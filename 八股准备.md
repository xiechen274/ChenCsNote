

# Mysql

## 分库分表

**分库分表** 是一种数据库优化技术，主要用于解决随着业务规模增长，数据库单一节点的性能瓶颈问题。它的目标是通过将数据水平或垂直切分，分布在多个数据库实例或表中，来提升数据库的性能、扩展性和稳定性。

### 1. **分库和分表的区别**
- **分库**：将数据按一定规则分散到多个数据库中，每个数据库存储数据的一部分。比如根据用户ID的范围，用户ID为1-10000的数据存储在一个库中，10001-20000的数据存储在另一个库中。
- **分表**：在同一个数据库实例内，把一张表按照某个字段（如ID）的范围或哈希值拆分成多个表。比如一张用户表`users`拆分成`users_1`，`users_2`等。

### 2. **分库分表的分类**

#### **水平切分（Sharding）**
- **水平分库**：把同一个业务的数据，按某个规则（如ID范围或哈希值）切分到不同的数据库实例中。不同的数据库存储相同结构的表，但表中存放的数据不同。
- **水平分表**：把一张表中的数据，按某个字段（如用户ID）进行切分，存储在多个相同结构的表中。

**场景**：水平切分适合数据量大、业务简单、单表数据增速快的情况。例如，一个电商平台的订单表会随着时间快速增长，通过水平切分来减轻单表压力。

#### **垂直切分（Vertical Partitioning）**
- **垂直分库**：根据业务模块的不同，把不同业务的数据分到不同的数据库中。比如，将用户数据存放在一个数据库，将订单数据存放在另一个数据库中。
- **垂直分表**：将一张表按列进行拆分，不同列存储在不同的表中。比如用户表中的基础信息（ID、用户名、性别等）放在一个表中，详细信息（地址、电话等）放在另一个表中。

**场景**：垂直切分适合业务复杂、单表列较多、部分业务增长较快的场景。例如，用户信息表中有很多字段，而查询时常常只用其中的一小部分字段，这时可以通过垂直切分来优化性能。

### 3. **分库分表的常见策略**

#### **哈希取模法**
根据某个字段（通常是ID）进行哈希运算，然后对库或者表的数量取模，决定数据的存储位置。  
- **优点**：实现简单，分布均匀，容易做到负载均衡。
- **缺点**：不支持跨库事务，扩容时要重新分布已有的数据，成本较高。

#### **范围切分法**
根据某个字段的范围划分，决定数据的存储位置。比如用户ID在1-10000的放在表A，10001-20000的放在表B。
- **优点**：扩展时较容易，只需要增加新的范围分区。
- **缺点**：数据增长不均匀时，可能会导致某些分区数据量过大，带来负载不均问题。

#### **一致性哈希法**
这种方法主要用于解决传统哈希取模在扩容时需要重新分布数据的问题。通过将数据和存储节点都映射到一个哈希环上，只需调整局部的数据即可完成扩容。
- **优点**：扩容时只需要调整部分数据，减少了迁移的成本。
- **缺点**：实现相对复杂。

### 4. **分库分表带来的挑战**
虽然分库分表可以提高数据库的性能和扩展性，但也带来了一些新的问题：
- **分布式事务**：跨库操作时，事务的一致性难以保证，可能需要引入分布式事务解决方案。
- **跨表查询复杂度增加**：查询需要跨多个表或库时，查询逻辑变得复杂，且性能降低。
- **数据迁移与扩容**：在需要增加新的库或表时，数据迁移成本较高。
- **开发维护成本**：分库分表的策略和规则增加了系统的复杂性，对开发人员要求较高。

### 5. **解决方案**
为了应对分库分表带来的问题，可以采用以下技术和工具：
- **中间件**：如 Mycat、ShardingSphere 等，可以帮助管理分库分表的路由、事务和查询等。
- **分布式事务框架**：如 Seata、TCC、Saga 等，提供了分布式事务的解决方案。
- **全局ID生成器**：如 Twitter 的 Snowflake 算法，用于生成唯一的分布式ID，确保分库分表后数据的一致性。

### 总结
分库分表是一种常见的数据库扩展技术，适合于数据量巨大、并发量高的场景。通过合理设计分库分表策略，可以有效解决单一数据库性能瓶颈问题，但同时也带来了诸如分布式事务、跨库查询等挑战。

# RabbitMQ

## 1.rabbitmq中的消息确认中消费者的ack机制和tcp有什么不同？

RabbitMQ中的消息确认机制和TCP的可靠数据传输虽然都是为了确保消息或数据的可靠传递，但它们的机制和应用场景有显著区别：

### 1. **消息确认机制（RabbitMQ）**
RabbitMQ中的消息确认机制主要用于确保消息在队列中不会丢失，特别是当消息被发送到消费者之后。消费者需要明确告知RabbitMQ它已经成功处理了某条消息，这个过程称为“ACK确认”。

- **过程**：当消费者收到一条消息时，RabbitMQ不会立即将该消息从队列中删除，而是等待消费者发送一个ACK确认信号。**如果消费者处理完消息后发送ACK确认，则RabbitMQ才会将该消息标记为已处理并删除**。如果消费者没有发出ACK，比如由于消费者崩溃或连接断开，**那么RabbitMQ会重新将该消息分配给其他消费者或等待当前消费者恢复。**
  
- **机制特点**：
  - **显式确认**：由消费者主动确认消息处理完成。
  - **消息重新投递**：如果没有收到ACK，RabbitMQ可以重新投递消息。
  - **不依赖传输层协议**：消息确认是应用层的逻辑，跟底层的网络协议无关。

### 2. **TCP的可靠数据传输**
TCP（Transmission Control Protocol）是一种传输层协议，负责在两个网络节点之间提供可靠的数据传输。它使用ACK机制来确保数据包正确、有序地传输到目标节点。

- **过程**：在TCP连接中，发送方会将数据分段成数据包并发送到接收方。每个数据包都有一个序列号。接收方收到数据包后，会向发送方发送一个ACK确认，告知发送方该数据包已经成功接收。发送方只有在收到ACK后才会认为传输成功，否则会重传该数据包。

- **机制特点**：
  - **隐式确认**：ACK由TCP协议自动生成和发送。
  - **数据包顺序控制**：TCP确保数据包按顺序传递，如果数据包丢失或乱序，接收方可以重新请求数据。
  - **重传机制**：如果发送方在一定时间内未收到ACK，则会自动重传丢失的数据包。
  - **基于传输层的协议**：TCP是底层传输层协议，直接与网络数据传输相关。

### 3. **主要区别**
| 特性         | RabbitMQ 消息确认                            | TCP 可靠传输                 |
| ------------ | -------------------------------------------- | ---------------------------- |
| **层次**     | 应用层（消息队列）                           | 传输层（网络协议）           |
| **确认触发** | 消费者显式确认（手动或自动）                 | 接收方隐式ACK                |
| **重传机制** | 没有ACK时，消息可重新投递到其他消费者        | 没有ACK时，数据包自动重传    |
| **目标**     | 确保消息成功被消费者处理                     | 确保数据包在网络传输中不丢失 |
| **顺序性**   | 不保证严格的消息顺序（需要额外配置实现顺序） | 确保数据包按顺序到达         |
| **传输介质** | 基于消息队列服务，跟底层网络传输无直接关系   | 基于网络数据传输协议         |

总结来说，RabbitMQ的消息确认是应用层级别的机制，确保消息被消费者正确处理，而TCP的可靠传输机制则是底层网络传输的协议，确保数据在网络中的正确传输和顺序性。两者在不同的层次上解决不同类型的可靠性问题。




# 代码生成器

```java
package codedemo;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import org.junit.Test;

/**
 * @author
 * @since 2018/12/13
 */
public class CodeGenerator {

    @Test
    public void run() {

        // 1、创建代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 2、全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty("user.dir");
        gc.setOutputDir("/Users/xiechen/Library/Mobile Documents/com~apple~CloudDocs/谷粒学院/backend/guli_parent/service/service_cms/src/main/java");

        gc.setAuthor("testjava");
        gc.setOpen(false); //生成后是否打开资源管理器
        gc.setFileOverride(false); //重新生成时文件是否覆盖

        //UserServie
        gc.setServiceName("%sService"); //去掉Service接口的首字母I

        gc.setIdType(IdType.ID_WORKER_STR); //主键策略
        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型
        gc.setSwagger2(true);//开启Swagger2模式

        mpg.setGlobalConfig(gc);

        // 3、数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("15959244158");
        dsc.setDbType(DbType.MYSQL);
        mpg.setDataSource(dsc);

        // 4、包配置
        PackageConfig pc = new PackageConfig();
        pc.setModuleName("educms"); //模块名
        //包  com.atguigu.eduservice
        pc.setParent("com.atguigu");
        //包  com.atguigu.eduservice.controller
        pc.setController("controller");
        pc.setEntity("entity");
        pc.setService("service");
        pc.setMapper("mapper");
        mpg.setPackageInfo(pc);

        // 5、策略配置
        StrategyConfig strategy = new StrategyConfig();

        strategy.setInclude("crm_banner");

        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
        strategy.setTablePrefix(pc.getModuleName() + "_"); //生成实体时去掉表前缀

        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作

        strategy.setRestControllerStyle(true); //restful api风格控制器
        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符

        mpg.setStrategy(strategy);


        // 6、执行
        mpg.execute();
    }
}
```



技术栈

<img src="C:%5CUsers%5C%E8%B0%A2%E9%9A%86%E6%9D%B0%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240826194538849.png" alt="image-20240826194538849" style="zoom:50%;" />

实现功能

![image-20240826194600941](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240826194600941.png)

# MyBatis-plus

## basemapper

1. **`insert(T entity)`**  
   - **作用**：插入一条记录。  
   - **参数**：`entity` 实体对象。  
   - **返回值**：影响行数。

2. **`deleteById(Serializable id)`**  
   - **作用**：根据主键 ID 删除一条记录。  
   - **参数**：`id` 主键 ID。  
   - **返回值**：影响行数。

3. **`deleteBatchIds(Collection<? extends Serializable> idList)`**  
   - **作用**：批量根据 ID 删除记录。  
   - **参数**：`idList` 主键 ID 集合。  
   - **返回值**：影响行数。

4. **`updateById(T entity)`**  
   - **作用**：根据主键 ID 更新记录。  
   - **参数**：`entity` 实体对象。  
   - **返回值**：影响行数。

5. **`selectById(Serializable id)`**  
   - **作用**：根据主键 ID 查询一条记录。  
   - **参数**：`id` 主键 ID。  
   - **返回值**：实体对象。

6. **`selectBatchIds(Collection<? extends Serializable> idList)`**  
   - **作用**：根据多个主键 ID 批量查询记录。  
   - **参数**：`idList` 主键 ID 集合。  
   - **返回值**：实体对象列表。

7. **`selectList(Wrapper<T> queryWrapper)`**  
   - **作用**：根据条件查询多条记录。  
   - **参数**：`queryWrapper` 查询条件封装。  
   - **返回值**：实体对象列表。

8. **`selectPage(IPage<T> page, Wrapper<T> queryWrapper)`**  
   - **作用**：分页查询。  
   - **参数**：`page` 分页参数, `queryWrapper` 查询条件。  
   - **返回值**：分页结果对象。

几种主键增长的策略，主要用的是mp自带的

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240826224602920.png" alt="image-20240826224602920" style="zoom:50%;" />

下面这两个自带的策略不调整的话会自动匹配 

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240826224714366.png" alt="image-20240826224714366" style="zoom:50%;" />

## Mp自动填充字段

这个方法可以根据**实际场景**以及自己的**个人喜好进行设置**不一定都是自动填充字段来确定

- 手动方式

![](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240826230258712.png)

- 自动填充：在实体类的属性前面加上注解 TableField

![image-20240826232437943](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240826232437943.png)

之后自己实现一个类，实现一些接口

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240826232504180.png" alt="image-20240826232504180" style="zoom:67%;" />

## Mp中的乐观锁

- 应用场景：12306抢票系统

乐观锁的实现

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240827085939705.png" alt="image-20240827085939705" style="zoom:50%;" />

乐观锁是一种并发控制机制，用于处理多用户同时访问和修改同一份数据时的冲突问题。与悲观锁不同，乐观锁的核心思想是假设多个事务并发修改同一资源的可能性较低，因此不对数据进行锁定，而是在数据更新时检查是否发生冲突。

### 乐观锁的工作原理：
1. **读取数据：** 当用户读取数据时，不加锁，也不阻止其他用户同时读取或修改数据。
  
2. **版本控制：** 数据表中通常会有一个版本号字段（如 `version` 字段），记录数据的版本号。每次数据被修改时，版本号都会递增。

3. **修改数据：** 当用户对数据进行修改并尝试提交时，系统会检查该数据的当前版本号是否与用户读取时的版本号一致。

4. **判断一致性：**
   - **一致：** 如果版本号一致，说明在用户读取数据到提交修改的过程中，数据没有被其他用户修改过，更新操作可以安全执行，同时版本号加1。
   - **不一致：** 如果版本号不一致，说明数据在用户读取之后已经被其他用户修改过，更新操作将被拒绝，用户可以选择重新获取数据并再次尝试修改。

### 乐观锁的适用场景：
- **多读少写的场景：** 当数据读取频繁，而写入较少时，乐观锁是理想的选择，因为它避免了频繁的锁操作带来的性能开销。
- **对冲突容忍度较高的场景：** 如果系统可以接受较高的并发冲突率（即用户可能需要多次尝试提交更新），乐观锁是合适的。

### 举个例子：
假设有一个商品库存表，库存量随着订单的生成而减少。
- 用户 A 和用户 B 同时读取了一件商品的库存量（假设为 10）。
- 用户 A 生成了一个订单，并将库存减少到 9，版本号从 1 变为 2。
- 用户 B 也尝试生成订单，但系统检测到版本号不一致（用户 B 看到的是版本号 1，而数据库中的版本号已经是 2），因此拒绝用户 B 的更新操作，提示用户重新获取最新的库存数据。

### 乐观锁的优势：
- **高并发性能：** 因为没有实际的锁定操作，所以系统性能更高。
- **更好的用户体验：** 在高并发环境下，用户不需要等待锁释放，只需在版本冲突时重新尝试提交。

乐观锁虽然不是真正的“锁”，但通过版本号或时间戳等机制实现了对数据一致性的保护，适用于需要高并发、对冲突容忍度较高的系统。

**实现**

![image-20240827092519582](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240827092519582.png)

## 悲观锁

悲观锁就是别的事务在操作的时候，其他的事务没办法进行，不能并发，效率低

## 查询

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240827094955041.png" alt="image-20240827094955041" style="zoom:50%;" />

分页查询<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240827094936531.png" alt="image-20240827094936531" style="zoom:33%;" />

## 删除

主要是mp里面多了逻辑删除，增强数据安全

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240827100413114.png" alt="image-20240827100413114" style="zoom:50%;" />

## 复杂查询

在 MyBatis-Plus 中，`Wrapper` 是一个用于构建动态 SQL 查询条件的工具类，它提供了链式调用的方式来构造复杂的查询条件。`Wrapper` 是一个抽象类，常见的实现类有 `QueryWrapper`、`UpdateWrapper` 和 `LambdaQueryWrapper` 等。

### `Wrapper` 常见构造器和方法

1. **`QueryWrapper`**:
   用于构建查询条件，可以通过链式调用来构造 `WHERE` 条件。

   ```java
   QueryWrapper<User> queryWrapper = new QueryWrapper<>();
   queryWrapper
       .eq("name", "Tom")   // 等于条件
       .gt("age", 20)        // 大于条件
       .like("email", "@qq.com") // 模糊匹配条件
       .orderByDesc("id");   // 按ID倒序排列
   ```

   这个last可以拼接语句
   
   ![](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920201759150.png)
   
2. **`UpdateWrapper`**:
   用于构建更新条件，可以设置更新的字段和值。

   ```java
   UpdateWrapper<User> updateWrapper = new UpdateWrapper<>();
   updateWrapper
       .eq("name", "Tom")   // 以 name = 'Tom' 为条件
       .set("age", 30);     // 将 age 更新为 30
   ```

3. **`LambdaQueryWrapper`**:
   这是 `QueryWrapper` 的 lambda 表达式版本，利用 Java 的 lambda 特性，可以避免因字段名写错而导致的错误。

   ```java
   LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
   lambdaQueryWrapper
       .eq(User::getName, "Tom") // 使用方法引用来指定条件
       .gt(User::getAge, 20);
   ```

### 常用方法

- **`eq`**: 等于条件，`eq(String column, Object val)`，如 `eq("name", "Tom")`。
- **`ne`**: 不等于条件，`ne(String column, Object val)`，如 `ne("status", 1)`。
- **`gt`**: 大于条件，`gt(String column, Object val)`，如 `gt("age", 20)`。
- **`lt`**: 小于条件，`lt(String column, Object val)`，如 `lt("age", 30)`。
- **`ge`**: 大于等于条件，`ge(String column, Object val)`，如 `ge("age", 20)`。
- **`le`**: 小于等于条件，`le(String column, Object val)`，如 `le("age", 30)`。
- **`like`**: 模糊匹配，`like(String column, Object val)`，如 `like("name", "Tom")`。
- **`between`**: 范围查询，`between(String column, Object val1, Object val2)`，如 `between("age", 20, 30)`。
- **`isNull`**: 判断是否为 `NULL`，`isNull(String column)`，如 `isNull("email")`。
- **`isNotNull`**: 判断是否不为 `NULL`，`isNotNull(String column)`，如 `isNotNull("email")`。
- **`orderByDesc`**: 按某列倒序排列，`orderByDesc(String... columns)`，如 `orderByDesc("id")`。
- **`orderByAsc`**: 按某列升序排列，`orderByAsc(String... columns)`，如 `orderByAsc("name")`。

### 综合示例
假设你要查询名字叫 "Tom"，年龄大于 20 且邮箱包含 `@qq.com` 的用户，并按 ID 倒序排列：

```java
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
queryWrapper
    .eq("name", "Tom")
    .gt("age", 20)
    .like("email", "@qq.com")
    .orderByDesc("id"); 

List<User> users = userMapper.selectList(queryWrapper);
```

或者使用 `LambdaQueryWrapper`:

```java
LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
lambdaQueryWrapper
    .eq(User::getName, "Tom")
    .gt(User::getAge, 20)
    .like(User::getEmail, "@qq.com")
    .orderByDesc(User::getId);

List<User> users = userMapper.selectList(lambdaQueryWrapper);
```

通过 `Wrapper`，MyBatis-Plus 提供了一种简单而强大的方式来构建动态查询条件，极大地方便了开发者在日常开发中的使用。

# 注解



- ```java
  @RequestBody(required = false) CourseFrontVo courseFrontVo//不必要参数
  ```

@Request

- 提交json数据格式的请求
- Controller注解需要用post请求
- 当方法参数使用Path变量的时候可以自动封装json数据

## @ControllerAdvice

`@ControllerAdvice` 是 Spring Framework 中的一个注解，用于定义全局的异常处理、数据绑定和模型增强功能。它可以被应用于一个类，以便提供全局的处理机制，主要用于增强控制器的功能和统一异常处理。

### 主要功能

1. **全局异常处理**：
   使用 `@ControllerAdvice` 可以定义一个或多个 `@ExceptionHandler` 方法来处理全局范围内的异常。这样可以避免在每个控制器中都重复编写异常处理代码。

2. **全局数据绑定**：
   可以通过 `@ControllerAdvice` 提供全局的 `@ModelAttribute` 方法，用于预处理控制器中的模型数据。这些方法会在所有控制器的处理方法调用之前执行。

3. **全局模型属性**：
   使用 `@ControllerAdvice` 可以定义全局的 `@ModelAttribute` 方法，以便向所有控制器的模型中添加通用属性。

4. **全局初始化数据**：
   可以在 `@ControllerAdvice` 类中使用 `@InitBinder` 注解来定义全局的绑定规则，例如定制数据格式化和解析。

### 使用示例

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.InitBinder;

@ControllerAdvice
public class GlobalControllerAdvice {

    // 全局异常处理
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // 全局数据绑定
    @ModelAttribute("globalAttribute")
    public String globalAttribute() {
        return "This is a global attribute";
    }

    // 全局初始化数据
    @InitBinder
    public void initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));
    }
}
```

### 解释

- **全局异常处理**：
  `@ExceptionHandler` 注解用于定义处理特定异常的逻辑。通过在 `@ControllerAdvice` 类中定义这些方法，可以为所有控制器提供统一的异常处理。

- **全局数据绑定**：
  `@ModelAttribute` 注解的方法会在每个控制器方法调用之前执行，能够为模型添加通用属性。

- **全局初始化数据**：
  `@InitBinder` 注解的方法用于定义如何绑定和格式化请求参数，可以全局设置数据绑定的规则。

### 总结

`@ControllerAdvice` 是 Spring 提供的一个强大的注解，用于集中处理控制器层的异常、数据绑定和模型属性。它有助于提高代码的可维护性和重用性，确保全局行为的一致性。

## @PostConstruct



`@PostConstruct` 是 Java 中的一种注解，通常用于在一个类实例化之后进行初始化操作。它会在依赖注入完成后，执行带有这个注解的方法，因此常用于一些初始化任务。

### `@PostConstruct` 的使用场景：
- 当你需要在 Spring Bean 初始化后执行一些额外的操作，如资源的连接、初始化服务等。
- 它确保这个方法在 Spring 完成依赖注入之后运行，但在其他初始化方法（如 `afterPropertiesSet()` 或者 `init-method`）之前。

### `@PostConstruct` 的典型工作流程：
1. **Spring 启动时实例化 Bean**：Spring 会扫描到带有 `@Service`, `@Component` 等注解的类，并将其实例化。
2. **依赖注入完成**：Spring 框架会为 Bean 注入其依赖，比如通过 `@Autowired` 注入其他服务或资源。
3. **执行 `@PostConstruct` 标注的方法**：当依赖注入完成后，Spring 会自动调用标注了 `@PostConstruct` 的方法，确保 Bean 已经完全初始化，并可以安全地进行操作。

### 示例解释：
```java
@Service
public class CanalService {

    @Autowired
    private CanalConnector canalConnector;

    @PostConstruct
    public void start() {
        // 当 CanalService 被 Spring 实例化并依赖注入完成后，start 方法会自动调用
        new Thread(() -> {
            while (true) {
                // 拉取数据
                Message message = canalConnector.getWithoutAck(100); // 获取指定数量的消息
                long batchId = message.getId();
                int size = message.getEntries().size();

                if (batchId != -1 && size > 0) {
                    handleEntries(message.getEntries());
                }

                canalConnector.ack(batchId); // 确认消费成功
            }
        }).start();
    }

    private void handleEntries(List<CanalEntry.Entry> entries) {
        // 处理 Canal 中拉取的 binlog 日志
    }
}
```

### 解释流程：
1. **实例化和依赖注入**：
   - `CanalService` 被 Spring 容器管理，Spring 自动创建这个类的实例并注入 `canalConnector`（通过 `@Autowired` 注入）。
   
2. **调用 `@PostConstruct` 方法**：
   - 当 `CanalService` 的实例被创建并且 `canalConnector` 成功注入之后，Spring 会自动调用 `start()` 方法（因为它被 `@PostConstruct` 标记）。
   
3. **启动逻辑**：
   - 在 `start()` 方法中，开启一个新线程，这个线程负责不断从 Canal 服务器拉取数据并处理。
   

因此，`@PostConstruct` 确保了 `start()` 方法在依赖注入完成后调用，防止因依赖未注入而导致的错误。

### 流程图大纲：

1. **Spring Boot 启动**
   - 实例化 `CanalService`
2. **依赖注入完成**
   - 注入 `CanalConnector`
3. **调用 `@PostConstruct` 标记的方法**
   - 调用 `start()` 方法
4. **启动线程**
   - 循环监听 Canal binlog
5. **处理日志**
   - 拉取并处理数据

## 构造类

```
//生成所有有参数的注解
@AllArgsConstructor
//生成吴参数构造
@NoArgsConstructor
```

# 依赖传递

- 如果2中包含了1的依赖，3添加了2，这样3就不需要添加1作为依赖 

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240901214646252.png" alt="image-20240901214646252" style="zoom:50%;" />

# 依赖

- Logback

需要先注释掉原有的log配置

- swagger

# 前端

## 文本编辑器组件

![image-20240912204037619](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240912204037619.png)



引入Scripts的时候要先引入vue.js在引入.router

## js

在 JavaScript 中，定义对象方法时，可以使用传统语法和 ES6 的简写语法。

### 传统方法定义
在传统的 JavaScript 中，定义对象的方法需要使用 `function` 关键字。

```javascript
const person1 = {
    sayHi: function() {
        console.log("Hi");
    }
};
person1.sayHi(); // 输出: "Hi"
```

### ES6 方法定义简写
在 ES6 中，方法可以使用更简洁的语法定义。你不再需要使用 `function` 关键字，直接在对象内定义方法即可。

```javascript
const person2 = {
    sayHi() {
        console.log("Hi");
    }
};
person2.sayHi(); // 输出: "Hi"
```

### 总结
- 传统方法：需要使用 `function` 关键字。
- ES6 简写：省略了 `function` 关键字，语法更加简洁。

![image-20240902221703673](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240902221703673.png)

### 箭头函数

箭头函数是 ES6 引入的一种更加简洁的函数表达方式。与传统函数相比，箭头函数在语法和行为上都有一些不同之处。

### 箭头函数的基本语法

```javascript
const functionName = (参数1, 参数2, ...) => {
    // 函数体
};
```

如果函数体只有一行代码，且需要返回一个表达式的结果，可以省略 `{}` 和 `return` 关键字：

```javascript
const functionName = (参数1, 参数2, ...) => 表达式;
```

### 使用箭头函数定义方法

需要注意的是，箭头函数**不能**像普通函数那样直接用来定义对象的方法，因为箭头函数不绑定 `this`。在对象方法中使用箭头函数可能导致 `this` 指向全局对象或 `undefined`，而不是当前对象。

#### 例子

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240902222211584.png" alt="image-20240902222211584" style="zoom:50%;" />

```javascript
const person = {
    name: 'John',
    // 传统函数
    sayHi: function() {
        console.log(`Hi, I'm ${this.name}`);
    },
    // 箭头函数
    sayHello: () => {
        console.log(`Hello, I'm ${this.name}`);
    }
};

person.sayHi();    // 输出: "Hi, I'm John"
person.sayHello(); // 输出: "Hello, I'm undefined"
```

### `this` 在箭头函数中的行为

- **箭头函数**不会创建自己的 `this`，它会捕获定义时的上下文中的 `this` 值，作为自己的 `this` 值。
- **普通函数**会根据调用的方式动态地绑定 `this`。

#### 对象方法中的箭头函数
由于箭头函数不绑定 `this`，它在对象方法中的行为可能与预期不符。通常情况下，在定义对象方法时，建议使用普通函数表达式而不是箭头函数。

### 总结
- 箭头函数提供了更简洁的语法，并且自动捕获外部作用域的 `this`，这对于回调函数或需要保持上下文的场景非常有用。
- 在对象方法中，尽量避免使用箭头函数，因为它不会绑定 `this`，可能导致意外行为。

## vue

![image-20240905230255422](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240905230255422.png)

在Vue.js中，组件是一个独立且可复用的代码块，用于构建用户界面的基本元素。它们可以包含HTML、CSS和JavaScript，从而使开发者可以将界面分割成更小、更易于管理的部分。以下是关于Vue组件的详细介绍：

### 1. 组件的定义
在Vue.js中，组件可以通过两种方式定义：**全局注册**和**局部注册**。

#### 全局注册
```javascript
Vue.component('my-component', {
  template: '<div>A custom component!</div>'
});
```
在这个例子中，`my-component` 是一个全局组件，注册后可以在任何Vue实例的模板中使用。

#### 局部注册
```javascript
var Child = {
  template: '<div>A custom component!</div>'
}

new Vue({
  el: '#app',
  components: {
    'my-component': Child
  }
});
```
局部组件只在它们被注册的Vue实例的范围内有效。

### 2. 组件的使用
一旦组件被注册，无论是全局还是局部，你都可以像使用HTML元素一样在模板中使用它：
```html
<my-component></my-component>
```

### 3. 组件的基础结构
一个Vue组件通常由三个部分组成：`template`、`script`和`style`。

```vue
<template>
  <div class="my-component">
    <!-- HTML 内容 -->
  </div>
</template>

<script>
export default {
  name: 'MyComponent',
  data() {
    return {
      // 组件数据
    };
  },
  methods: {
    // 组件方法
  }
}
</script>

<style scoped>
.my-component {
  /* 样式定义 */
}
</style>
```
- **template**: 用于定义组件的HTML结构。
- **script**: 包含组件的逻辑，如数据、方法和生命周期钩子等。
- **style**: 组件的样式，可以使用`scoped`关键字使样式仅作用于当前组件。

### 4. 父子组件通信
Vue组件之间的通信主要通过 `props` 和 `events` 实现。

#### 使用 `props` 传递数据
父组件可以通过 `props` 向子组件传递数据。
```javascript
Vue.component('child', {
  props: ['message'],
  template: '<p>{{ message }}</p>'
});
```
父组件在使用子组件时，可以这样传递数据：
```html
<child message="Hello from parent"></child>
```

#### 使用事件传递消息
子组件可以通过 `$emit` 触发事件向父组件发送消息。
```javascript
Vue.component('child', {
  template: '<button @click="notify">Click me</button>',
  methods: {
    notify() {
      this.$emit('notify', 'Hello from child');
    }
  }
});
```
父组件可以监听子组件触发的事件：
```html
<child @notify="handleNotify"></child>
```

### 5. 组件的生命周期
每个Vue组件都有一系列生命周期钩子函数，从组件创建到销毁，这些钩子函数可以让你在不同的生命周期阶段执行特定的代码。例如：
- `created`: 在实例创建完成后立即调用。
- `mounted`: 在DOM挂载完成后调用。
- `updated`: 数据更新导致的重新渲染后调用。
- `destroyed`: 在实例销毁之后调用。

### 6. 插槽 (Slots)
插槽允许父组件向子组件传递内容，常用于构建灵活的组件。
```vue
<template>
  <div>
    <slot></slot>
  </div>
</template>
```
在父组件中，可以这样使用插槽：
```html
<child>
  <p>This is passed to the child component!</p>
</child>
```

### 7. 动态组件
Vue还支持动态组件，即根据某个条件动态加载或切换不同的组件：
```vue
<component :is="currentComponent"></component>
```
这里的`currentComponent`是一个绑定到当前组件名称的变量，Vue会根据这个变量的值来渲染不同的组件。

通过使用组件，Vue.js能够帮助开发者构建模块化、可维护的应用程序。每个组件都是一个独立的模块，具有自己的数据、方法和样式，使得复杂的应用程序能够被拆分为更易管理的小部分。

## axious

理解了，你的意思是为什么在箭头函数 `(response) => {}` 中，`response` 后面不需要加括号。

在箭头函数中，参数的使用方式有以下规则：

1. **单个参数**：如果箭头函数只有一个参数，参数名称后面是不需要加括号的。例如：
   ```javascript
   response => {
       // 函数体
   }
   ```
   这就是为什么你看到的是 `response => {}`，而不是 `(response) => {}`。两者的功能完全一样，只是 `response => {}` 更简洁。

2. **多个参数**：如果箭头函数有多个参数，参数列表必须用括号括起来。例如：
   ```javascript
   (param1, param2) => {
       // 函数体
   }
   ```

3. **没有参数**：如果箭头函数没有参数，必须使用一对空括号来表示。例如：
   ```javascript
   () => {
       // 函数体
   }
   ```

总结一下，当箭头函数只有一个参数时，括号是可选的。如果你喜欢简洁的代码风格，可以省略括号；如果你想让代码更具可读性或保持一致性，可以加上括号，两种方式在功能上没有差别。

## npm

node.js的包管理工具，相当于后段的maven

![image-20240904145527720](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240904145527720.png)

- 配置镜像
- ![image-20240904145639022](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240904145639022.png)
- npm config set registry https://registry.npmmirror.com/最新的淘宝url

```js
#使用 npm install 安装依赖包的最新版，
#模块安装的位置:项目目录\node_modules
#安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本 #同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的 <dependencies>
npm install jquery
#npm管理的项目在备份和传输的时候一般不携带node_modules文件夹
npm install #根据package.json中的配置下载依赖，初始化项目 #如果安装时想指定特定的版本
npm install jquery@2.1.x #devDependencies节点:开发时的依赖包，项目打包到生产环境的时候不包含的依赖
#使用 -D参数将依赖添加到devDependencies节点
npm install --save-dev eslint
#或
npm install -D eslint
#全局安装 #Node.js全局安装的npm包和工具的位置:用户目录\AppData\Roaming\npm\node_modules #一些命令行工具常使用全局安装的方式
npm install -g webpack
```

![image-20240904150232393](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240904150232393.png)

## Bable

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240904150445769.png" alt="image-20240904150445769" style="zoom: 33%;" />

![image-20240904151051226](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240904151051226.png)

## 模块化

将前端代码模块化，方便各种不同的组件调用，不同js与js之间可以调用

![image-20240904151311558](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240904151311558.png)

## Webpack

Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按 照指定的规则生成对应的静态资源。

从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的 请求

- ```npm
  npm install -g webpack webpack-cli
  ```

![image-20240905150450096](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240905150450096.png)

## 经典代码

根据路径中的id来实现具体方法实现，这里是通过是否有id来判断是删除还是添加

![image-20240905231527569](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240905231527569.png)

vue中监听路由变化

![image-20240905233350357](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240905233350357.png)

# 后段



- 配置不需要数据库的启动类

```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
```

- 自动初始化成员变量

  ![image-20240906213628606](/Users/xiechen/Library/Application Support/typora-user-images/image-20240906213628606.png)

- 在上传用户头像的时候使用时间戳进行分类，UUID进行唯一的值的分类，日期类别是工具类joda.time这个依赖

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240908161023472.png" alt="image-20240908161023472" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240908161135639.png" alt="image-20240908161135639" style="zoom: 50%;" />

![](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240908161817446.png)

## nginx

在 macOS 中配置 Nginx 需要经过以下几个步骤：

### 1. 安装 Nginx
可以使用 Homebrew 来安装 Nginx，Homebrew 是 macOS 上常用的包管理工具。

打开终端，运行以下命令：

```bash
brew install nginx
```

安装完成后，查看 Nginx 版本确认安装成功：

```bash
nginx -v
```

### 2. 启动 Nginx
安装完成后，可以使用以下命令启动 Nginx：

```bash
sudo nginx
```

启动后可以在浏览器中访问 `http://localhost:8080`，默认端口为8080。如果看到欢迎页面，说明 Nginx 运行成功。

### 3. 修改 Nginx 配置
Nginx 的默认配置文件位于 `/usr/local/etc/nginx/nginx.conf`。可以使用你喜欢的文本编辑器来编辑这个文件，比如：

```bash
sudo vim /usr/local/etc/nginx/nginx.conf
```

一些常见的修改内容包括：
- 更改默认的端口号（例如将 8080 改为 80）
- 配置虚拟主机
- 配置静态文件路径
- 反向代理设置等

#### 更改端口：
找到 `server` 块中的 `listen` 行，将其改为 `80`，这样 Nginx 就会在默认的 HTTP 端口上运行。

```nginx
server {
    listen       80;
    server_name  localhost;

    location / {
        root   html;
        index  index.html index.htm;
    }
}
```

#### 配置虚拟主机：
你可以通过在配置文件中添加多个 `server` 块来配置多个虚拟主机。

```nginx
server {
    listen       80;
    server_name  example.com;
    
    location / {
        root   /path/to/your/site;
        index  index.html;
    }
}
```

### 4. 重新加载 Nginx 配置
修改完配置文件后，使用以下命令重新加载 Nginx：

```bash
sudo nginx -s reload
```

### 5. 停止 Nginx
如果需要停止 Nginx，可以使用以下命令：

```bash
sudo nginx -s stop
```

### 6. 设置自动启动
如果想让 Nginx 随系统启动，可以将其加入 `launchctl` 服务中。不过在 macOS 上，通常是通过手动控制 Nginx 的运行。

### 7. 检查错误日志

![image-20240909115804858](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240909115804858.png)

如果 Nginx 启动失败，可以查看错误日志进行排查。日志文件一般位于 `/usr/local/var/log/nginx/`。

通过这些步骤，你应该能够成功在 macOS 上配置并运行 Nginx。如果你需要进一步的配置帮助，欢迎继续提问。

## 数据库部分

![image-20240909145847698](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240909145847698.png)

- edu-subject的存储结构里面有parent_id 0代表是一级目录 2代表是二级目录以此类推

![image-20240909145757206](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240909145757206.png)

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240910204735085.png" alt="image-20240910204735085" style="zoom:50%;" />

- 表之间的关系
- <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240910205013405.png" alt="image-20240910205013405" style="zoom:67%;" />

## Redis

进入客户端



```shell
#启动redis客户端
redis-cli

#密码验证登陆
AUTH 15959244158

#退出客户端
exit
```

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920212514629.png" alt="image-20240920212514629" style="zoom: 33%;" />



- **由于首页访问量大，所以吧首页数据存入redis做缓存解决访问速度**

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920212117612.png" alt="image-20240920212117612" style="zoom:50%;" />

redis整合SpringBoot

### SpringCache

Spring Cache 是 Spring Framework 提供的缓存抽象框架，它简化了在 Spring 应用中使用缓存的复杂性。通过 Spring Cache，开发者可以轻松地将缓存集成到应用程序中，减少数据库查询和其他耗时操作，提高性能。

#### Spring Cache 的核心概念

1. **缓存抽象**：Spring Cache 提供了一个抽象层，支持各种缓存提供者（如 Ehcache、Caffeine、Redis 等），开发者可以切换缓存实现而不改变业务代码。
  
2. **注解驱动的缓存**：Spring Cache 提供了多个注解来简化缓存的使用：
   - `@Cacheable`: 用于标注方法，表示返回值会被缓存。当相同的输入再次调用时，缓存会返回已缓存的结果，而不执行方法。
   - `@CachePut`: 标注的方法每次都会被调用，并且将结果存入缓存，用于更新缓存。
   - `@CacheEvict`: 用于从缓存中移除特定键的缓存数据。
   - `@Caching`: 用于组合多个缓存注解。

3. **缓存管理器 (Cache Manager)**：缓存管理器是负责管理缓存的核心组件。Spring 支持多种缓存管理器，如 `ConcurrentMapCacheManager`（默认）和 `RedisCacheManager`，用户可以根据需要选择或配置。

4. **缓存键和条件**：
   - 默认情况下，Spring Cache 使用方法的参数作为缓存键，可以通过 `key` 属性自定义缓存键生成。
   - 使用 `condition` 和 `unless` 属性来控制缓存行为，比如只有满足条件时才缓存结果。

#### 基本用法

1. **引入依赖**：
   在 `pom.xml` 中添加 Spring Cache 依赖（如果使用的是 Spring Boot）：
   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-cache</artifactId>
   </dependency>
   ```

2. **启用缓存**：
   在配置类中通过 `@EnableCaching` 注解启用缓存支持：
   ```java
   @Configuration
   @EnableCaching
   public class CacheConfig {
       // 配置缓存管理器（可选）
   }
   ```

3. **使用注解**：
   在需要缓存的方法上使用注解：
   ```java
   @Service
   public class UserService {
       @Cacheable(value = "users", key = "#id")
       public User getUserById(Long id) {
           // 假设这是一个耗时的数据库查询
           return userRepository.findById(id);
       }
   }
   ```

   这样，`getUserById` 方法的结果将被缓存，后续调用相同的 `id` 将直接从缓存中读取。

#### 配置缓存

Spring Cache 支持多种缓存实现。以下是常见的两种缓存配置：

1. **使用内存缓存（ConcurrentMapCache）**：
   这是默认的缓存实现，不需要额外配置。适用于小型应用或开发阶段的缓存需求。

2. **使用 Redis 缓存**：
   如果要使用 Redis 作为缓存存储，可以在配置中定义 RedisCacheManager：
   ```java
   @Configuration
   public class CacheConfig {
       @Bean
       public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
           RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()
               .entryTtl(Duration.ofMinutes(10)) // 设置缓存过期时间
               .disableCachingNullValues();
           return RedisCacheManager.builder(redisConnectionFactory)
               .cacheDefaults(cacheConfig)
               .build();
       }
   }
   ```

#### Spring Cache 的优点

1. **灵活性**：支持多种缓存提供者，可以根据应用需求选择合适的缓存实现。
2. **简化缓存逻辑**：通过注解方式，简化了缓存的实现逻辑，开发者可以专注于业务代码。
3. **可扩展性**：可以自定义缓存键生成、缓存管理器等，满足复杂的缓存需求。

Spring Cache 适用于需要提高性能、减少重复计算或数据库查询的场景。

过程就是在ServiceImp上添加缓存注解

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240922100249597.png" alt="image-20240922100249597" style="zoom:33%;" />

![image-20240922102118642](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240922102118642.png)

![image-20240922102333275](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240922102333275.png)

第三个对应的是删除作用，**删除的时候把原来的缓存给删除**

# EaxyExcel

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240909151005709.png" alt="image-20240909151005709" style="zoom: 67%;" />

```java
package com.atguigu.demo;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import org.junit.Test;

/**
 * @author
 * @since 2018/12/13
 */
public class CodeGenerator {

    @Test
    public void run() {

        // 1、创建代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 2、全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty("user.dir");
        gc.setOutputDir("/Users/xiechen/Library/Mobile Documents/com~apple~CloudDocs/谷粒学院/guli_parent/service/service_edu" + "/src/main/java");

        gc.setAuthor("testjava");
        gc.setOpen(false); //生成后是否打开资源管理器
        gc.setFileOverride(false); //重新生成时文件是否覆盖

        //UserServie
        gc.setServiceName("%sService");	//去掉Service接口的首字母I

        gc.setIdType(IdType.ID_WORKER_STR); //主键策略
        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型
        gc.setSwagger2(true);//开启Swagger2模式

        mpg.setGlobalConfig(gc);

        // 3、数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("15959244158");
        dsc.setDbType(DbType.MYSQL);
        mpg.setDataSource(dsc);

        // 4、包配置
        PackageConfig pc = new PackageConfig();
        pc.setModuleName("eduservice"); //模块名
        //包  com.atguigu.eduservice
        pc.setParent("com.atguigu");
        //包  com.atguigu.eduservice.controller
        pc.setController("controller");
        pc.setEntity("entity");
        pc.setService("service");
        pc.setMapper("mapper");
        mpg.setPackageInfo(pc);

        // 5、策略配置
        StrategyConfig strategy = new StrategyConfig();

        strategy.setInclude("edu_subject");

        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
        strategy.setTablePrefix(pc.getModuleName() + "_"); //生成实体时去掉表前缀

        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作

        strategy.setRestControllerStyle(true); //restful api风格控制器
        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符

        mpg.setStrategy(strategy);


        // 6、执行
        mpg.execute();
    }
}

```

# 技术

## 分页条件查询

根据前端传过来的条件进行拼接，查询完之后提取出前端需要的数据封装到map里面，然后返回map

```java
//2 根据讲师id查询所讲课程
QueryWrapper<EduCourse> wrapper = new QueryWrapper<>();
//判断条件值是否为空，不为空拼接
if(!StringUtils.isEmpty(courseFrontVo.getSubjectParentId())) { //一级分类
    wrapper.eq("subject_parent_id",courseFrontVo.getSubjectParentId());
}
if(!StringUtils.isEmpty(courseFrontVo.getSubjectId())) { //二级分类
    wrapper.eq("subject_id",courseFrontVo.getSubjectId());
}
if(!StringUtils.isEmpty(courseFrontVo.getBuyCountSort())) { //关注度
    wrapper.orderByDesc("buy_count");
}
if (!StringUtils.isEmpty(courseFrontVo.getGmtCreateSort())) { //最新
    wrapper.orderByDesc("gmt_create");
}

if (!StringUtils.isEmpty(courseFrontVo.getPriceSort())) {//价格
    wrapper.orderByDesc("price");
}

baseMapper.selectPage(pageParam,wrapper);

List<EduCourse> records = pageParam.getRecords();
long current = pageParam.getCurrent();
long pages = pageParam.getPages();
long size = pageParam.getSize();
long total = pageParam.getTotal();
boolean hasNext = pageParam.hasNext();//下一页
boolean hasPrevious = pageParam.hasPrevious();//上一页

//把分页数据获取出来，放到map集合
Map<String, Object> map = new HashMap<>();
map.put("items", records);
map.put("current", current);
map.put("pages", pages);
map.put("size", size);
map.put("total", total);
map.put("hasNext", hasNext);
map.put("hasPrevious", hasPrevious);
   //map返回
        return map;
```

## 微信扫码登录

### **json字符串转换为map**

**gson.fromJson(accessTokenInfo, HashMap.class);**

```java
//使用json转换工具 Gson
//第一个参数是json字符串，第二个是转换的类型
Gson gson = new Gson();
HashMap mapAccessToken = gson.fromJson(accessTokenInfo, HashMap.class);
String access_token = (String)mapAccessToken.get("access_token");
String openid = (String)mapAccessToken.get("openid");
```

### OAuth2

OAuth 2.0（Open Authorization 2.0）是一个开放标准协议，用于允许用户授权第三方应用访问他们存储在另一服务提供商上的资源，而无需暴露用户的凭据（例如用户名和密码）。OAuth 2.0 是 OAuth 协议的改进版，常用于Web应用、桌面应用、移动设备等场景下的授权流程。

它的工作原理如下：

1. **授权请求**：客户端应用请求用户授权来访问资源。这个请求通常通过浏览器或移动应用中的用户界面引导用户同意。
  
2. **授权批准**：用户同意授权后，OAuth 服务器会生成授权码并返回给客户端应用。

3. **获取访问令牌**：客户端使用获取的授权码向OAuth 服务器请求访问令牌。访问令牌用于代替用户凭证来访问受保护的资源。

4. **资源访问**：客户端应用将访问令牌附加到请求中，向资源服务器发送请求以访问用户的资源。资源服务器根据访问令牌的有效性决定是否允许访问。

OAuth 2.0 的典型场景包括：
- 第三方登录：通过Facebook、Google等第三方账号登录其他应用。
- API 授权：允许第三方应用通过API访问某些用户数据，如GitHub授权CI工具访问仓库。

OAuth 2.0 有多种授权模式，常见的有：
- **授权码模式**：最常见的模式，适用于Web应用。
- **隐式授权模式**：适用于不安全的客户端，如JavaScript应用。
- **密码凭证模式**：用户将自己的凭证直接提供给应用，适合高度信任的环境。
- **客户端凭证模式**：适用于应用之间的授权，用户不直接参与。

OAuth 2.0 的安全性强，并且灵活，可广泛适用于各种现代应用场景。



- 登录设计

  **步骤**

  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240925191125993.png" alt="image-20240925191125993" style="zoom:50%;" />

  1.准备工作

  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240925190949697.png" alt="image-20240925190949697" style="zoom:50%;" />

  2.配置所需参数到配置文件中

  3.写Controller

  在获取微信扫描的二维码时，需要重定向到微信，重定向的url使用这种写法，如果直接用字符串拼接很容易写错，%s是String的占位符

  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240925192900539.png" alt="image-20240925192900539" style="zoom:50%;" />

  ```java
  //之后使用下面的String.format方法来填写参数
  String qrcodeUrl = String.format(
              baseUrl,
              ConstantPropertiesUtil.WX_OPEN_APP_ID,
              redirectUrl,
              state);
  
  //返回固定地址，重定向
      return "redirect:" + qrcodeUrl;
  ```

  对url进行编码![image-20240925193330423](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240925193330423.png)

  扫码之后获取登录信息



<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240926204758064.png" alt="image-20240926204758064" style="zoom:50%;" />

第三步通过前两部获取到的token和id请求微信的一个url来获取扫码人信息，如微信昵称，头像之类的信息，返回到的是一个Json字符串，通过Gson这个第三方类来提取字符串中的数据（openid access_token）来请求微信网站，**请求是通过HttpUtils这个自定义的工具类**获取到之后同样再通过Gson转换json字符串，判断用户是否是第一次登录（调用Service方法）如果没有，**就把信息存储到数据库中**，通过Jwt工具类里面的通过用户信息生成token来生成用户的token，之后再重定向到用户的登录界面**（这样就可以实现跨域的同时，显示出用户信息）**

*生成token的原因是为了在扫码之后的页面展示用户信息，cookie没办法解决跨域问题*

```java
//发送请求
String userInfo = HttpClientUtils.get(userInfoUrl);
//获取返回userinfo字符串扫描人信息
HashMap userInfoMap = gson.fromJson(userInfo, HashMap.class);
String nickname = (String)userInfoMap.get("nickname");//昵称
String headimgurl = (String)userInfoMap.get("headimgurl");//头像

member = new UcenterMember();
member.setOpenid(openid);
member.setNickname(nickname);
member.setAvatar(headimgurl);
memberService.save(member);

 //使用jwt根据member对象生成token字符串
            String jwtToken = JwtUtils.getJwtToken(member.getId(), member.getNickname());
            //最后：返回首页面，通过路径传递token字符串
            return "redirect:http://localhost:3000?token="+jwtToken;
```



![image-20240926204942342](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240926204942342.png)

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240926211925052.png" alt="image-20240926211925052" style="zoom:50%;" />

##         JWT

JWT（JSON Web Token）是一种用于身份验证的无状态令牌，常用于分布式系统。它包含三部分内容：

1. **Header（头部）**：说明使用的算法和令牌类型，通常是JWT。
2. **Payload（负载）**：存放用户信息和声明，比如用户ID、过期时间等。
3. **Signature（签名）**：用来验证令牌没有被篡改，通常使用密钥和加密算法生成。

生成的JWT通常是一个由这三部分组成的字符串，用`.`分隔。它的主要优点是：**无状态**，服务器不需要保存用户登录信息，减少了服务器压力。

等你深入学习时，可以再探讨更多细节。

下面是一个示例的JWT字符串：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

这个JWT包含以下部分：
1. **Header**:
   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```
2. **Payload**:
   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "iat": 1516239022
   }
   ```
3. **Signature**: 使用`HS256`算法和密钥生成的签名部分。

这个JWT可以用来模拟基础的身份验证。

## Stream相关

- 下面这代码直接把项目中原有的for循环给替换成高级一点的写法并且添加上了非空判断

```java
//1.根据课程id查询所有视频的id
QueryWrapper<EduVideo> videoQueryWrapper = new QueryWrapper<>();
//挑选出列
videoQueryWrapper.select("video_source_id");
List<EduVideo> eduVideoList = baseMapper.selectList(videoQueryWrapper);
//将eduVideoList转换为String类型的List，因为VodClient是String的范形
List<String> videoIds = eduVideoList.stream()
        .map(EduVideo::getVideoSourceId)
        //添加非空的过滤
        .filter(videoId -> !StringUtils.isEmpty(videoId))
        .collect(Collectors.toList());
vodClient.deleteBatch(videoIds);
```

愿写法

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920000158627.png" alt="image-20240920000158627" style="zoom:33%;" />

## SringUtils

### join

`StringUtils.join()` 是 Apache Commons Lang 的一个方法，用于将数组或集合中的元素按指定分隔符连接成字符串。



1. **连接数组**：
   ```java
   StringUtils.join(new String[]{"apple", "banana", "cherry"}, ", ");
   // 输出: "apple, banana, cherry"
   ```

2. **连接集合**：
   ```java
   StringUtils.join(Arrays.asList("red", "green", "blue"), "-");
   // 输出: "red-green-blue"
   ```

3. **连接数组部分元素**：
   ```java
   StringUtils.join(new String[]{"a", "b", "c", "d"}, ",", 1, 3);
   // 输出: "b,c"
   ```

主要用于简化字符串拼接，避免手动操作。

```java
//videoIdList值转换成 1,2,3
String videoIds = StringUtils.join(videoIdList.toArray(), ",");
```

### isEmpty

使用StringUtils这个包的isEmpty来判断字符串是否为空，等价于

Empty指的是这个字符串是“”他有指向的对象，null是指没有指向对象，判断字符串为空需要同时满足这两个条件

```java
//videoSourceId != null && !videoSourceId.isEmpty()
```

- ```java
  if(!StringUtils.isEmpty(videoSourceId)){
      vodClient.removeAlyVideo(videoSourceId);
  }
  ```
  
- 注册功能

1.先获取到验证码手机号等信息

2.进行非空判断

3.从redis中获取验证码

```java
//判断验证码
        //获取redis验证码
        String redisCode = redisTemplate.opsForValue().get(mobile);
        if(!code.equals(redisCode)) {
            throw new GuliException(20001,"注册失败");
        }
```

4.与redis中的验证码进行比较

5.QueyyMapper查阅是否有手机号冲突

```java
  QueryWrapper<UcenterMember> wrapper = new QueryWrapper<>();
        wrapper.eq("mobile",mobile);
        Integer count = baseMapper.selectCount(wrapper);
        if(count > 0) {
            throw new GuliException(20001,"注册失败");
        }
```



6.存入数据库

## 配置相关

```java
//配置视频流一次最大1G
spring.servlet.multipart.max-file-size=1024MB

spring.servlet.multipart.max-request-size=1024MB
```

- SpringBoot启动类跳过筛选数据源

```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
```

- 阿里云视频点播+oss

  SDK是对API做了封装

  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240918132940653.png" alt="image-20240918132940653" style="zoom: 33%;" />

  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240918134327228.png" alt="image-20240918134327228" style="zoom: 67%;" />

- 实现阿里云视频删除视频的接口

```java
//根据视频id删除阿里云视频
@DeleteMapping("removeAlyVideo/{id}")
public R removeAlyVideo(@PathVariable String id){
    try {
        //初始化阿里云视频对象
        DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID,ConstantVodUtils.ACCESS_KEY_SECRET);
        //创建删除工具对象
        DeleteVideoRequest request = new DeleteVideoRequest();
        //向request设置删除的id
        request.setVideoIds(id);
        client.getAcsResponse(request);
    }catch (Exception e){
       throw new GuliException(20001,"删除小节视频失败") ;
    }
    return R.ok();
}
```

- sql注入细节

  ![image-20240916202719741](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240916202719741.png)

- 巧妙利用wrapper判断数据量,count

```java
int count = videoService.count(wrapper)
```



- 由于这个监听器没有交给Spring托管所以没办法直接注入Service，采用了从Controller到Service的通过方法参数层层传递参数

```java
/*手动将subJectService传入，用的是public修饰，这点很细，
这样在监听器里这个类就相当于注入了，因为其他类都可以用*/
public EduSubjectService subjectService;
public SubjectExcelListener(EduSubjectService subjectService) {
    this.subjectService = subjectService;
}
```

- 使用BeanUtils.copyPropertie这个方法来拷贝属性(封装属性)

```java
//封装一级列表
        List<OneSubject> finalSubjectList = new ArrayList<>();
        for (int i = 0; i < oneSubjectList.size(); i++) {
            EduSubject eduSubject = oneSubjectList.get(i);
            //开始拷贝值
            OneSubject oneSubject = new OneSubject();
            //用Spring封装的copyProperties来拷贝属性值
          	//前面的edu复制到后面的oneSubject
            BeanUtils.copyProperties(eduSubject,oneSubject);
            finalSubjectList.add(oneSubject);
        }
```

- 大小写转换用于验证码判断

  ![image-20240910203023054](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240910203023054.png)

  

  - 使用阿里云短信发送服务进行登录校验

  

  - **redis**:使用redis对短信验证码的内容进行存储，并且设置过期时间

  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240924102707287.png" alt="image-20240924102707287" style="zoom:50%;" />

  ![image-20240924102900504](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240924102900504.png)
  
  ## 删除含有子项目的业务
  
  - 场景：删除课程章节，章节里面有小节（一分类之下有二级分类）
  
  <img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240916171053861.png" alt="image-20240916171053861" style="zoom:33%;" />
  
  解决方案一：直接把所有小节都删除掉
  
  解决方案二：防止删除含有小节的章节，得先把小节删除掉（添加判断）
  
  ​	先查询是否有小节，判断，之后再删除
  
  
  
  - MD5加密
  
  ```java
   /*因为存储到数据库密码肯定加密的
  把输入的密码进行加密，再和数据库密码进行比较
  加密方式 MD5*/
  //判断密码
  if (!MD5.encrypt(password).equals(ucenterMember.getPassword()) && ucenterMember.getIsDisabled()){
      throw new GuliException(20001,"登录失败");
  }
  ```
  
  md5工具类
  
  ```java
  public final class MD5 {
  
      public static String encrypt(String strSrc) {
          try {
              char hexChars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                      '9', 'a', 'b', 'c', 'd', 'e', 'f' };
              byte[] bytes = strSrc.getBytes();
              MessageDigest md = MessageDigest.getInstance("MD5");
              md.update(bytes);
              bytes = md.digest();
              int j = bytes.length;
              char[] chars = new char[j * 2];
              int k = 0;
              for (int i = 0; i < bytes.length; i++) {
                  byte b = bytes[i];
                  chars[k++] = hexChars[b >>> 4 & 0xf];
                  chars[k++] = hexChars[b & 0xf];
              }
              return new String(chars);
          } catch (NoSuchAlgorithmException e) {
              e.printStackTrace();
              throw new RuntimeException("MD5加密出错！！+" + e);
          }
      }
  
      public static void main(String[] args) {
          System.out.println(MD5.encrypt("111111"));
      }
  
  }
  ```
  
  



## 单点登录

![image-20240922145341176](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240922145341176.png)

- 大部分公司中时使用集群部署

![image-20240922145511566](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240922145511566.png)

**单点登录（SSO）：在一个模块中登录了，就不需要在其他模块再次登录**

### 单点登录的几种实现方式

单点登录（Single Sign-On, SSO）的几种常见实现方式如下：

1. **Session 广播机制**  
   这种方式通常用于集群环境中，每个服务器节点都维护各自的用户Session，当某个节点的用户登录或退出时，会通过广播机制将Session同步给其他节点。  
   - **优点**：每个节点共享用户Session，不需要额外的存储机制。  
   - **缺点**：广播会带来网络开销，集群节点多时会增加复杂性，不适用于大规模集群。

2. **Cookie + Redis 实现**  
   在这种方式中，用户登录时，服务器生成一个Session ID，将其存储在Redis中（作为Key数据），并通过Cookie返回给用户浏览器。后续请求时，浏览器会带上该Cookie，服务器通过Redis验证Session ID来判断用户身份。  
   - **优点**：利用Redis的分布式存储，解决了Session共享问题，适合大规模分布式系统。  
   - **缺点**：依赖Redis，系统复杂性增加，存在一定的网络延迟。

3. **Token 实现**  
   Token方式通常采用JWT（JSON Web Token）或自定义Token来实现。用户登录后，服务器生成Token并返回给用户，用户在后续请求中将Token作为认证凭据发送，根据token是否存在来判断，如果存在已有token的用户信息就是登录，没有的话就是不是登录。 
   - **优点**：Token是无状态的**(可以直接通过Token解析器获得用户信息)**，服务器不需要存储Session，减少了服务器压力，适合分布式系统和跨域认证。  
   - **缺点**：Token过期处理和续期机制较为复杂，Token泄露风险需要额外的安全措施。

每种方式各有优劣，选择时需根据项目的具体需求、系统架构和安全性要求来决定。

- 使用token获取用户信息

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240925101724422.png" alt="image-20240925101724422" style="zoom:50%;" />

## 评论发布

效果实现

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240927162408008.png" alt="image-20240927162408008" style="zoom: 33%;" />

实现流程

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240927163424240.png" alt="image-20240927163424240" style="zoom:50%;" />

## 实现微信支付

- 后续获取二维码和查询订单的接口，**请求微信的数据都是使用xml，使用微信的工具类进行转换，得到的数据都是使用xmltomap方法转换为map数据再提取对应的信息**

总体流程分析

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240927164650493.png" alt="image-20240927164650493" style="zoom: 67%;" />

数据库表设计

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240929100855854.png" alt="image-20240929100855854" style="zoom:67%;" />



### 第一个接口

**在第一个接口中，生成订单需要课程信息和用户信息，使用nacos调用**

**由于调用信息的返回对象可能不同，还需要涉及到信息的提取**，这里设计了一个专门的信息Order的实体信息，**来简化信息提取的过程**这样更为方便，详情信息同理

```java
//根据用户id获取用户信息
@PostMapping("getUserInfo/{id}")
public UcenterMemberOrder getUserInfoOrder(@PathVariable String id){
    UcenterMember member = memberService.getById(id);
    //把member对象赋给统一的order对象
    UcenterMemberOrder ucenterMemberOrder = new UcenterMemberOrder();
    BeanUtils.copyProperties(member,ucenterMemberOrder);
    return ucenterMemberOrder;
}
```

![image-20240929103037675](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240929103037675.png)

![image-20240929101516563](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240929101516563.png)

```java
//1 生成订单的方法
//前端使用了cookie+拦截器的功能把token存图到请求头中，生成订单号的方法累去要使用Http请求对象
    @PostMapping("createOrder/{courseId}")
    public R saveOrder(@PathVariable String courseId, HttpServletRequest request) {
        //创建订单，返回订单号
        String orderNo =  orderService.createOrders(courseId,JwtUtils.getMemberIdByJwtToken(request));         
        return R.ok().data("orderId",orderNo);
    }

```

生成订单号的工具类

```java
public static String getOrderNo() {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
    String newDate = sdf.format(new Date());
    String result = "";
    Random random = new Random();
    for (int i = 0; i < 3; i++) {
        result += random.nextInt(10);
    }
    return newDate + result;
}
```

最后在order中注册客户端，添加上feign注解

```java
@Component
//注册为客户端，并且写上调用的服务的名字
@FeignClient("service-edu")
public interface EduClient {

    //根据课程id查询课程信息
    @PostMapping("/eduservice/coursefront/getCourseInfoOrder/{id}")
    public CourseWebVoOrder getCourseInfoOrder(@PathVariable("id") String id);

}
```

```java
@Component
@FeignClient("service-ucenter")
public interface UcenterClient {

    //根据用户id获取用户信息
    @PostMapping("/educenter/member/getUserInfoOrder/{id}")
    public UcenterMemberOrder getUserInfoOrder(@PathVariable("id") String id);
}
```

之后就是在Controller中调用方法，然后set订单信息

第二个接口直接查询就好了很简单





### 生成微信二维码

准备步骤

传递给微信生成二维码的信息必须是xml格式的数据，可以调用微信的方法来转换map为xml格式

*这个生成二维码同样是要请求微信的地址，使用http工具类来发送请求*`https://api.mch.weixin.qq.com/pay/unifiedorder`

返回的也是xml格式

```java
//把xml格式转换map集合，把map集合返回
Map<String,String> resultMap = WXPayUtil.xmlToMap(xml);
```

![image-20240929154449872](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240929154449872.png)

```java
//生成微信支付二维码接口
@Override
public Map createNatvie(String orderNo) {
    try {
        //1 根据订单号查询订单信息
        QueryWrapper<Order> wrapper = new QueryWrapper<>();
        wrapper.eq("order_no",orderNo);
        Order order = orderService.getOne(wrapper);

        //2 使用map设置生成二维码需要参数
        Map m = new HashMap();
        m.put("appid","wx74862e0dfcf69954");
        m.put("mch_id", "1558950191");
        m.put("nonce_str", WXPayUtil.generateNonceStr());
        m.put("body", order.getCourseTitle()); //课程标题
        m.put("out_trade_no", orderNo); //订单号
        m.put("total_fee", order.getTotalFee().multiply(new BigDecimal("100")).longValue()+"");
        m.put("spbill_create_ip", "127.0.0.1");
        m.put("notify_url", "http://guli.shop/api/order/weixinPay/weixinNotify\n");
        m.put("trade_type", "NATIVE");

        //3 发送httpclient请求，传递参数xml格式，微信支付提供的固定的地址
        HttpClient client = new HttpClient("https://api.mch.weixin.qq.com/pay/unifiedorder");
        //设置xml格式的参数
        client.setXmlParam(WXPayUtil.generateSignedXml(m,"T6m9iK73b0kn9g5v426MKfHQH7X8rKwb"));
        client.setHttps(true);
        //执行post请求发送
        client.post();

        //4 得到发送请求返回结果
        //返回内容，是使用xml格式返回
        String xml = client.getContent();

        //把xml格式转换map集合，把map集合返回
        Map<String,String> resultMap = WXPayUtil.xmlToMap(xml);

        //最终返回数据 的封装
        Map map = new HashMap();
        map.put("out_trade_no", orderNo);
        map.put("course_id", order.getCourseId());
        map.put("total_fee", order.getTotalFee());
        map.put("result_code", resultMap.get("result_code"));  //返回二维码操作状态码
        map.put("code_url", resultMap.get("code_url"));        //二维码地址

        return map;
    }catch(Exception e) {
        throw new GuliException(20001,"生成二维码失败");
    }

}
```

### 改变订单状态

微信请求的url

`https://api.mch.weixin.qq.com/pay/orderquery`

```java
//查询订单支付状态
@Override
public Map<String, String> queryPayStatus(String orderNo) {
    try {
        //1、封装参数
        Map m = new HashMap<>();
        m.put("appid", "wx74862e0dfcf69954");
        m.put("mch_id", "1558950191");
        m.put("out_trade_no", orderNo);
        m.put("nonce_str", WXPayUtil.generateNonceStr());

        //2 发送httpclient
        HttpClient client = new HttpClient("https://api.mch.weixin.qq.com/pay/orderquery");
        client.setXmlParam(WXPayUtil.generateSignedXml(m,"T6m9iK73b0kn9g5v426MKfHQH7X8rKwb"));
        client.setHttps(true);
        client.post();

        //3 得到请求返回内容
        String xml = client.getContent();
        Map<String, String> resultMap = WXPayUtil.xmlToMap(xml);
        //6、转成Map再返回
        return resultMap;
    }catch(Exception e) {
        return null;
    }
}
```

支付完成之后，跳转回详情页面的方法

![image-20240929161407626](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240929161407626.png)

## Cannal

**Canal** 是阿里巴巴开源的一个 **MySQL binlog** 增量订阅&消费的组件，主要用于实现 MySQL 数据库的主从同步，数据迁移，以及跨数据库的实时同步。Canal 模拟了 MySQL 的 **slave** 的交互协议，伪装自己为从库，然后从 MySQL 主库拉取 binlog 日志，解析这些日志内容并将数据推送给下游消费端，从而实现数据库的同步。

### Canal 实现数据库同步的原理

#### 1. **伪装为 MySQL 从库**
Canal 通过模拟 MySQL 从库的行为，向 MySQL 主库发送请求来获取 binlog。binlog 是 MySQL 的一种二进制日志，用于记录数据库中的所有增、删、改操作，主要作用是支持主从复制和数据恢复。

Canal 会像 MySQL 从库一样注册到 MySQL 主库，通过使用与 MySQL Slave 同样的交互协议来订阅主库的 binlog 日志。

#### 2. **读取 binlog 日志**
MySQL 主库会持续生成 binlog 日志，记录所有写操作（INSERT、UPDATE、DELETE等）。Canal 通过从 MySQL 主库拉取这些 binlog 日志，获取最新的数据库变更记录。

这些日志是以二进制格式存储的，包含了所有涉及数据变动的 SQL 语句。

#### 3. **解析 binlog**
Canal 收到 binlog 后，会对其进行解析，转换为可读的事件类型。binlog 日志记录的是每个 SQL 操作的原始数据变化，Canal 解析 binlog，将其中的数据库操作转换为相应的 SQL 事件或 JSON 事件，便于下游应用程序处理。

解析过程涉及以下几个步骤：
- **表结构解析**：Canal 会解析表结构信息，映射数据库表和字段，确保 binlog 日志中的数据能正确转换。
- **事件解析**：根据不同的操作类型（插入、更新、删除），Canal 会解析对应的事件。

#### 4. **消费 binlog 事件**
解析完成后，Canal 将生成的事件推送给下游的消费端。下游的应用程序可以通过订阅 Canal 提供的事件流来实现数据同步。

- **支持多种输出形式**：Canal 支持将解析后的数据推送到不同的目标，比如 MQ（如 Kafka、RocketMQ），或直接将数据写入其他数据库（如 Elasticsearch、HBase 等）。
- **多种同步模式**：下游消费端可以根据需求选择数据全量同步、增量同步，或混合模式。

#### 5. **下游消费与数据同步**
下游的消费应用可以根据 Canal 推送的 binlog 事件实现各种功能：
- **实时数据同步**：可以将 MySQL 的数据同步到其他数据存储系统，如 PostgreSQL、MongoDB、Elasticsearch 等，实现数据多源同步。
- **实时数据分析**：通过 Canal 获取的增量数据，推送到数据分析平台（如 Kafka、Flink 等），实现实时数据分析。
- **数据迁移**：在数据库迁移过程中，通过 Canal 可以实现实时增量数据的同步，确保数据的一致性。

#### 6. **异常处理与容错**
Canal 内部通过 checkpoint 机制保存 binlog 的拉取位置，遇到异常或故障时可以从之前的 checkpoint 位置继续读取日志，避免数据丢失。同时，Canal 支持集群部署，提升高可用性。

### 主要流程总结
1. **伪装从库**，连接 MySQL 主库，拉取 binlog。
2. **解析 binlog**，将二进制日志转换为 SQL 事件或 JSON 格式。
3. **推送数据**，将解析后的数据推送给下游的消费系统。
4. **消费数据**，下游系统接收事件流，实现数据库的实时同步或数据处理。

通过上述步骤，Canal 实现了对 MySQL 数据库的实时同步和监控，适用于多种数据集成场景。

### 使用场景
- **异构数据库同步**：如从 MySQL 同步数据到 MongoDB、Elasticsearch 等。
- **数据仓库构建**：将 MySQL 数据同步到数据仓库中，支持实时的数据分析。
- **数据备份与恢复**：通过 binlog 实现增量数据备份与恢复。
- **消息系统**：将数据库变化以消息的形式推送到消息队列，供其他系统实时消费。

Canal 基于 binlog 的数据捕获方式，可以在不影响 MySQL 主库性能的情况下，实现数据的实时同步与处理，适用于高性能、低延迟的数据同步场景。

![image-20240930173755022](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930173755022.png)

canal同步操作

![image-20240930174007901](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930174007901.png)

做好mysql的配置工作之后可以下载canal了，下载完之后修改一下对应的配置文件

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930175230673.png" alt="image-20240930175230673" style="zoom: 33%;" />

整合SpringBoot



![](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930175434558.png)

要在 Spring Boot 项目中整合 Canal（一个阿里巴巴的开源工具，用于 MySQL 的 binlog 订阅与消费），你可以按照以下步骤进行：

### 1. 引入依赖

首先，在 `pom.xml` 中添加 Canal 的依赖。你可以选择阿里巴巴官方提供的 Canal 客户端依赖。

```xml
<dependency>
    <groupId>com.alibaba.otter</groupId>
    <artifactId>canal.client</artifactId>
    <version>1.1.6</version> <!-- 选择适合的版本 -->
</dependency>
```

### 2. 配置 Canal 客户端

在 Spring Boot 项目中，通过配置 Canal 客户端的连接。你可以在 `application.properties` 或 `application.yml` 文件中配置 Canal Server 的信息。

#### `application.yml`
```yaml
canal:
  server:
    host: 127.0.0.1  # Canal 服务器地址
    port: 11111       # Canal 服务器端口
  destination: example # Canal 实例名称
  username: ""
  password: ""
```

### 3. 创建 Canal 客户端 Bean

在 Spring Boot 中定义 Canal 客户端的 Bean，并处理 Canal 传输的 binlog 数据。

```java
import com.alibaba.otter.canal.client.CanalConnector;
import com.alibaba.otter.canal.client.CanalConnectors;
import com.alibaba.otter.canal.protocol.CanalEntry;
import com.alibaba.otter.canal.protocol.Message;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.net.InetSocketAddress;
import java.util.List;

@Configuration
public class CanalConfig {

    @Value("${canal.server.host}")
    private String canalServerHost;

    @Value("${canal.server.port}")
    private int canalServerPort;

    @Value("${canal.destination}")
    private String destination;

    @Bean
    public CanalConnector canalConnector() {
        CanalConnector connector = CanalConnectors.newSingleConnector(
                new InetSocketAddress(canalServerHost, canalServerPort),
                destination,
                "",
                ""
        );
        connector.connect();
        connector.subscribe(".*\\..*"); // 订阅所有数据库表
        connector.rollback();
        return connector;
    }
}
```

### 4. 创建 Canal 消费服务

接下来，创建一个服务去监听 Canal 的 binlog 数据。

```java
import com.alibaba.otter.canal.client.CanalConnector;
import com.alibaba.otter.canal.protocol.CanalEntry;
import com.alibaba.otter.canal.protocol.Message;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.util.List;

@Service
public class CanalService {

    @Autowired
    private CanalConnector canalConnector;

    @PostConstruct
    public void start() {
        new Thread(() -> {
            while (true) {
                // 拉取数据
                Message message = canalConnector.getWithoutAck(100); // 获取指定数量的消息
                long batchId = message.getId();
                int size = message.getEntries().size();
                
                if (batchId != -1 && size > 0) {
                    handleEntries(message.getEntries());
                }

                canalConnector.ack(batchId); // 确认消费成功
            }
        }).start();
    }

    private void handleEntries(List<CanalEntry.Entry> entries) {
        for (CanalEntry.Entry entry : entries) {
            if (entry.getEntryType() == CanalEntry.EntryType.ROWDATA) {
                try {
                    CanalEntry.RowChange rowChange = CanalEntry.RowChange.parseFrom(entry.getStoreValue());
                    for (CanalEntry.RowData rowData : rowChange.getRowDatasList()) {
                        if (rowChange.getEventType() == CanalEntry.EventType.INSERT) {
                            handleInsert(rowData);
                        } else if (rowChange.getEventType() == CanalEntry.EventType.UPDATE) {
                            handleUpdate(rowData);
                        } else if (rowChange.getEventType() == CanalEntry.EventType.DELETE) {
                            handleDelete(rowData);
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private void handleInsert(CanalEntry.RowData rowData) {
        System.out.println("Insert: " + rowData.toString());
    }

    private void handleUpdate(CanalEntry.RowData rowData) {
        System.out.println("Update: " + rowData.toString());
    }

    private void handleDelete(CanalEntry.RowData rowData) {
        System.out.println("Delete: " + rowData.toString());
    }
}
```

### 5. 启动项目并调试

通过上面的步骤，项目启动后，Canal 客户端会自动连接到 Canal Server，并开始订阅和消费 MySQL 的 binlog 日志。

### 6. 注意事项

- 确保 MySQL 已开启 binlog，并且 Canal Server 能够正常连接到 MySQL。
- 在生产环境中，建议加上异常处理、日志记录，以及对 Canal 服务的容错机制。
  

这样，你就可以在 Spring Boot 项目中整合 Canal 来监听 MySQL 的 binlog 日志并处理数据变更了。

## Gateway（SpringCloud组件）

Spring Cloud Gateway 是一个功能强大的反应式 API 网关，**具有灵活的路由、过滤器、负载均衡、限流、熔断等功能**。在微服务架构中，它作为流量的入口，帮助我们对服务进行路由和流量管理，同时提供丰富的扩展性，可以通过自定义过滤器、集成安全等特性满足复杂的业务需求。

`Spring Cloud Gateway` 是 Spring Cloud 微服务架构中非常重要的网关组件，主要用于处理 API 网关的功能。它提供了路由请求、权限校验、流量控制等功能，在微服务架构中起到流量管理的作用。

下面，我会详细介绍 Spring Cloud Gateway 的各个知识点，帮助你全面理解它的功能和使用方式。

---

### 1. **Spring Cloud Gateway 基本概念**

Spring Cloud Gateway 是基于 Spring 5.0、Spring Boot 2.x 和 Project Reactor 实现的反应式 API 网关。它支持：
- 路由功能
- 过滤器功能
- 负载均衡
- 限流
- 熔断

#### 1.1. **路由 (Routing)**

路由是 Gateway 最核心的功能，负责将外部请求转发到具体的服务实例。路由包含两个主要部分：
- **ID**：每个路由都有唯一的标识符
- **URI**：请求的目标服务
- **匹配条件**：当请求满足某个路由的条件时，Gateway 就会将请求转发到相应的服务。

**示例：**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: example_route
          uri: http://example.com
          predicates:
            - Path=/example/**
```

在上面的配置中，所有访问 `/example/**` 路径的请求都会被路由到 `http://example.com`。

#### 1.2. **断言 (Predicates)**

断言用于判断请求是否符合路由的条件。Spring Cloud Gateway 支持多种断言，比如：

- **Path 路径断言**：根据请求路径进行路由。
- **Host 断言**：根据请求头中的 `Host` 进行路由。
- **Method 断言**：根据 HTTP 请求方法进行路由。
- **Query 断言**：根据请求参数进行路由。
- **Header 断言**：根据请求头的值进行路由。

**示例：**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: path_route
          uri: http://example.com
          predicates:
            - Path=/test/**
            - Method=GET
            - Query=name
```
这个路由只会匹配路径为 `/test/**` 且方法为 `GET` 的请求，同时要求请求中包含 `name` 参数。

#### 1.3. **过滤器 (Filters)**

过滤器允许在请求被路由到下游服务之前或返回响应时进行拦截和修改。过滤器可以在请求和响应的生命周期中执行不同的操作，如：
- 添加、修改请求头或响应头
- 请求限流
- 负载均衡
- 熔断处理

过滤器分为两种类型：
- **全局过滤器**：对所有路由生效。
- **局部过滤器**：只对某个路由生效。

**示例：**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: add_header_route
          uri: http://example.com
          filters:
            - AddRequestHeader=X-Request-Example, Hello
```
这个过滤器会在转发请求前，给请求头加上 `X-Request-Example: Hello`。

常见的过滤器有：
- **AddRequestHeader**：添加请求头。
- **AddResponseHeader**：添加响应头。
- **Retry**：配置重试机制。
- **Hystrix**：实现熔断。

#### 1.4. **负载均衡**

调节集群的负载均衡

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930182405187.png" alt="image-20240930182405187" style="zoom: 67%;" />

Spring Cloud Gateway 可以与 Spring Cloud LoadBalancer 一起使用，提供简单的负载均衡功能。通过将路由的 `uri` 设置为 `lb://service-id`，Gateway 会根据服务注册中心的负载均衡策略将请求分发到不同的服务实例上。

**示例：**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: load_balanced_route
          uri: lb://order-service
          predicates:
            - Path=/order/**
```
当请求匹配 `/order/**` 路径时，Spring Cloud Gateway 会通过负载均衡，将请求转发到 `order-service` 的不同实例上。

#### 1.5. **限流 (Rate Limiting)**

Gateway 也提供了限流的功能，通过 `RequestRateLimiter` 过滤器可以实现基于令牌桶的限流。该功能可以防止某个 API 被滥用。

要实现限流功能，需要结合 Redis 使用，下面是一个简单的限流示例：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: rate_limiter_route
          uri: http://example.com
          predicates:
            - Path=/rate-limit/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenishRate: 10  # 每秒补充10个令牌
                  burstCapacity: 20  # 允许的最大请求数
```
此示例中，`replenishRate` 表示每秒生成多少个令牌，而 `burstCapacity` 是令牌桶的最大容量。

#### 1.6. **熔断 (Circuit Breaker)**

Spring Cloud Gateway 可以通过与 `Resilience4j` 或 `Hystrix` 集成来实现熔断功能。熔断器可以在请求到下游服务失败时，提供一种快速失败机制。

**Hystrix 熔断示例：**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: circuit_breaker_route
          uri: http://example.com
          predicates:
            - Path=/circuit/**
          filters:
            - name: Hystrix
              args:
                name: fallbackCmd
```
在这个示例中，如果访问 `/circuit/**` 时目标服务不可用，熔断器会立即返回一个备用响应，而不是一直等待。

---

### 2. **Gateway 配置方式**

Spring Cloud Gateway 的配置可以通过两种方式：
- **基于 Java 代码配置**：通过 Java 代码创建路由。
- **基于配置文件（YAML 或 properties）配置**：通过配置文件定义路由。

#### 2.1. **基于 Java 代码的配置**

通过 `RouteLocatorBuilder` 可以在 Java 代码中配置 Gateway 的路由：

```java
@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes()
            .route("path_route", r -> r.path("/get")
                .uri("http://httpbin.org"))
            .route("host_route", r -> r.host("*.myhost.org")
                .uri("http://httpbin.org"))
            .build();
}
```

#### 2.2. **基于配置文件的配置**

前面的示例大部分是基于 `application.yml` 的配置，这种方式相对简单，适合不需要复杂逻辑的场景。

```java
#配置service-edu服务 spring.cloud.gateway.routes[1].id=service-edu spring.cloud.gateway.routes[1].uri=lb://service-edu spring.cloud.gateway.routes[1].predicates= Path=/eduservice/**
#配置service-ucenter服务 spring.cloud.gateway.routes[2].id=service-ucenter spring.cloud.gateway.routes[2].uri=lb://service-ucenter spring.cloud.gateway.routes[2].predicates= Path=/ucenterservice/**
```



---

### 3. **Spring Cloud Gateway 的高级特性**

#### 3.1. **自定义过滤器**

如果内置的过滤器无法满足需求，你可以自定义过滤器。自定义过滤器通常用于处理复杂的请求修改或监控需求。

**示例：**
```java
@Component
public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println("Custom Global Filter");
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return -1;  // 定义过滤器的执行顺序
    }
}
```

#### 3.2. **与 Spring Security 集成**

Gateway 可以与 Spring Security 无缝集成，实现身份验证、授权和其他安全控制。

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: secure_route
          uri: http://secure-service
          predicates:
            - Path=/secure/**
          filters:
            - RemoveRequestHeader=Cookie
```

通过 Spring Security，可以配置过滤器来进行认证或授权。

---

### 4. **监控与调试**

Spring Cloud Gateway 支持通过 Actuator 集成监控 API 流量、路由情况等信息。常用的端点包括：
- `/actuator/gateway/routes`：查看所有配置的路由。
- `/actuator/gateway/globalfilters`：查看所有的全局过滤器。
- `/actuator/gateway/routefilters`：查看所有的路由过滤器。



### 与Nginx的差别

Spring Cloud Gateway 和 Nginx 都可以用作网关，但它们的功能定位和使用场景有显著的区别。以下是两者之间的主要区别：

#### 1. **定位与架构层级**

- **Spring Cloud Gateway**：
  - Spring Cloud Gateway 是一个专为微服务架构设计的 **API 网关**，**主要用于在微服务架构中处理 API 请求**。
  - 它基于 **Spring Boot** 和 **Reactor**（响应式编程框架），完全是 Java 生态中的一部分，常用于在 Spring Cloud 微服务架构中充当流量入口。
  - Spring Cloud Gateway 具有良好的微服务集成能力，能够与其他 Spring Cloud 组件（如 Spring Cloud Config、Eureka、Hystrix、Sleuth 等）无缝结合。
  
- **Nginx**：
  - Nginx 是一个高性能的 **HTTP 服务器、反向代理服务器** 和 **负载均衡器**，最初是为处理高并发的 HTTP 请求而设计的。
  - Nginx 常用于 Web 应用的前端，负责处理静态资源、SSL 终止、反向代理和负载均衡等任务，并不是专门为微服务而设计。
  - 它基于 C 语言编写，性能极高，特别擅长处理高并发和大量静态文件。

#### 2. **功能侧重点**

- **Spring Cloud Gateway**：
  - **API 路由和微服务集成**：Gateway 是为 API 网关设计的，提供了灵活的路由规则，可以通过简单的配置将请求转发到微服务。它与微服务架构高度整合，比如可以和服务注册中心（如 Eureka、Consul）结合，实现动态的路由发现和自动负载均衡。
  - **响应式编程**：基于 Spring WebFlux 和 Reactor 实现，支持高并发的非阻塞处理，可以很好地处理异步请求和响应。
  - **丰富的内置过滤器和断言机制**：Spring Cloud Gateway 提供了丰富的内置过滤器（限流、熔断、重试、修改请求头等）和断言功能（路径匹配、参数匹配、请求方法等），能在 API 请求前后进行复杂的拦截和处理。
  - **安全性**：可以与 Spring Security 集成，轻松实现基于 OAuth2 或 JWT 的身份验证和授权控制。
  - **动态路由和扩展性**：通过代码和配置文件的方式轻松添加自定义过滤器和路由规则，支持在运行时动态配置路由。
  - **微服务追踪与监控**：可以与 Spring Cloud Sleuth、Zipkin 等集成，实现请求链路追踪，适合大规模微服务集群的监控。

- **Nginx**：
  - **高性能反向代理与负载均衡**：Nginx 最为擅长的是反向代理和负载均衡。它支持多种负载均衡策略（如轮询、最少连接等），性能卓越，特别适合处理高并发 HTTP 请求的负载均衡。
  - **静态内容服务**：Nginx 能高效地提供静态资源服务（如 HTML、CSS、JavaScript 和图片），是许多 Web 服务器的首选。
  - **SSL/HTTPS 处理**：Nginx 常用于处理 SSL 终止，也就是解密 SSL 流量并将解密后的请求转发到后端服务，减轻后端的负载。
  - **缓存功能**：Nginx 具备强大的缓存能力，可以将静态文件或 API 请求的响应缓存到内存中，从而大大提高性能。
  - **简单的配置**：Nginx 使用配置文件（nginx.conf）定义服务器行为，配置相对简单并且性能优化优秀，但它的动态能力和复杂场景下的处理能力不如 Spring Cloud Gateway。

#### 3. **编程语言与生态**

- **Spring Cloud Gateway**：
  - **基于 Java**：使用 Spring Boot 和 Java 生态系统，是 Java 开发者在微服务架构中集成网关的最佳选择，尤其是在已有 Spring 微服务体系下，Spring Cloud Gateway 与其他组件无缝集成。
  - **生态**：与 Spring Cloud 组件（如 Eureka、Config、Sleuth 等）集成得非常紧密。适合 Spring 微服务体系下的开发。

- **Nginx**：
  - **基于 C 语言**：Nginx 是用 C 语言编写的，性能极高，适合高并发的场景。
  - **生态广泛**：Nginx 的应用范围非常广，支持多种应用场景（如 Web 服务器、反向代理、负载均衡、缓存）。它与任何后端技术栈（Java、Node.js、Python、PHP 等）都能很好地配合工作。



![image-20240930181154054](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930181154054.png)

# SpringSecurity（权限管理）

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241003184730617.png" alt="image-20241003184730617" style="zoom:50%;" />

五张表来存储权限关系

![image-20241003185600591](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241003185600591.png)

🎯 **Spring Security** 是一个基于 **Spring Framework** 的强大、灵活的安全框架，主要用于保护 Java 应用程序，尤其是 web 应用程序。它为认证（authentication）和授权（authorization）提供了全面的解决方案，并集成了常见的安全功能，比如防止 CSRF 攻击、会话固定攻击、点击劫持等。

以下是对 Spring Security 的详细介绍：

---

### 🔑 **核心功能：**

1. **认证（Authentication）：**
   
   - Spring Security **通过验证用户（密码）的身份来确保用户是谁**。
   - 可以通过多种方式进行身份认证，如：
     - **表单登录**（Form-based login）
     - **HTTP Basic** 或 **Digest** 认证
     - **OAuth2** 和 **OpenID Connect**
     - **LDAP**, **JWT**（JSON Web Token）等。
   
2. **授权（Authorization）：**
   
   - 确保已认证的用户**可以访问他们被允许的资源或执行被允许的操作**。
   - 提供基于角色的访问控制（Role-based Access Control, RBAC）以及更加细粒度的权限控制。
   
3. **基于过滤器的架构（Filter-based architecture）：**
   - Spring Security 是通过一系列的 Servlet 过滤器链来实现的。每个请求都会依次通过这些过滤器，以确保请求是安全的。
   - 例如，`UsernamePasswordAuthenticationFilter` 处理表单登录，`BasicAuthenticationFilter` 处理基本 HTTP 认证，`SecurityContextPersistenceFilter` 负责从会话中恢复安全上下文等。

   ![image-20241004121110494](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004121110494.png)
   
4. **保护 HTTP 请求：**
   - 支持细粒度的 URL 路径保护规则，可以使用 **antMatchers** 或 **regexMatchers** 来控制哪些 URL 是开放的，哪些是受保护的。

5. **CSRF（Cross-Site Request Forgery, 跨站请求伪造）防护：**
   - 默认启用了 CSRF 防护，防止恶意网站通过伪造请求来执行未经授权的操作。

6. **会话管理：**
   - 支持会话固定攻击防护，确保会话在用户登录前后安全地处理。
   - 还可以配置最大会话数量，防止同一用户的多次登录。

7. **OAuth 2.0 和 OpenID Connect：**
   - Spring Security 集成了对 OAuth 2.0 和 OpenID Connect 的支持，方便开发人员实现安全的单点登录（SSO）和第三方认证。

8. **密码编码和加密：**
   - 提供了多种密码编码机制（如 BCrypt, SCrypt, Pbkdf2），确保用户密码存储和处理的安全性。

9. **防止会话劫持、点击劫持：**
   - 提供了一系列的保护机制，确保应用程序的用户会话和操作不被恶意劫持。

---

### ⚙️ **工作流程：**

1. **请求处理：**
   - 当用户发送请求时，Spring Security 的过滤器链首先捕获这个请求。
   
2. **身份认证：**
   - Spring Security 检查用户是否已通过身份验证（通过会话、token等）。如果没有，则引导用户进行身份认证（如表单登录、OAuth登录等）。

3. **权限检查：**
   - 一旦用户通过身份验证，系统会检查用户是否具备访问特定资源的权限。

4. **访问资源：**
   - 如果用户被允许访问资源，Spring Security 将放行请求，否则返回相应的错误状态码（如 403 Forbidden）。
   
   ![image-20241004121357474](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004121357474.png)

---

### 🔨 **如何使用 Spring Security：**

在 Spring Boot 项目中，集成 Spring Security 非常简单。只需要添加对应的依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**基础配置示例：**

![image-20241004122039410](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004122039410.png)

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()  // 公共路径不需要认证
                .anyRequest().authenticated()          // 其他路径需要认证
                .and()
            .formLogin()                               // 启用表单登录
                .loginPage("/login")                   // 自定义登录页面
                .permitAll()
                .and()
            .logout()                                  // 启用登出功能
                .permitAll();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication()
            .withUser("user").password("{noop}password").roles("USER")   // 简单的内存用户
            .and()
            .withUser("admin").password("{noop}admin").roles("ADMIN");
    }
}
```

**解释：**
- `authorizeRequests()`：定义 URL 的访问权限。
- `formLogin()`：启用表单登录。
- `logout()`：启用登出功能。
- `inMemoryAuthentication()`：创建内存中的用户以便测试。
- ![image-20241004121650220](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004121650220.png)

---

### 🚀 **总结：**
Spring Security 提供了全面的认证和授权解决方案，具有极高的灵活性和安全性。无论是保护 web 应用，还是构建 OAuth2 服务，Spring Security 都能够胜任。结合 Spring Boot 的简洁配置，开发者可以快速构建一个安全的应用程序。

![image-20241004120856547](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004120856547.png)



### 项目中的使用

先规定好不同角色对应的权限

```java
//=========================给角色分配菜单=======================
@Override
public void saveRolePermissionRealtionShipGuli(String roleId, String[] permissionIds) {
    //roleId角色id
    //permissionId菜单id 数组形式
    //1 创建list集合，用于封装添加数据
    List<RolePermission> rolePermissionList = new ArrayList<>();
    //遍历所有菜单数组
    for(String perId : permissionIds) {
        //RolePermission对象
        RolePermission rolePermission = new RolePermission();
        rolePermission.setRoleId(roleId);
        rolePermission.setPermissionId(perId);
        //封装到list集合
        rolePermissionList.add(rolePermission);
    }
    //添加到角色菜单关系表
    rolePermissionService.saveBatch(rolePermissionList);
}
```





## 定时任务

- 使用场景：在固定的时候自动执行程序：闹钟

实现步骤：

1. 在启动类上添加注解

![image-20240930155439878](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240930155439878.png)

2.添加定时任务类

需要在这个类里面添加什么时候执行，cron

**七子表达式**生成器

http://cron.qqe2.com/

```java
@Component
public class ScheduledTask {
    @Autowired
    private StatisticsDailyService dailyService;

    /**
     * 测试* 每天七点到二十三点每五秒执行一次
     */
    @Scheduled(cron = "0/5 * * * * ?")
    public void task1() {
        System.out.println("*********++++++++++++*****执行了");
    }

    /**
     * 每天凌晨1点执行定时
     */
    @Scheduled(cron = "0 0 1 * * ?")
    public void task2() {
        //获取上一天的日期
        String day = DateUtil.formatDate(DateUtil.addDays(new Date(), -1));
        dailyService.createStatisticsByDay(day);
    }
}
```



# 配置中心

对多个模块的配置信息进行统一管理

- 场景

![image-20241004190436255](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004190436255.png)

![image-20241004190409908](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004190409908.png)

![image-20241004190803697](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241004190803697.png)



## 阿里视频播放器

1. 首先需要创建接口获取视频播放的凭证

   ```java
   //根据视频id获取视频凭证
       @GetMapping("getPlayAuth/{id}")
       public R getPlayAuth(@PathVariable String id) {
           try {
               //创建初始化对象
               DefaultAcsClient client = InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET);
               //创建获取凭证request和response对象
               GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();
               //向request设置视频id
               request.setVideoId(id);
               //调用方法得到凭证
               GetVideoPlayAuthResponse response = client.getAcsResponse(request);
               String playAuth = response.getPlayAuth();
               return R.ok().data("playAuth",playAuth);
           }catch(Exception e) {
               throw new GuliException(20001,"获取凭证失败");
           }
       }
   ```

   

   ## 

   ## 



# 状态码

- 403原因

路径写错

跨域

# Bug问题

**使用添加配置文件的解决方案不知道为什么一直启动不了SpringBoot**，最后解决的时候还是采用直接把xml放到resources的mapper下面然后就可以被扫描了

mapper没有被识别，maven在加载项目的时候只会加载java文件，xml不会被加载，下面是解决方案

![image-20240916204008288](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240916204008288.png)

**解决方案**

在pom.xml加上

<img src="/Users/xiechen/Library/Application Support/typora-user-images/image-20240916205438127.png" alt="image-20240916205438127" style="zoom:50%;" />

## 前端json问题

在写删除小节所有视频这个接口的时候，测试时出现了小节视频id空指针异常

- 先是采用递归调用上层接口是否传入空参，检查没有问题之后就通过数据库sql语句直接查询，发现不是后段语句的原因
- 就以为是阿里云上传单个视频的时候没有返回视频id，检查之后发现接口没有问题，这个时候实在是很脑大
- 开始在方法调用端口设置打印一些错误信息，成功发现传入的小节对象中没有视频id，打印出来为null，这个时候我就开始检查前端封装json数据是否有问题，最终排查bug，成功解决

**总结**

一定要仔细检查前端封装好的数据，并且在后端加入参数判断！！

# 微服务

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240918221806009.png" alt="image-20240918221806009" style="zoom: 33%;" />

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240918222030112.png" alt="image-20240918222030112" style="zoom: 33%;" />

<img src="/Users/xiechen/Library/Application Support/typora-user-images/image-20240919144113614.png" alt="image-20240919144113614" style="zoom: 33%;" />

- 微服务基础组件

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919144237540.png" alt="image-20240919144237540" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919144725924.png" alt="image-20240919144725924" style="zoom:50%;" />

Nacos与Cloud

需要把跨模块调用者和使用者都注册到Nacos中

![image-20240919150544582](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919150544582.png)

常见的注册中心

![image-20240919150645791](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919150645791.png)

![image-20240919150738909](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919150738909.png)

## nacos使用

![image-20240919222429523](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919222429523.png)

在启动类上注册，下面这注解是在nacos中注册服务端和调用端的作用

```java
@EnableDiscoveryClient//nacos注册
```

- 访问网址

localhost://8848/nacos

## Feign

- 简介

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919222945983.png" alt="image-20240919222945983" style="zoom: 33%;" />

使用步骤

先引入依赖

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919223430100.png" alt="image-20240919223430100" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919223625852.png" alt="image-20240919223625852" style="zoom:50%;" />

注意的是PathVariable需要指定参数

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240919223722073.png" alt="image-20240919223722073" style="zoom:50%;" />

```java
@Component
@FeignClient("service-vod")
public interface VodClient {
    //根据视频id删除阿里云视频
    @DeleteMapping("removeAlyVideo/{id}")
    public R removeAlyVideo(@PathVariable("id") String id);
}
```

**之后就在调用的地方注入实现的接口，然后调用接口里面的方法**

## 熔断器**Hystrix**

- 延迟处理就是处理的时间，超过了这个时间就是出现了问题，保证分布式系统的稳定

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920115538232.png" alt="image-20240920115538232" style="zoom:50%;" />

1)接口化请求调用当调用被@FeignClient注解修饰的接口时，在框架内部，将请求转换成Feign的请求 实例feign.Request，交由Feign框架处理。

(2)**Feign** :转化请求Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请 求，封装了Http调用流程。

(3)**Hystrix**:熔断处理机制 Feign的调用关系，会被Hystrix代理拦截，对每一个Feign调用请 求，Hystrix都会将其包装成HystrixCommand,参与Hystrix的流控和熔断规则。如果请求判断需要熔断， 则Hystrix直接熔断，抛出异常或者使用FallbackFactory返回熔断Fallback结果;如果通过，则将调用请求传递 给Ribbon组件。

(4)**Ribbon**:服务地址选择 当请求传递到Ribbon之后,Ribbon会根据自身维护的服务列表，根据服务的服 务质量，如平均响应时间，Load等，结合特定的规则，从列表中挑选合适的服务实例，选择好机器之 后，然后将机器实例的信息请求传递给Http Client客户端，HttpClient客户端来执行真正的Http接口调用;

(5)**HttpClient** :Http客户端，真正执行Http调用根据上层Ribbon传递过来的请求，已经指定了服务地 址，则HttpClient开始执行真正的Http请求

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920105029872.png" alt="image-20240920105029872" style="zoom: 67%;" />

**Feign是根据服务名称之后对调用的方法进行调用**

熔断器Hystrix的作用就是在进行远程调用的时候如果远程设备出现bug，熔断器会启动保护功能，停止与远程调用的连接

### Ribbon

- 负载均衡

在调用多个组件的时候，可以负责把组件添加到多个服务端，保持负载均衡



一切都准备好了之后在通过httpclient进行各个服务的调用

![image-20240920110126125](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920110126125.png)

### 如何整合熔断器

- 1.导入依赖

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

<!--hystrix依赖，主要是用 @HystrixCommand --> <dependency>

```
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```

<!--服务注册--> <dependency>

```
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

<!--服务调用--> <dependency>

```xml
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

- 2.配置hystrix的配置文件

  ```java
  #开启熔断机制
  feign.hystrix.enabled=true
  # 设置hystrix超时时间，默认1000ms hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000
  ```

- 3.![image-20240920120131986](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920120131986.png)

- 4.![image-20240920120147582](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920120147582.png)

# 前端知识

- 服务端渲染技术

![image-20240920123734586](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920123734586.png)

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20240920160938789.png" alt="image-20240920160938789" style="zoom: 67%;" />

# 工具类

## Http请求工具类

```java
package com.atguigu.eduorder.utils;

import org.apache.http.Consts;
import org.apache.http.HttpEntity;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.*;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.text.ParseException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * http请求客户端
 * 
 * @author qy
 * 
 */
public class HttpClient {
    private String url;
    private Map<String, String> param;
    private int statusCode;
    private String content;
    private String xmlParam;
    private boolean isHttps;

    public boolean isHttps() {
       return isHttps;
    }

    public void setHttps(boolean isHttps) {
       this.isHttps = isHttps;
    }

    public String getXmlParam() {
       return xmlParam;
    }

    public void setXmlParam(String xmlParam) {
       this.xmlParam = xmlParam;
    }

    public HttpClient(String url, Map<String, String> param) {
       this.url = url;
       this.param = param;
    }

    public HttpClient(String url) {
       this.url = url;
    }

    public void setParameter(Map<String, String> map) {
       param = map;
    }

    public void addParameter(String key, String value) {
       if (param == null)
          param = new HashMap<String, String>();
       param.put(key, value);
    }

    public void post() throws ClientProtocolException, IOException {
       HttpPost http = new HttpPost(url);
       setEntity(http);
       execute(http);
    }

    public void put() throws ClientProtocolException, IOException {
       HttpPut http = new HttpPut(url);
       setEntity(http);
       execute(http);
    }

    public void get() throws ClientProtocolException, IOException {
       if (param != null) {
          StringBuilder url = new StringBuilder(this.url);
          boolean isFirst = true;
          for (String key : param.keySet()) {
             if (isFirst)
                url.append("?");
             else
                url.append("&");
             url.append(key).append("=").append(param.get(key));
          }
          this.url = url.toString();
       }
       HttpGet http = new HttpGet(url);
       execute(http);
    }

    /**
     * set http post,put param
     */
    private void setEntity(HttpEntityEnclosingRequestBase http) {
       if (param != null) {
          List<NameValuePair> nvps = new LinkedList<NameValuePair>();
          for (String key : param.keySet())
             nvps.add(new BasicNameValuePair(key, param.get(key))); // 参数
          http.setEntity(new UrlEncodedFormEntity(nvps, Consts.UTF_8)); // 设置参数
       }
       if (xmlParam != null) {
          http.setEntity(new StringEntity(xmlParam, Consts.UTF_8));
       }
    }

    private void execute(HttpUriRequest http) throws ClientProtocolException,
          IOException {
       CloseableHttpClient httpClient = null;
       try {
          if (isHttps) {
             SSLContext sslContext = new SSLContextBuilder()
                   .loadTrustMaterial(null, new TrustStrategy() {
                      // 信任所有
                      public boolean isTrusted(X509Certificate[] chain,
                            String authType)
                            throws CertificateException {
                         return true;
                      }
                   }).build();
             SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
                   sslContext);
             httpClient = HttpClients.custom().setSSLSocketFactory(sslsf)
                   .build();
          } else {
             httpClient = HttpClients.createDefault();
          }
          CloseableHttpResponse response = httpClient.execute(http);
          try {
             if (response != null) {
                if (response.getStatusLine() != null)
                   statusCode = response.getStatusLine().getStatusCode();
                HttpEntity entity = response.getEntity();
                // 响应内容
                content = EntityUtils.toString(entity, Consts.UTF_8);
             }
          } finally {
             response.close();
          }
       } catch (Exception e) {
          e.printStackTrace();
       } finally {
          httpClient.close();
       }
    }

    public int getStatusCode() {
       return statusCode;
    }

    public String getContent() throws ParseException, IOException {
       return content;
    }

}
```

# 项目总结

![image-20241005103151291](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005103151291.png)

![image-20241005103321947](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005103321947.png)

# 补充

## MQ

![image-20241005131324488](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005131324488.png)

特点：异步消息，应用解耦，流量削峰

![image-20241005131025992](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005131025992.png)

## 消息队列的发送形式

![image-20241005131515257](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005131515257.png)

MQ（消息队列，Message Queue）是一种用于消息传递的机制，它允许应用程序以异步方式相互通信。MQ消息发送方式通常包括以下几种：

### 1. **点对点（P2P）模式**
在点对点模式中，消息生产者发送消息到队列（Queue），然后消息消费者从队列中读取并处理消息。每条消息只能被一个消费者消费，消息一旦被读取就会从队列中删除。

- **特点**：
  - 每条消息只能被一个消费者接收。
  - 消息会保存在队列中，直到有消费者处理它。

- **应用场景**：
  - 订单处理系统中的任务调度。
  - 工作队列的实现。

### 2. **发布/订阅（Pub/Sub）模式**
在发布/订阅模式中，消息生产者将消息发布到主题（Topic），所有订阅了该主题的消费者都会收到消息。与点对点模式不同的是，消息可以被多个消费者接收。

- **特点**：
  - 消息可以被多个消费者同时接收。
  - 发布者和订阅者之间是松耦合的。

- **应用场景**：
  - 新闻推送、通知系统等广播类场景。
  - 事件驱动架构中的事件传播。

### 3. **事务消息**
事务消息用于确保消息传递的可靠性，尤其是在生产者和消费者之间进行分布式事务时，保证消息的发送和处理是原子性的。如果事务失败，消息将不会被消费。

- **特点**：
  - 支持分布式事务。
  - 保证消息传递的一致性。

- **应用场景**：
  - 金融系统中的交易处理。
  - 复杂业务场景下的分布式系统。

### 4. **延时消息**
延时消息允许生产者发送消息并设置消息的延时时间，消费者在消息延时到期后才能接收到该消息。

- **特点**：
  - 消息发送后不会立即被消费，经过指定的延迟时间后才能被处理。

- **应用场景**：
  - 延迟任务调度。
  - 消息的定时处理。

### 5. **顺序消息**
顺序消息确保消息按照它们的发送顺序被消费，通常用于要求严格顺序处理的场景。

- **特点**：
  - 消息按照发送顺序依次被消费者处理。
  - 可以使用有序队列来实现。

- **应用场景**：
  - 订单状态更新。
  - 日志的顺序写入。

### 常用的MQ工具
- **RabbitMQ**：支持多种协议的高性能消息代理，适用于点对点和发布/订阅模式。
- **Kafka**：分布式流处理平台，擅长处理大数据量的消息和流数据。
- **ActiveMQ**：支持多种消息协议，应用广泛的开源消息队列。

MQ的消息发送方式因使用场景不同而灵活多样。根据业务需求，可以选择适合的方式来提高系统的性能与可靠性。

### 核心概念

交换机：接收生产者消息，并且路由给服务器队列

![image-20241005154208745](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005154208745.png)

![image-20241005154949873](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005154949873.png)

#### 概念图

- 建立长连接可以保证高可用，生产者可以得治那个队列出现问题了

![image-20241005155203959](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005155203959.png)

### 运行机制

消息与队列之间存在绑定关系

![image-20241005160323674](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005160323674.png)

#### 交换机的类型

![image-20241005160627756](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005160627756.png)

![image-20241005160613627](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005160613627.png)

**3. Topic Exchange**

​	•	**特点**：模式匹配路由键，支持通配符。

​	•	**工作方式**：Topic Exchange 使用 **通配符** 来匹配路由键，可以通过“*”匹配一个单词，通过“#”匹配零个或多个单词。

​	•	**适用场景**：适用于复杂的路由规则，特别是当你需要基于多个维度（如日志的级别和来源）来路由消息时。例如，按日志来源和级别进行路由，*.error 可以匹配所有错误级别的日志，app1.* 可以匹配来自 app1 的所有日志。

**示例**：

​	•	Routing Key 为 app1.error 的消息会被 *.error 或 app1.* 绑定的队列接收。



```java
# 绑定队列
rabbitmqadmin declare queue name=error_queue
rabbitmqadmin declare queue name=app1_queue
rabbitmqadmin declare binding source=my_topic_exchange destination=error_queue routing_key=*.error
rabbitmqadmin declare binding source=my_topic_exchange destination=app1_queue routing_key=app1.*
```

![image-20241005160635102](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005160635102.png)

fanout是广播，topic是有路由规则

## rabbitMQ整合SpringBoot

![image-20241005162353147](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005162353147.png)

在 Spring Boot 中整合 RabbitMQ 主要通过 Spring AMQP 实现。Spring AMQP 提供了与 RabbitMQ 的无缝集成，支持消息队列的发送、接收以及监听等功能。下面详细介绍如何整合 RabbitMQ 与 Spring Boot：

#### 1. 引入依赖

首先，你需要在 Spring Boot 项目中添加 RabbitMQ 的相关依赖。可以通过修改 `pom.xml` 文件来添加依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

#### 2. 配置 RabbitMQ

Spring Boot 提供了自动化配置，你可以在 `application.properties` 或 `application.yml` 文件中配置 RabbitMQ 的连接信息：

**application.properties:**
```properties
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
```

**application.yml:**
```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
```

#### 3. 定义消息队列、交换器和绑定关系

- ***可以使用AmqpAdmin来创建或者自定义Bean***

![image-20241005163618371](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005163618371.png)

![image-20241005163923981](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005163923981.png)

从你上传的截图来看，你使用了 `AmqpAdmin` 来声明交换机，具体代码是：

```java
DirectExchange directExchange = new DirectExchange(name: "");
amqpAdmin.declareExchange(directExchange);
```

而我提供的方法中是通过 `@Bean` 创建交换机：

```java
@Bean
public TopicExchange exchange() {
    return new TopicExchange("myExchange");
}
```

##### 区别

1. **方式一：`AmqpAdmin.declareExchange()`**
   - **手动声明交换机**：通过 `AmqpAdmin` 手动声明交换机。这种方式你可以在代码的任何地方灵活使用 `AmqpAdmin` 来创建交换机、队列、绑定等操作。适合在运行时动态地声明或修改交换机。
   - **管理和维护**：`AmqpAdmin` 提供了更大的灵活性，可以在程序的任何地方通过方法调用来管理交换机。通常适用于需要在应用运行过程中动态配置交换机或队列的场景。
   - **使用场景**：如果你想要在代码运行过程中灵活地动态创建或管理 RabbitMQ 的组件（交换机、队列等），这种方法可能更适合。

2. **方式二：通过 `@Bean` 定义**
   - **自动配置和声明**：通过 `@Bean` 声明的交换机会在 Spring 容器启动时自动创建。Spring Boot 会自动将这些定义好的交换机、队列等声明到 RabbitMQ 中。这种方式更适合于静态声明，也就是说，系统一启动就会根据配置创建好交换机。
   - **简洁性**：通过配置文件和注解，你不需要手动调用方法来声明交换机。Spring Boot 会在启动时自动帮你处理这些声明，代码更加简洁，适合配置相对稳定的应用。
   - **使用场景**：如果 RabbitMQ 相关的配置在应用中相对固定，比如交换机、队列等是在应用启动时就定义好的，那么通过 `@Bean` 声明的方式更加简便。

##### 总结

- 如果你希望在应用启动时自动创建交换机而不需要手动干预，推荐使用 `@Bean` 定义方式，适合静态配置的场景。
- 如果你需要在运行时动态创建、修改交换机或队列，使用 `AmqpAdmin` 提供的 `declareExchange()` 方法更合适，适合动态配置的场景。

你可以根据应用的具体需求选择合适的方式。如果配置在系统运行过程中不会频繁变化，使用 `@Bean` 定义更加简便和自动化。

可以通过 `@Bean` 注解定义队列、交换器和绑定关系。在 Spring Boot 中，你可以在配置类中编写这些 Bean。

**例如，创建一个简单的队列、交换器，并进行绑定：**

```java
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    public static final String QUEUE_NAME = "myQueue";
    public static final String EXCHANGE_NAME = "myExchange";

    @Bean
    public Queue queue() {
        return new Queue(QUEUE_NAME);
    }
		//定义交换器，传入交换器的名字
    @Bean
    public TopicExchange exchange() {
        return new TopicExchange(EXCHANGE_NAME);
    }

    @Bean
    public Binding binding(Queue queue, TopicExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with("routing.key.#");
    }
}
```

#### 4. 发送消息

如果发送的消息是个对象，我们会使用序列化机制，想要将对象发送，对象必须实现Serializable接口

发送消息可以通过 `AmqpTemplate` 实现。在你的服务类中注入 `AmqpTemplate`，并通过它发送消息：

```java
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class RabbitMQSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;  // 使用 RabbitTemplate

    public void send(String message) {
        System.out.println("Sending message: " + message);
        rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_NAME, RabbitConfig.ROUTING_KEY, message);
    }
}
```

#### 5. 接收消息

接收消息时，需要定义一个消息监听器。可以使用 `@RabbitListener` 注解来监听指定的队列消息。

```java
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class RabbitMQReceiver {

    @RabbitListener(queues = "myQueue")
    public void receiveMessage(String message) {
        System.out.println("收到消息: " + message);
    }
}
```

在这里，@RabbitListener 会监听队列 myQueue，并在收到消息时触发 receiveMessage() 方法。

#### 6. 测试发送和接收消息

在 Spring Boot 应用中，可以通过 REST API 或其他触发点来调用消息发送方法。比如，使用一个简单的控制器：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RabbitMQController {

    @Autowired
    private RabbitMQSender rabbitMQSender;

    @GetMapping("/send")
    public String sendMessage(@RequestParam String message) {
        rabbitMQSender.sendMessage(message);
        return "Message sent: " + message;
    }
}
```

#### 7. 启动应用

完成上述配置后，启动 Spring Boot 应用程序，访问 `/send?message=HelloWorld` 来发送消息。RabbitMQ 将处理消息，且监听器会接收到并处理它。**启动累上添加上@dEnableRabbit**的注解

### 总结

整合步骤主要分为以下几个部分：

1. 引入 `spring-boot-starter-amqp` 依赖。
2. 在 `application.yml` 中配置 RabbitMQ 连接信息。
3. 通过 `@Bean` 定义队列、交换器和绑定关系。
4. 使用 `AmqpTemplate` 发送消息。
5. 使用 `@RabbitListener` 注解接收消息。

通过这些步骤，Spring Boot 与 RabbitMQ 就能无缝集成，实现消息的发送与消费。

## RabbitMQ的消息确认机制

在每个消息传递的组件中（生产者到代理，代理到消息队列），都会想上层返回一个消息确认，从而知道消息是否成功被接受

**最后消费者会通过ACK（有点像是TCP的可靠数据传输）**，来确认消息的抵达是否完整

![image-20241005223342302](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005223342302.png)

![image-20241005223930408](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005223930408.png)

## 实现延时队列

**可以解决定时任务的消耗数据库压力的痛点**

![image-20241005224903386](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005224903386.png)

下单之后，订单给消息队列发送消息，创建一个服务来监听这个订单消息的消息队列，如果长时间没有监听到消息，就自动关闭订单。

#### ![image-20241005225050523](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005225050523.png)

#### 死信路由的概念

![image-20241005225510458](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005225510458.png)

### 延时队列实现

- **设置队列ttl时间**，并且设置死信路由，防止消息成为死信后被其他队列监听

![image-20241005225914829](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005225914829.png)

- 为消息单独设置ttl

![image-20241005230044332](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005230044332.png)

### 项目中具体实现

![image-20241005230743336](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005230743336.png)

![image-20241005230946819](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005230946819.png)

![image-20241005231301140](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005231301140.png)

![image-20241005232201917](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241005232201917.png)

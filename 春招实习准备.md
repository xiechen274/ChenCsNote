



# HOT100

## 动态规划

### 最大子数组和（LeetCode 53）

#### 题目描述

给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

------

#### 示例

- 输入: `nums = [-2,1,-3,4,-1,2,1,-5,4]`
   输出: `6`
   解释: 子数组 `[4,-1,2,1]` 的和最大，为 6。
- 输入: `nums = [1]`
   输出: `1`
- 输入: `nums = [5,4,-1,7,8]`
   输出: `23`

------

#### 解题思路

##### 方法一：暴力解法

1. 遍历所有可能的子数组。
2. 计算每个子数组的和，并维护一个变量 `maxSum` 保存最大的子数组和。
3. 时间复杂度为 O(n^2)。

**暴力解法代码：**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = Integer.MIN_VALUE; // 初始最大值
        for (int i = 0; i < nums.length; i++) {
            int currentSum = 0;
            for (int j = i; j < nums.length; j++) {
                currentSum += nums[j]; // 累加子数组元素
                maxSum = Math.max(maxSum, currentSum); // 更新最大值
            }
        }
        return maxSum;
    }
}
```

------

##### 方法二：动态规划（Kadane's算法）

1. 定义状态：

   - `dp[i]` 表示以第 `i` 个元素结尾的最大子数组和。

2. 状态转移方程：

   - 如果将 `nums[i]` 与前面的子数组连接，结果比 `nums[i]` 大，则选择连接。

   - 否则以 `nums[i]` 开始新的子数组。

   - 转移方程为：

     ```java
     dp[i] = Math.max(dp[i-1] + nums[i], nums[i])
     ```

3. 初始状态：

   - `dp[0] = nums[0]`

4. 优化：动态规划只需记录当前状态和最大值，因此可以将空间复杂度优化为 O(1)。

**动态规划代码：**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = nums[0]; // 初始化最大值
        int currentSum = nums[0]; // 当前子数组和

        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(currentSum + nums[i], nums[i]); // 状态转移
            maxSum = Math.max(maxSum, currentSum); // 更新最大值
        }

        return maxSum;
    }
}
```

------

#### 比较分析

| 方法     | 时间复杂度 | 空间复杂度 | 优点                         | 缺点                   |
| -------- | ---------- | ---------- | ---------------------------- | ---------------------- |
| 暴力解法 | O(n^2)     | O(1)       | 逻辑简单，容易实现           | 时间复杂度较高，效率低 |
| 动态规划 | O(n)       | O(1)       | 时间复杂度低，适合大规模数据 | 需要理解状态转移方程   |

------

#### 笔记总结

1. **动态规划核心**：
    将问题分解为子问题，利用子问题的最优解来推导整个问题的最优解。
2. **Kadane's算法** 是动态规划的简化实现，优化了空间复杂度。
3. 推荐使用动态规划解法，尤其在输入规模较大的情况下，时间复杂度 O(n) 更高效

## 哈希表

### 1.两数字之和

- 直接暴力

复杂度O（n方）

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
}

```

- 哈希表

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            int subSum = target - nums[i];
            if(map.containsKey(subSum)){
                return new int[]{map.get(subSum),i};
            }
            else map.put(nums[i],i);
        }
        return null;
    }
}

```



## 链表

### 相交链表

- 通过hash表，先把A链表的所有node存入set集合，然后再遍历B链表，如果b链表的某个node在集合中，就直接返回这个节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> nodeSet = new HashSet<>();
        ListNode visitA = headA;
        while(visitA != null){
            nodeSet.add(visitA);
            visitA = visitA.next;
        }
        visitA = headB;
        while(visitA != null){
            if(nodeSet.contains(visitA)) return visitA;
            else visitA = visitA.next;
        }
        return null;
    }
}
```



# 简历库

## 有用友实习参考

<img src="https://uploadfiles.nowcoder.com/message_images/20241025/850730041_1729829149938/discuss_1729829150082.jpeg?x-oss-process=image%2Fresize%2Cw_276%2Ch_276%2Cm_mfit%2Fformat%2Cpng" alt="img"  />

# 计网

## Http和Https的区别？他是如何解决加密问题的

- 除此之外，**性能上Https会消耗更多的服务器资源**

![image-20250109155510570](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109155510570.png)

### 如何解决加密



### 关键词

- **混合加密+摘要算法+数字签名+CA认证**

主要解决了三个问题：

- **信息加密**：防止传输过程的明文被窃取，使用**混合加密**（建立连接前非对称加密，建立连接之后对称加密）的方式。
- **校验机制**：使用**摘要算法（哈希函数）+数字签名**，为原始数据生成独一无二的指纹（code），检验前后的指纹是否一致，如果不一致的话就不展示，解决了**篡改风险**	
- **身份验证**：通过公钥来验证服务器身份。

**哈希函数**来保证加密的完整性，**数字签名来保证消息来源的可靠性**

![image-20250109161258652](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109161258652.png)

*还没有增加数字签名之前的流程*

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png)

### 数字签名算法

![image-20250109164021436](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109164021436.png)

加了数字签名之后

![image-20250109164132370](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109164132370.png)

### 数字证书

私钥加密，公钥解密的方式可以确定一组签名的可靠性，但是无法辨别**私钥的来源是否是想要来源**，就比如吧私钥和公钥一起篡改了，那这样识别是可以通过，但是却是冒牌的数据

![image-20250109164607956](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109164607956.png)

所以需要通过将私钥放入**CA**服务器进行认证，来认证一下发送的数据源是否是想要的

![image-20250109165001375](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109165001375.png)

## TCP

**文档**：[TCP小林Coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#)

### TCP和UDP的区别？

![TCP 头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

![image-20250107173309905](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173309905.png)

![image-20250107172916015](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107172916015.png)

![image-20250107172938404](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107172938404.png)

![image-20250107173012445](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173012445.png)

![image-20250107173210993](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173210993.png)

- UDP的头部没有**首部长度**，因为UDP的首部长度是固定的
- TCP没有**包长度**，因为TCP的包长度可以使用一定的公式计算出来

![image-20250107173444882](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173444882.png)

```
+-------------------------+-------------------------+
|         TCP             |         UDP             |
+-------------------------+-------------------------+
| 面向连接               | 无连接                 |
| 可靠性高               | 不保证可靠性           |
| 有序数据传输           | 数据可能乱序           |
| 速度较慢               | 速度较快               |
| 应用场景：文件传输等   | 应用场景：实时流媒体等 |
+-------------------------+-------------------------+
```



### TCP的三次握手

#### 回答重点

TCP 的三次握手是建立可靠连接的过程，用于确保通信双方准备就绪并交换必要信息。具体步骤如下：

1. **第一次握手**：
    客户端发送 `SYN` 报文，表示请求建立连接，并附上初始序列号（`ISN(client)`）。
   - 报文：`SYN=1, seq=ISN(client)`
   - 意图：告诉服务端自己准备好并请求通信。
2. **第二次握手**：
    服务端收到 `SYN` 后，回复 `SYN+ACK`，表示同意建立连接，并附上自己的初始序列号（`ISN(server)`）。
   - 报文：`SYN=1, ACK=ISN(client)+1, seq=ISN(server)`
   - 意图：告诉客户端自己也已准备好，并确认客户端的请求。
3. **第三次握手**：
    客户端收到 `SYN+ACK` 后，回复一个 `ACK` 报文，确认服务端的信息。
   - 报文：`ACK=ISN(server)+1, seq=ISN(client)+1`
   - 意图：告诉服务端连接已确认完成。

完成上述三次握手后，连接建立成功，双方可以开始数据传输。

------

#### 详细解析

##### 为什么需要三次握手？

- 确保通信双方准备就绪：
  - 第一次握手：客户端确认自己能发送，服务端能接收。
  - 第二次握手：服务端确认自己能发送，客户端能接收。
  - 第三次握手：客户端确认服务端的确认信息，双方同步通信状态。
- **防止历史连接误触：**
   旧的 SYN 请求可能被误处理，如果没有第三次握手确认，会导致服务端误以为建立了新的连接，浪费资源。

##### 示例状态变化

1. 客户端从 `CLOSED → SYN-SENT`。
2. 服务端从 `CLOSED → SYN-RECEIVED`，发送 `SYN+ACK`。
3. 客户端从 `SYN-SENT → ESTABLISHED`，发送 `ACK`。
4. 服务端从 `SYN-RECEIVED → ESTABLISHED`，完成连接。

------

#### 知识扩展

下图展示了三次握手的交互流程：

```
客户端                        服务端
  | ----SYN(seq=x)---->        |
  |                           |
  | <----SYN+ACK(seq=y, ack=x+1)-- |
  |                           |
  | ----ACK(ack=y+1)---->      |
  |                           |
```

- `SYN`：同步序列号，用于建立连接。
- `ACK`：确认序列号，确保报文接收无误。

------

#### 总结

TCP 的三次握手通过 `SYN` 和 `ACK` 报文协调双方状态，确保可靠连接的建立，同时防止历史连接干扰，是 TCP 协议可靠性的基础机制之一。

![image-20250107174809806](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107174809806.png)

**前两次的握手是不携带数据的**

### 为什么是三次握手？不是两次、四次？

**回答的重点从TCP**为什么三次握手**才**可以**初始化 Socket、序列号和窗口大小并建立 TCP 连接**。入手

两次握手：![image-20250108144916879](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108144916879.png)

![image-20250108145018726](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108145018726.png)

![两次握手会造成资源浪费](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png)

四次握手：![image-20250108144957600](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108144957600.png)

#### 小结

![image-20250108144744417](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108144744417.png)

## WebSocket和http

> websocket最主要的特征就是，服务器可以主动给客户端发送数据

### **1. HTTP vs WebSocket**

- **HTTP 协议特点**：
  - **半双工**：客户端发起请求，服务端响应，通信过程有明确的主从关系。
  - **请求/响应模型**：服务端无法主动推送数据给客户端。
  - **适用场景**：静态网页、普通接口调用等单次请求-响应的场景。
  
- **WebSocket 协议特点**：
  - **全双工**：基于 TCP，通信双方可随时主动发送数据。
  - **长连接**：只需一次握手，连接保持期间可多次发送数据，无需重复创建连接。
  - **适用场景**：需要频繁交互、服务端主动推送的场景，如实时聊天、网页游戏、协作办公。

- **为什么需要 WebSocket？**
  - HTTP 适用于静态内容交互，但在 **实时通信** 场景下效率低（如扫码登录、实时推送）。
  - WebSocket 补足了 HTTP 的不足，为实时性需求提供了高效解决方案。

---

### **2. WebSocket 连接建立过程**

1. **HTTP 升级机制**：
   - 浏览器发起 HTTP 请求时，带上以下 Header：
     - `Connection: Upgrade`
     - `Upgrade: websocket`
     - `Sec-WebSocket-Key`：随机 Base64 字符串，用于校验。
   - 服务器返回：
     - 状态码 `101 Switching Protocols` 表示协议切换。
     - `Sec-WebSocket-Accept`：根据客户端的 `Sec-WebSocket-Key` 计算得到，用于验证合法性。

2. **通信建立后**：
   - 双方通过 WebSocket 的数据格式通信，完全脱离 HTTP。

---

### **3. WebSocket 报文格式**
- **帧（Frame）结构**：
  - **FIN**：是否是消息的最后一帧。
  - **Opcode**：
    - `0x1`：文本数据（string）。
    - `0x2`：二进制数据（byte[]）。
    - `0x8`：关闭连接。
  - **Payload length**：数据长度（动态编码，可能是 7、7+16 或 7+64 bits）。
  - **Masking-key**：客户端向服务端发送数据时的掩码，用于数据加密。
  - **Payload data**：实际数据。

- **Payload 长度编码规则**：
  - 0-125：直接使用 7 bits 表示长度。
  - 126：额外使用 16 bits 表示长度。
  - 127：额外使用 64 bits 表示长度。

---

### **4. HTTP 长轮询（Long Polling）**
- **机制**：
  - 客户端发起请求，服务端不立即响应，而是保持连接直到有数据或超时。
  - 若超时无响应，客户端重新发起下一次请求。
- **优点**：
  - 减少重复请求的带宽浪费，提升用户体验。
- **缺点**：
  - 保持连接时间较长，占用服务端资源，非最佳实时通信方式。

---

### **5. 服务器推送技术**
- **伪推送：轮询**：
  - 客户端主动发起请求（短轮询、长轮询），看似服务端推送，实际是客户端请求。
- **真推送：WebSocket**：
  - 服务端主动将消息发送到客户端，无需等待客户端请求。

---

### **6. 使用场景**
1. **HTTP 定时轮询**：
   - 场景：扫码登录、简单状态检查。
   - 特点：实现简单，但不适合复杂实时需求。
2. **HTTP 长轮询**：
   - 场景：文件上传进度通知、即时通知。
   - 特点：减少轮询次数，但资源占用较大。
3. **WebSocket**：
   - 场景：实时游戏、在线聊天、协作工具（如飞书）。
   - 特点：高效、实时、适合频繁通信。

---

### **7. 总结对比**
| **特性**     | **HTTP**            | **WebSocket**          |
| ------------ | ------------------- | ---------------------- |
| **通信模式** | 半双工              | 全双工                 |
| **连接方式** | 短连接              | 长连接                 |
| **数据推送** | 客户端主动拉取      | 服务端可主动推送       |
| **适用场景** | 请求-响应式应用场景 | 实时性强的场景         |
| **协议建立** | 无需额外操作        | 需进行协议升级（HTTP） |

---

### **8. 示例：WebSocket 与 HTTP 抓包分析**
- WebSocket 建立连接前：
  - HTTP 请求带特殊头部 (`Upgrade: websocket`)。
- WebSocket 协议切换后：
  - 不再使用 HTTP 报文，而是直接基于 WebSocket 帧结构通信。

---

### **9. 延伸问题**
- **WebSocket 与 Socket 的关系**：
  - WebSocket 是基于 TCP 的应用层协议，解决了应用层通信的格式和数据边界问题。
  - Socket 是编程接口（API），用于实现网络通信，不限制协议层级。

- **HTTP/2 与 WebSocket 的对比**：
  - HTTP/2 引入了流的概念，支持服务端推送，但在全双工通信和实时性上仍不如 WebSocket 专用。

---

这篇笔记系统化地总结了 HTTP 和 WebSocket 的区别、技术原理、使用场景和实践意义，适合初学者或复习时参考。

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241117114500583.png" alt="image-20241117114500583" style="zoom:50%;" />

websocket和http是两种协议，只不过前者的建立实在后者先连接的基础上再header中put响应的请求头信息来升级协议

# 操作系统

# Java基础

## private和protected的区别

- ### 回答重点

  在Java中，`protected` 和 `private` 是两种访问修饰符，用于控制类的成员（字段、方法或构造方法）的可见性和访问权限：

  1. **`protected`**
     - 访问范围：
       - 当前类
       - 同一包中的其他类
       - 继承该类的子类（即使不在同一包中，也可以访问 `protected` 的成员）
     - **典型场景：**
        适合在继承关系中提供子类访问权限，同时对无关类隐藏。
  2. **`private`**
     - 访问范围：
       - 仅限当前类内部。
     - **典型场景：**
        用于隐藏类的实现细节，只允许通过公有方法（getter、setter）或其他内部逻辑访问。

  ------

  ### 详细解析

  #### `protected` 关键点

  - 跨包访问限制：

     只能通过子类访问，不能直接通过对象访问。例如：

    ```java
    package packageA;
    public class Parent {
        protected void display() {
            System.out.println("Protected method");
        }
    }
    
    package packageB;
    import packageA.Parent;
    
    public class Child extends Parent {
        public void test() {
            display(); // 合法，子类继承访问
        }
    }
    ```

    如果 

    ```
    Child
    ```

     和 

    ```
    Parent
    ```

     是不同包中的类，

    ```
    display
    ```

     方法只能通过继承访问，不能通过实例直接调用。

  #### `private` 关键点

  - **完全隐藏：** 任何其他类，包括子类，均无法直接访问。

    ```java
    public class Parent {
        private String secret = "Hidden";
    
        private void showSecret() {
            System.out.println(secret);
        }
    
        public void accessSecret() {
            showSecret(); // 可通过公有方法间接访问
        }
    }
    ```

  - **封装性：** 强制使用者通过控制方法（如 getter 或 setter）访问和修改数据，便于控制输入输出的合法性。

  ------

  ### 知识扩展

  | 关键字      | 当前类 | 同包 | 子类（跨包） | 其他包 |
  | ----------- | ------ | ---- | ------------ | ------ |
  | `public`    | ✔      | ✔    | ✔            | ✔      |
  | `protected` | ✔      | ✔    | ✔            | ✘      |
  | `default`   | ✔      | ✔    | ✘            | ✘      |
  | `private`   | ✔      | ✘    | ✘            | ✘      |

  1. **`protected` vs `default` (无修饰符)**
      默认访问修饰符（`default`）仅限于包内访问，而 `protected` 允许子类跨包访问。

  2. **访问控制优先级：** `private` < `default` < `protected` < `public`

  3. **示意图：**

     ```text
     包A:
     ----------------------
     [ 类A ]  protected成员
             ↗
     包B:
     ----------------------
     [ 类B (子类) ]
     ```

  ------

  ### 总结

  - `private` 提供最严格的封装，仅供类内部使用。
  - `protected` 提供包访问权限，并扩展到子类，**即在继承关系中提供更高的灵活性。**

  



## Java中抽象类和接口有什么区别

### 设计动机

![image-20250110112841711](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110112841711.png)



## Java中为什么不支持多继承

Java不支持多重继承是因为它可能导致 **“钻石问题”**（Diamond Problem），增加代码的复杂性和模糊性。通过接口（`interface`）的机制，Java在一定程度上实现了多继承的灵活性，同时避免了多重继承的主要缺陷。

**拓展：为什么接口可以实习多实现**

理解：对于相同的重复方法且有不同的写法，子类必须重写接口，相当于归一化。

![image-20250110111210207](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110111210207.png)

## 为什么继承只允许单继承，接口可以多实现呢？

从设计角度上理解

- 接口是决定类有哪些能力can-do ，一个对象类可以掌握多个能力（规范）（实现多个接口）
- 继承是决定这个类是什么，所以从合理性解释一个类也只能是某一个父类的继承

![image-20250110111836362](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110111836362.png)



## JDK 和 JRE 有什么区别？

**回答重点：**

**JRE(Java Runtime Environment)指的是 Java 运行环境，包含了 JVM、核心类库和其他支持运行 Java 程序的文件。**

- JVM（Java Virtual Machine）：执行 Java 字节码，提供了 Java 程序的运行环境。
- 核心类库：一组标准的类库（如 java.lang、java.util 等），供 Java 程序使用。
- 其他文件：如配置文件、库文件等，支持 JVM 的运行。

JDK（Java Development Kit）可以视为 JRE 的超集，是用于开发 Java 程序的完整开发环境，它包含了 JRE，以及用于开发、调试和监控 Java 应用程序的工具。

- JRE：JDK 包含了完整的 JRE，因此它也能运行 Java 程序。
- 开发工具：如编译器（javac）、调试器（jdb）、打包工具（jar）等，用于开发和管理 Java 程序。
- 附加库和文件：支持开发、文档生成和其他开发相关的任务。

## Java中Exception和Error的区别？

![image-20250110092220609](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110092220609.png)

![image-20250110092355583](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110092355583.png)

## Java的传参本质

在 Java 中，所有的参数传递本质上是 **值传递**。然而，这种值传递在不同的情境下可能表现得像“引用传递”，这是因为 Java 的对象引用本身是以值的形式传递的。我们具体来看：

------

### 1. 基本数据类型

对于 **基本数据类型**（`int`, `double`, `char`, `boolean` 等），参数传递的是变量的值，即复制了一份变量的内容。

**示例：**

```java
public class Test {
    public static void main(String[] args) {
        int num = 10;
        modifyValue(num);
        System.out.println("num 的值: " + num); // 输出: num 的值: 10
    }

    public static void modifyValue(int value) {
        value = 20; // 修改的是 value 的副本，与 num 无关
    }
}
```

**结论：** 基本数据类型的值不会受到方法内修改的影响，因为方法内操作的是副本。

------

### 2. 引用数据类型

对于 **引用数据类型**（如数组、对象等），参数传递的仍然是值，但这个值是**对象的引用地址的副本**。因此，通过这个副本，方法可以修改引用所指向的对象内容，但不能改变引用本身的指向。

**示例 1：修改对象的内容**

```java
public class Test {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        modifyArray(arr);
        System.out.println("arr[0] 的值: " + arr[0]); // 输出: arr[0] 的值: 99
    }

    public static void modifyArray(int[] array) {
        array[0] = 99; // 修改了引用指向的对象
    }
}
```

**示例 2：尝试修改引用本身**

```java
public class Test {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        changeReference(arr);
        System.out.println("arr[0] 的值: " + arr[0]); // 输出: arr[0] 的值: 1
    }

    public static void changeReference(int[] array) {
        array = new int[]{99, 98, 97}; // 修改的是 array 的副本，与原引用无关
    }
}
```

**结论：**

- 方法可以通过引用地址修改对象的内容。
- 方法无法改变外部变量的引用地址。

------

### 总结

1. **基本数据类型**：值传递，方法内操作的是副本。
2. **引用数据类型**：值传递，方法内操作的是对象引用地址的副本，可以通过它修改对象的内容，但不能修改引用本身。

**进一步思考：**

- 如果需要实现类似“引用传递”的行为，可以使用包装类（如 `AtomicInteger`）或将变量封装在自定义对象中。



## Java中的序列化和反序列化是什么？

![image-20241127141207657](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141207657.png)

![image-20241127141230685](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141230685.png)

### 实现这个接口的意义

![image-20241127141255819](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141255819.png)

![image-20241127141711398](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141711398.png)

**通过id来验证在反序列化的过程中是否出错**

## Java 中的 hashCode 和 equals 方法之间有什么关系？ 

在 Java 中，`hashCode` 和 `equals` 是 Object 类中定义的两个重要方法。它们在集合框架中（如 `HashMap`、`HashSet`）和对象比较中发挥重要作用。这两个方法之间有紧密的关系，并且需要遵循特定的约定。

------

### **`hashCode` 方法**

- **作用**：
  - 返回对象的哈希值（一个整数）。
  - 用于确定对象在基于哈希的集合（如 `HashMap`、`HashSet`）中的存储位置。
- **默认实现**：
  - 默认情况下，`Object` 的 `hashCode` 方法返回对象的内存地址的哈希码。
- **需要重写时**：
  - 当类重写了 `equals` 方法时，也必须重写 `hashCode` 方法，以确保逻辑一致性。

------

### **`equals` 方法**

- **作用**：
  - 比较两个对象的内容是否相等。
  - 默认比较对象的引用地址。
- **默认实现**：
  - 默认情况下，`Object` 的 `equals` 方法比较对象的引用地址，即 `obj1 == obj2`。
- **需要重写时**：
  - 如果希望按内容比较两个对象是否相等（例如比较两个 `Person` 对象的 `name` 和 `age`），需要重写 `equals` 方法。

------

### **`hashCode` 和 `equals` 的关系**

根据 Java 的规范，`hashCode` 和 `equals` 方法必须满足以下关系：

1. **一致性（Consistent Relationship）**：
   - 如果两个对象根据 `equals` 方法比较是相等的（即 `a.equals(b)` 返回 `true`），那么它们的 `hashCode` 值必须相同。
2. **非强制要求（Not Required but Encouraged）**：
   - 如果两个对象根据 `equals` 方法比较不相等，则它们的 `hashCode` 值可以相同，但不建议。
3. **一致性约束（HashCode Contract）**：
   - 在同一次程序运行中，只要对象的内容未发生变化，多次调用同一个对象的 `hashCode` 方法应该返回相同的值。

如果这两个方法的逻辑不一致，可能会导致基于哈希的数据结构（如 `HashMap` 或 `HashSet`）工作异常。

------

### **示例代码**

下面是一个类重写 `equals` 和 `hashCode` 的示例：

```java
import java.util.Objects;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // 同一对象
        if (obj == null || getClass() != obj.getClass()) return false; // 类型不同
        Person person = (Person) obj; // 类型转换
        return age == person.age && Objects.equals(name, person.name); // 比较内容
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age); // 生成哈希值
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("Alice", 25);
        Person p2 = new Person("Alice", 25);
        Person p3 = new Person("Bob", 30);

        // equals 比较
        System.out.println("p1 equals p2: " + p1.equals(p2)); // true
        System.out.println("p1 equals p3: " + p1.equals(p3)); // false

        // hashCode 比较
        System.out.println("p1 hashCode: " + p1.hashCode());
        System.out.println("p2 hashCode: " + p2.hashCode());
        System.out.println("p3 hashCode: " + p3.hashCode());

        // 基于 HashSet
        HashSet<Person> set = new HashSet<>();
        set.add(p1);
        set.add(p2); // 不会添加，因为 p1.equals(p2)
        set.add(p3);
        System.out.println("HashSet 内容: " + set);
    }
}
```

------

### **重要注意点**

1. **一致性问题**： 如果只重写了 `equals` 而没有重写 `hashCode`，可能会导致在 `HashMap` 或 `HashSet` 中存储和查找对象时行为异常。
2. **性能问题**： 不建议两个不相等的对象产生相同的哈希值（哈希冲突），因为这会降低哈希结构的性能。
3. **推荐使用 `Objects.hash`**：
   - 使用 `Objects.hash` 方法生成哈希值，简化代码。

------

### **总结**

- `equals` 决定对象是否“逻辑相等”。
- `hashCode` 决定对象在基于哈希的数据结构中的位置。
- 必须同时重写 `equals` 和 `hashCode`，确保它们逻辑一致。



在 Java 中，`hashCode` 和 `equals` 的知识在集合框架和实际开发中非常重要，尤其是在面试中常被用作核心问题。以下是一些扩展问题及其解答，以帮助理解这些方法的实际应用和潜在挑战。

------

### **扩展问题 1：`hashCode` 和 `equals` 在集合中的作用**

#### **问题**：在 HashMap 和 HashSet 中，`hashCode` 和 `equals` 是如何发挥作用的？

#### **解答**：

- **HashMap**：

  1. 存储键值对时

     ：

     - `hashCode` 决定键存储在哪个哈希桶（bucket）中。
     - 如果两个键的 `hashCode` 相同，它们会被存储到同一个桶中，形成链表（或树形结构，Java 8 引入）。
     - 再通过 `equals` 方法检查链表中的对象，确保键的唯一性。

  2. 查找键值对时

     ：

     - 首先根据 `hashCode` 定位桶。
     - 然后在桶中通过 `equals` 方法找到匹配的键。

- **HashSet**：

  - 工作原理与 HashMap 类似，但 HashSet 底层是通过一个 HashMap 来实现的，其中键为对象，值是一个固定值（通常为 `null`）。

#### **示例代码**：

```java
import java.util.HashSet;

class Example {
    private int value;

    public Example(int value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Example example = (Example) obj;
        return value == example.value;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(value);
    }
}

public class Main {
    public static void main(String[] args) {
        HashSet<Example> set = new HashSet<>();
        set.add(new Example(1));
        set.add(new Example(1)); // 因为 equals 返回 true，不会加入
        set.add(new Example(2));
        System.out.println("HashSet 内容: " + set.size()); // 输出 2
    }
}
```

------

### **扩展问题 2：`hashCode` 和 `equals` 不一致的后果**

#### **问题**：如果 `hashCode` 和 `equals` 逻辑不一致会发生什么？

#### **解答**：

1. **结果错误**：
   - 如果对象的 `hashCode` 相同，但 `equals` 不一致（即两个对象哈希值相同，但内容不等），可能会导致哈希表存储错误，出现重复对象或无法找到对象。
2. **查找失败**：
   - 如果 `hashCode` 逻辑错误，即使 `equals` 返回 `true`，在基于哈希的集合中仍可能找不到对象。
3. **性能下降**：
   - 如果大量对象的 `hashCode` 值相同（哈希冲突严重），会导致哈希表退化成链表，查找性能从 O(1) 降低到 O(n)。

------

### **扩展问题 3：如何设计一个良好的 `hashCode` 和 `equals` 实现？**

#### **问题**：重写 `hashCode` 和 `equals` 时有哪些最佳实践？

#### **解答**：

1. **`hashCode` 的设计**：
   - 使用所有参与 `equals` 比较的字段。
   - 尽量减少哈希冲突，分布均匀。
   - 推荐使用 `Objects.hash` 方法，或者参考经典算法（如乘法散列法）。
2. **`equals` 的实现**：
   - 避免直接使用 `==` 比较引用。
   - 检查对象是否为 `null` 和类型是否匹配。
   - 使用所有重要字段进行比较。
   - 遵循对称性、传递性、一致性等规范。

------

### **扩展问题 4：为什么推荐在 `equals` 中使用 `getClass` 而不是 `instanceof`？**

#### **问题**：在 `equals` 方法中，用 `getClass` 和 `instanceof` 有什么区别？

#### **解答**：

- **`getClass`**：
  - 比较时要求对象必须是同一类。
  - 适用于精确比较，例如比较两个完全相同类型的类。
- **`instanceof`**：
  - 判断对象是否为某个类或其子类的实例。
  - 适用于允许子类逻辑相等的场景。

#### **示例**：

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false; // 精确匹配
    MyClass other = (MyClass) obj;
    return field == other.field;
}

// 或使用 instanceof
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof MyClass)) return false; // 允许子类
    MyClass other = (MyClass) obj;
    return field == other.field;
}
```

**区别**：

- `getClass` 更严格，适用于不可变类（例如 `Integer`、`String`）。
- `instanceof` 更宽松，适用于继承层次结构中的多态比较。

------

### **扩展问题 5：面试中可能衍生的进阶问题**

1. **在 `TreeSet` 或 `TreeMap` 中，`hashCode` 和 `equals` 是否重要？**
   - 答：它们不重要，因为 `TreeSet` 和 `TreeMap` 使用 `compareTo` 或自定义的 `Comparator` 方法进行排序和比较。
2. **如何实现对象的深拷贝（基于序列化）？**
   - 答：通过序列化和反序列化可以实现深拷贝，但需要类实现 `Serializable` 接口。
3. **如何避免 `HashMap` 中的哈希冲突？**
   - 答：设计一个好的 `hashCode` 方法以均匀分布对象；此外，Java 8 中的 `HashMap` 在冲突链超过一定长度后会使用红黑树优化。
4. **`hashCode` 和 `equals` 是否适用于多线程环境？**
   - 答：默认情况下它们是线程安全的，但如果涉及可变字段且这些字段被多个线程修改，则需要同步或使用不可变对象。

# Redis

## 缓存雪崩、击穿、穿透

### 回答重点

**大量的缓存key，在同一时间过期，所有的请求直接访问到数据库上**

### 解决方案

- 增加key过期时间的随机性

### 其他问题

![image-20250120172856643](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250120172856643.png)

# Spring

## @Resource和@Autowire的区别？

`https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5`参考链接

### 回答重点

`@Resource` 和 `@Autowired` 是 Spring 框架中用来实现依赖注入的两个注解，功能相似但有一些关键区别：

- **来源**：
  - `@Resource` 是 JSR-250 规范的一部分，属于 Java 标准，位于 `javax.annotation` 包中。
  - `@Autowired` 是 Spring 提供的注解，位于 `org.springframework.beans.factory.annotation` 包中。
- **注入方式**：
  - `@Resource` 默认按 **名称** 注入，可以通过 `name` 属性指定注入的 Bean 名称。如果没有指定 `name` 且找不到对应的名称 Bean，会按 **类型** 注入。
  - `@Autowired` 默认按 **类型** 注入。如果需要按名称注入，可以结合 `@Qualifier` 注解使用。
- **配置属性**：
  - `@Resource` 提供了 `name` 和 `type` 两个属性，用于精确指定注入的目标。
  - `@Autowired` 提供了 `required` 属性，用于控制是否必须注入（默认值为 `true`，即必须注入）。
- **适用范围**：
  - `@Resource` 通常用于更通用的场景，与 Java EE 兼容。
  - `@Autowired` 是 Spring 特有的，依赖于 Spring 容器。

------

### 详细解析

#### 1. **`@Resource` 的使用**

```java
@Resource(name = "myService")
private MyService service;
```

- **按名称注入**：如果指定了 `name` 属性，Spring 会在容器中查找名为 `"myService"` 的 Bean 并注入。
- **按类型注入**：如果没有指定 `name` 属性，Spring 会根据字段或属性的类型寻找匹配的 Bean。

------

#### 2. **`@Autowired` 的使用**

```java
@Autowired
private MyService service;
```

- **按类型注入**：Spring 根据 `MyService` 的类型寻找匹配的 Bean。
- **可选性控制**：`@Autowired(required = false)` 表示注入是可选的，如果没有找到匹配的 Bean，字段将保持未赋值。

```java
@Autowired(required = false)
private Optional<MyService> service; // Java 8 的 Optional
```

------

#### 3. **两者的对比示例**

假设我们有以下配置：

```java
@Component("myService")
public class MyServiceImpl implements MyService {
    // 实现方法
}
```

使用 `@Resource` 和 `@Autowired` 注入：

```java
@Component
public class MyController {

    @Resource(name = "myService")
    private MyService service1; // 按名称注入

    @Autowired
    private MyService service2; // 按类型注入
}
```

**总结**：

- 如果 `@Resource(name = "myService")` 找不到指定名称的 Bean，会抛出异常。
- 如果 `@Autowired` 找到多个 `MyService` 类型的 Bean，会抛出歧义性异常。

------

### 知识扩展

#### Spring 框架中的依赖注入模式

1. **构造器注入**：通过构造函数实现依赖注入，推荐用于不可变字段。
2. **Setter 注入**：通过 Setter 方法注入，适合可选的依赖。
3. **字段注入**：通过注解直接注入，简洁但难以测试。

#### 依赖注入的优先级

Spring 中多个注解可能同时使用时的优先级：

- `@Resource` 的优先级高于 `@Autowired`，如果一个字段同时标注了两者，`@Resource` 生效。

#### 多 Bean 的注入

当有多个类型相同的 Bean 时：

1. `@Qualifier` 和 `@Autowired` 配合使用，明确指定 Bean 名称。
2. 使用 `@Primary` 在一个 Bean 上标记为默认注入。

------

### 总结

![image-20250109092346658](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092346658.png)

- **`@Resource` 更关注名称匹配，兼容性强，适合跨框架使用，是java原生的javax.annotation下。**

- **`@Autowired` 更灵活，强类型注入，与 Spring 框架深度集成，如果又多个相同Type的，可以结合Qualifier注解**

  ![结合Qualifer注解搭配Autowired](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092226343.png)

![image-20250109092039180](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092039180.png)

------

### 相关面试题

1. 如果容器中有两个相同类型的 Bean，分别使用 `@Resource` 和 `@Autowired`，结果会怎样？
2. 请解释 `@Primary` 和 `@Qualifier` 的作用及区别。
3. 如果同时使用了 `@Resource` 和 `@Autowired`，如何确定最终注入的 Bean？
4. 使用 `@Autowired` 注入时，如何处理可能为空的依赖？

## IoC和DI的区别？

IoC（Inverse of Control:控制反转）是一种设计思想或者说是某种模式。这个设计思想就是 **将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容器。** 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。

IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。

### 总结

| **对比维度** | **IOC**                        | **DI**                       |
| ------------ | ------------------------------ | ---------------------------- |
| 定义         | 一种设计原则                   | 实现IOC的具体方式            |
| 核心目标     | 反转对象创建和依赖管理的控制权 | 注入依赖，解耦对象           |
| 实现方式     | 可通过DI、服务定位器等实现     | 通过构造器、Setter等方式实现 |
| 依赖于容器   | 是                             | 是                           |



## Spring注入依赖的几种方式？

- Setter：在xml中注入setter方法

本质上包含两步：

1. **第一步，需要new UserServiceImpl()创建对象, 所以需要默认构造函数**
2. **第二步，调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数**

![image-20250109093938337](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093938337.png)、

- 构造函数注入

![image-20250109094055803](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109094055803.png)

- 最后一个就是最常用的注解注入

![image-20250109092526737](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092526737.png)

## Spring注入IOC容器的几种方法

![image-20250109093716248](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093716248.png)

- 注解注入

![image-20250109093824147](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093824147.png)

- xm配置

![image-20250109093814489](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093814489.png)

- @Configuration+@Bean
- ![image-20250109093747283](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093747283.png)

## @Component和@Configuration的区别

### 主要回答

![image-20250109093542631](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093542631.png)



## Bean的作用域有几种

![image-20250109100026118](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109100026118.png)

**官网最新的六种作用域**

![image-20250109095919790](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109095919790.png)

### 1.Singleton(默认)

- **描述**：默认作用域。Spring 容器中只会创建该 Bean 的一个实例，无论你获取多少次，始终是同一个对象。
- **使用场景**：适合无状态的、共享资源的 Bean。
- **声明方式**：`@Scope("singleton")` 或默认不声明。

### 2. **Prototype**

- **描述**：每次获取时都会创建一个新的实例。
- **使用场景**：适合需要频繁创建的 Bean，例如多线程中需要独立状态的 Bean。
- **声明方式**：`@Scope("prototype")`。

### 3. **Request**

- **描述**：每个 HTTP 请求都会创建一个新的实例，生命周期与请求相同。
- **使用场景**：适合 Web 应用中与单次请求关联的 Bean。
- **声明方式**：`@Scope("request")`。
- **前提**：需要在 Web 应用环境下运行。

### 4. **Session**

- **描述**：每个 HTTP Session 会创建一个新的实例，生命周期与会话相同。
- **使用场景**：适合 Web 应用中需要与用户会话绑定的 Bean。
- **声明方式**：`@Scope("session")`。
- **前提**：需要在 Web 应用环境下运行。

### 5. **Application**

- **描述**：在 ServletContext 级别共享同一个实例，生命周期与 Web 应用程序一致。
- **使用场景**：适合整个应用程序范围共享的 Bean。
- **声明方式**：`@Scope("application")`。
- **前提**：需要在 Web 应用环境下运行。

### 6. **WebSocket**

- **描述**：每个 WebSocket 会话都会创建一个新的实例。
- **使用场景**：适合基于 WebSocket 会话的 Bean。
- **声明方式**：`@Scope("websocket")`。
- **前提**：需要在支持 WebSocket 的应用中运行。



## 怎么绑定Bean的作用域？

**重点**：通过Scope来绑定

```java
@Component
@Scope(value = "request")
public class RequestScopedBean {
}

```



![image-20250109100457772](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109100457772.png)



## @RequestBody的作用？

### 回答重点

`@RequestBody` 是 Spring 框架中用于将 HTTP 请求体内容绑定到 Java 对象的注解，通常用于处理 JSON 或 XML 格式的数据。在 Spring 的 `@Controller` 或 `@RestController` 方法中，`@RequestBody` 解析请求体，并将其转换为方法参数对象。

------

### 详细解析

#### 使用场景

1. **处理 HTTP POST/PUT 请求的请求体**
   - 通常用于 RESTful 接口，在客户端提交 JSON 或 XML 数据时，服务器端需要将这些数据转换为 Java 对象以便进一步处理。
2. **结合 Jackson 序列化**
   - Spring MVC 使用 Jackson 库（默认）将 JSON 数据反序列化为对应的 Java 对象，或者将 Java 对象序列化为 JSON 数据返回。

#### 示例代码

```java
@RestController
public class UserController {
    @PostMapping("/users")
    public String createUser(@RequestBody User user) {
        return "User " + user.getName() + " created successfully!";
    }
}

class User {
    private String name;
    private int age;

    // getters and setters
}
```

#### 请求示例

**请求 URL:**
 `POST http://localhost:8080/users`

**请求体 (JSON):**

```json
{
    "name": "Alice",
    "age": 25
}
```

**服务器输出:**
 `User Alice created successfully!`

#### 工作原理

1. Spring MVC 使用 `HttpMessageConverter`（例如 `MappingJackson2HttpMessageConverter`）读取请求体并将其反序列化。
2. 通过 `@RequestBody` 注解标注的方法参数会被自动注入反序列化后的对象。
3. 如果请求体与目标对象结构不匹配，则会抛出异常，如 `HttpMessageNotReadableException`。

#### 特点与限制

- 优点

  :

  - 简化了手动解析请求体的工作。
  - 与 Spring 的依赖注入无缝集成。

- 限制

  :

  - 默认需要请求体，否则会抛出异常。如果请求体可选，可以通过设置 

    ```
    required = false
    ```

     来实现:

    ```java
    public ResponseEntity<?> update(@RequestBody(required = false) User user) { ... }
    ```

------

### 知识扩展

#### 常见错误及解决方法

1. **`HttpMessageNotReadableException`**
   - 原因：请求体与 Java 对象结构不匹配。
   - 解决：确保 JSON 数据与目标对象的字段和类型一致。
2. **缺少默认构造函数**
   - 原因：目标对象缺少无参构造函数。
   - 解决：为 POJO 添加无参构造函数。
3. **字符编码问题**
   - 确保客户端和服务器之间的字符集一致（如 UTF-8）。

#### 与其他注解的对比

| 注解              | 作用                                     |
| ----------------- | ---------------------------------------- |
| `@RequestBody`    | 将请求体绑定到方法参数对象               |
| `@RequestParam`   | 提取 URL 中的查询参数或表单参数          |
| `@PathVariable`   | 提取 URL 路径中的动态部分                |
| `@ModelAttribute` | 将表单数据绑定到对象（通常用于表单提交） |

------

### 总结

`@RequestBody` 是一个强大的工具，用于简化 JSON 或 XML 请求数据到 Java 对象的映射。它适合在 RESTful 风格的 API 中处理复杂的请求数据。通过结合 Spring 的序列化机制，开发者可以快速实现接口功能，同时提高代码的可读性和可维护性。





# MYSQL

## 什么是数据库的隔离级别

### **什么是事务隔离级别？**

**事务隔离级别**是数据库系统用来定义多个事务并发执行时，相互之间隔离程度的机制。它主要解决在并发事务环境下可能出现的数据不一致问题，比如**脏读**、**不可重复读**和**幻读**。

事务隔离级别通过设置不同的限制，来控制事务对共享资源（如表、行、页）的访问方式，以平衡数据一致性和系统性能。

------

### **事务的四大特性（ACID）与隔离性**

事务的四大特性是 **ACID**（Atomicity, Consistency, Isolation, Durability），其中的 **Isolation（隔离性）** 就是事务隔离级别的核心所在。
 隔离性确保一个事务的执行不会受到其他事务中间状态的干扰。

------

### **事务隔离级别的分类**

SQL标准定义了 4 种隔离级别，隔离性从低到高依次为：

| **隔离级别**            | **描述**                                                     | **解决的问题**               | **典型问题可能性**     |
| ----------------------- | ------------------------------------------------------------ | ---------------------------- | ---------------------- |
| **1. READ UNCOMMITTED** | 事务可以读取到其他事务未提交的数据（脏读）                   | 无限制，性能最高，但一致性差 | 脏读、不可重复读、幻读 |
| **2. READ COMMITTED**   | 事务只能读取到其他事务已提交的数据（防止脏读）               | 避免脏读                     | 不可重复读、幻读       |
| **3. REPEATABLE READ**  | 事务多次读取同一行数据，读取结果始终一致（防止不可重复读），但可能出现幻读 | 避免脏读和不可重复读         | 幻读                   |
| **4. SERIALIZABLE**     | 所有事务串行化执行（完全隔离，防止幻读），相当于加锁处理     | 避免脏读、不可重复读和幻读   | 无并发性，性能最低     |

------

### **四种隔离级别的行为差异**

隔离级别的定义决定了能防止哪些并发问题：

| 隔离级别             | 脏读 (Dirty Read) | 不可重复读 (Non-Repeatable Read) | 幻读 (Phantom Read) |
| -------------------- | ----------------- | -------------------------------- | ------------------- |
| **READ UNCOMMITTED** | 可能              | 可能                             | 可能                |
| **READ COMMITTED**   | 禁止              | 可能                             | 可能                |
| **REPEATABLE READ**  | 禁止              | 禁止                             | 可能                |
| **SERIALIZABLE**     | 禁止              | 禁止                             | 禁止                |

------

### **隔离级别的详细说明**

#### **1. READ UNCOMMITTED（读未提交）**

- 特点：
  - 事务可以读取到其他事务尚未提交的数据。
  - 并发性能最好，但可能导致数据一致性问题。
- 问题：
  - 可能发生 **脏读**、**不可重复读** 和 **幻读**。
- 适用场景：
  - 数据一致性要求较低的场景，例如日志系统。

#### **2. READ COMMITTED（读已提交）**

- 特点：
  - 一个事务只能读取到其他事务已提交的数据。
  - 避免了 **脏读**。
- 问题：
  - 可能发生 **不可重复读** 和 **幻读**。
- 适用场景：
  - 需要避免脏读，且对不可重复读和幻读容忍的业务场景，例如在线查询系统。
- MySQL中：
  - Oracle 数据库默认隔离级别。

#### **3. REPEATABLE READ（可重复读）**

- 特点：
  - 在同一事务中，多次读取同一行的数据时，结果是一致的。
  - 避免了 **脏读** 和 **不可重复读**。
- 问题：
  - 可能发生 **幻读**。
- 适用场景：
  - 读一致性要求高的场景，例如财务系统。
- MySQL中：
  - 默认的隔离级别。MySQL通过多版本并发控制（MVCC）机制解决了幻读问题。

#### **4. SERIALIZABLE（可串行化）**

- 特点：
  - 强制事务串行化执行，避免了所有并发问题（脏读、不可重复读、幻读）。
  - 等效于对每个查询加锁。
- 问题：
  - 并发性能最低，可能出现大量锁等待。
- 适用场景：
  - 数据一致性要求极高且并发需求较低的场景，例如银行转账系统。

------

### **如何选择事务隔离级别？**

选择隔离级别需要权衡**性能**与**一致性**：

1. 性能优先，容忍一定的不一致性：
   - 使用 **READ UNCOMMITTED** 或 **READ COMMITTED**。
2. 一致性优先，但需要较高并发：
   - 使用 **REPEATABLE READ**（MySQL 默认）。
3. 一致性绝对优先，完全避免并发问题：
   - 使用 **SERIALIZABLE**，但性能会显著下降。

------

### **MySQL中的事务隔离级别**

- 默认隔离级别：**REPEATABLE READ**。

- 配置方法：

  1. 修改全局或会话级别隔离级别：

     ```sql
     SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 全局修改
     SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; -- 会话修改
     ```

  2. 在事务中设置隔离级别：

     ```sql
     SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
     START TRANSACTION;
     ```

------

### **事务隔离级别与常见问题的示例**

#### **(1) 脏读问题**

- **场景：** 一个事务读取了另一个未提交事务的修改数据。
- **避免方式：** 选择 **READ COMMITTED** 或更高。

#### **(2) 不可重复读问题**

- **场景：** 一个事务两次读取同一行数据，但因为另一个事务修改了数据，导致结果不同。
- **避免方式：** 选择 **REPEATABLE READ** 或更高。

#### **(3) 幻读问题**

- **场景：** 一个事务两次查询同一条件的数据范围，但另一个事务插入了新数据，导致查询结果不一致。
- **避免方式：** 选择 **SERIALIZABLE**。

------

### **事务隔离级别的重要性**

1. **保护数据一致性：** 防止并发事务引发数据不一致问题。
2. **提升性能：** 通过适当的隔离级别，减少锁竞争，提升并发处理能力。
3. **灵活性：** 根据实际需求，权衡一致性和性能，选择适合的隔离级别。

如果需要更详细的实践代码或案例分析，欢迎进一步提问！

## 执行一条 select 语句，期间发生了什么？



## “**脏读**”、“**不可重复读**” 和 “**幻读**？

在数据库事务管理中，“**脏读**”、“**不可重复读**” 和 “**幻读**” 是与事务隔离性相关的三种典型问题。它们主要出现在多事务并发操作时，了解它们对于选择合适的隔离级别（Isolation Level）非常重要。以下是详细的解释：

------

### **1. 脏读 (Dirty Read)**

**定义：**
 一个事务能够读取到另一个事务尚未提交的数据。如果后者事务回滚，那么前者读取到的就是无效或“脏”的数据。

#### **示例：**

1. 事务A更新了一行数据，但尚未提交。
2. 事务B读取了这行未提交的数据。
3. 事务A回滚了更改，事务B此时读取的数据是无效的。

#### **代码示例：**

```sql
-- 假设有一张表 account(balance INT)，初始余额为 100。
-- 事务A
START TRANSACTION;
UPDATE account SET balance = balance - 50 WHERE id = 1; -- 将余额减少50

-- 事务B
START TRANSACTION;
SELECT balance FROM account WHERE id = 1; -- 事务B读取到未提交的新余额（可能为50）

-- 事务A
ROLLBACK; -- 事务A回滚更改

-- 事务B读取到的余额（50）是脏数据，因为实际上余额应该还是100。
```

#### **避免方法：**

选择隔离级别 **`READ COMMITTED`** 或更高。

------

### **2. 不可重复读 (Non-Repeatable Read)**

**定义：**
 一个事务在两次读取同一数据时，数据值因另一个事务的提交而发生变化，导致读取的结果不一致。

#### **示例：**

1. 事务A读取了某行数据。
2. 事务B更新了该行数据并提交。
3. 事务A再次读取同一行数据，发现内容已被修改。

#### **代码示例：**

```sql
-- 假设表 account(balance INT)，初始余额为 100。
-- 事务A
START TRANSACTION;
SELECT balance FROM account WHERE id = 1; -- 第一次读取，余额为100

-- 事务B
START TRANSACTION;
UPDATE account SET balance = balance + 50 WHERE id = 1; -- 更新余额为150
COMMIT; -- 提交更改

-- 事务A
SELECT balance FROM account WHERE id = 1; -- 第二次读取，余额变为150
-- 两次读取结果不同，不可重复读问题。
```

#### **避免方法：**

选择隔离级别 **`REPEATABLE READ`** 或更高。

------

### **3. 幻读 (Phantom Read)**

**定义：**
 一个事务两次查询某范围的数据时，因另一个事务插入了新的数据而导致结果集不一致。

#### **示例：**

1. 事务A查询满足某条件的记录集。
2. 事务B插入了一条新记录并提交。
3. 事务A再次查询相同条件，发现多了一条记录。

#### **代码示例：**

```sql
-- 假设表 account(balance INT)，初始有两条记录 (id=1, id=2)。
-- 事务A
START TRANSACTION;
SELECT * FROM account WHERE balance > 50; -- 查询余额大于50的记录，结果可能是两条

-- 事务B
START TRANSACTION;
INSERT INTO account (id, balance) VALUES (3, 60); -- 插入新记录
COMMIT; -- 提交更改

-- 事务A
SELECT * FROM account WHERE balance > 50; -- 再次查询，结果多了一条记录(id=3)
-- 事务A发现多出了数据，即为幻读。
```

#### **避免方法：**

选择隔离级别 **`SERIALIZABLE`**。

------

### **总结：不同问题与隔离级别的关系**

| 隔离级别             | 脏读 | 不可重复读 | 幻读 |
| -------------------- | ---- | ---------- | ---- |
| **READ UNCOMMITTED** | 可能 | 可能       | 可能 |
| **READ COMMITTED**   | 禁止 | 可能       | 可能 |
| **REPEATABLE READ**  | 禁止 | 禁止       | 可能 |
| **SERIALIZABLE**     | 禁止 | 禁止       | 禁止 |

------

### **实用建议**

1. **选择隔离级别**：
   - 如果读一致性要求较高且性能可接受，优先使用 **`REPEATABLE READ`**。
   - 如果完全避免并发问题且不关心性能，则选择 **`SERIALIZABLE`**。
2. **MySQL默认隔离级别：**
    MySQL 的默认隔离级别是 **`REPEATABLE READ`**，它避免了脏读和不可重复读问题，但可能存在幻读。
3. **测试环境中复现问题：**
    利用事务模拟上述三种问题，能加深对隔离级别的理解。

------

如果需要进一步的实践题或代码演练，欢迎继续提问！

## Mysql中如何存储NULL

在 MySQL 中，**NULL 值**的存储方式取决于表的存储引擎（如 InnoDB 或 MyISAM）以及列的定义情况。NULL 值表示字段没有值或未知，与数字 0、空字符串 `''` 并不相同。

以下是 MySQL 中 NULL 值的存储和处理方式的详细说明：

------

### **1. NULL 值在存储上的实现**

#### **1.1. InnoDB 存储引擎**

- **NULL 值在记录中的存储：**

  - 在 InnoDB 中，每一行记录有一个额外的 **位图（bitmap）**，用来标识列是否为 NULL。
  - 如果某列允许为 NULL，那么在该列的位图中会为它分配一位，用来存储“是否为 NULL”的状态：
    - **1：表示该列为 NULL**。
    - **0：表示该列非 NULL**。
  - NULL 值本身不会占用额外的存储空间（即该列的实际值未被存储）。

- **存储示例：**

  - 如果表定义为：

    ```sql
    CREATE TABLE example (
        id INT NOT NULL,
        name VARCHAR(50),
        age INT NULL
    );
    ```

    - `name` 列可以为 NULL。
    - `age` 列可以为 NULL，InnoDB 会为 `age` 列分配 1 位来表示是否为 NULL。

------

#### **1.2. MyISAM 存储引擎**

- 在 MyISAM 中，NULL 值的存储方式类似 InnoDB：
  - 使用额外的位来标识列是否为 NULL。
  - 如果一个表包含多个允许为 NULL 的列，MyISAM 会用一个 NULL 标志字节来存储这些列的 NULL 状态，每列对应一位。
- **存储效率：**
  - NULL 值本身不会占用实际存储空间，只会影响 NULL 标志位。

------

### **2. NULL 值与索引**

- **索引中存储 NULL 值的处理：**
  - InnoDB 引擎：
    - NULL 值可以存储在索引中。
    - 对于单列索引，NULL 值会被索引，且多次出现的 NULL 值会被视为相同的键值。
  - MyISAM 引擎：
    - NULL 值也会被索引，但处理方式与非 NULL 值类似。
- **主键和唯一索引：**
  - 主键列（`PRIMARY KEY`）**不允许为 NULL**，因为主键要求每一行记录唯一标识。
  - 唯一索引（`UNIQUE INDEX`）允许列为 NULL，并且多个 NULL 值被视为不同（SQL 标准的规定）。

------

### **3. NULL 值的处理逻辑**

#### **3.1. 比较操作**

NULL 值的比较与常规值不同，不能直接用 `=` 或 `!=` 判断。需要用 **`IS NULL`** 或 **`IS NOT NULL`** 判断是否为 NULL：

```sql
-- 查找某列值为 NULL 的记录：
SELECT * FROM example WHERE age IS NULL;

-- 查找某列值非 NULL 的记录：
SELECT * FROM example WHERE age IS NOT NULL;
```

#### **3.2. NULL 值的参与计算**

任何值与 NULL 进行算术或逻辑运算，结果都会是 NULL。例如：

```sql
SELECT 10 + NULL; -- 结果为 NULL
SELECT 'abc' || NULL; -- 结果为 NULL
```

#### **3.3. 聚合函数与 NULL**

聚合函数会自动忽略 NULL 值。例如：

```sql
SELECT AVG(age) FROM example; -- NULL 值不会参与平均值计算
SELECT COUNT(age) FROM example; -- COUNT 只统计非 NULL 值
```

------

### **4. NULL 对性能的影响**

- **存储效率：**

  - NULL 值不会占用实际的列存储空间，但会增加 NULL 标志位，通常不会显著影响存储效率。

- **查询效率：**

  - 查询 NULL 值时，通常无法利用索引，可能导致全表扫描。例如：

    ```sql
    SELECT * FROM example WHERE age IS NULL;
    ```

------

### **5. 特殊场景：NOT NULL 和 DEFAULT 的关系**

- 如果某列定义为 `NOT NULL` 且没有指定默认值（`DEFAULT`），那么插入时必须显式提供一个值，否则会报错。
- 如果某列定义为允许 NULL，则可以插入 `NULL` 值或不指定该列，默认值为 `NULL`。

------

### **6. NULL 值的常见问题与解决**

#### **6.1. 主键不支持 NULL**

```sql
CREATE TABLE example (
    id INT PRIMARY KEY, -- 主键不允许为 NULL
    name VARCHAR(50) NULL
);
```

解决方法：使用其他列作为主键，或设置非 NULL 的替代值。

#### **6.2. NULL 与默认值**

如果某列既允许 NULL，又设置了默认值，默认值仅在插入未提供该列值时生效。插入显式 NULL 时，列值为 NULL。

#### **6.3. 查询中的 NULL**

对于多条件查询，要注意 NULL 的特殊处理。例如：

```sql
SELECT * FROM example WHERE age = 30 OR age IS NULL;
-- 需要显式加入 IS NULL 条件
```

------

### **总结**

1. **存储：** NULL 值以额外的标志位存储，不占用实际的列存储空间。1表示null，占用一个bitmap也就是1字节来标识
2. **索引：** NULL 值会被索引，但主键列不允许为 NULL。
3. **比较：** 需要用 `IS NULL` 或 `IS NOT NULL` 判断 NULL 值。
4. **聚合：** 聚合函数自动忽略 NULL 值。

如果你有更具体的场景需求，欢迎继续提问！



## varchar(n) 中 n 最大取值为多少？

![image-20241126145754668](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126145754668.png)

### 单字段

![image-20241126145818613](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126145818613.png)

![image-20241126145831926](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126145831926.png)

### 如果需要更大的字段怎么办

![image-20241126150912928](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126150912928.png)

### **5. 综合总结**

1. **理论上：** `VARCHAR(n)` 的 `n` 最大值是 65535，但受限于字符集和存储引擎的行大小限制。

> utf-8 3字节 ASCII1字节

1. 常用范围：
   - `latin1` 字符集：`VARCHAR(65535)`。
   - `utf8mb4` 字符集：实际 `n` 最大值约为 16383。
2. 优化建议：
   - 根据实际需要选择合适的字符集和字段长度。
   - 超长文本可以考虑使用 `TEXT` 类型。

同时null也会占用一个bitmap





## Mysqls索引

- 详细参考链接

`https://javaguide.cn/database/mysql/mysql-index.html`



## 有哪几类索引

### 回答重点

索引可以根据不同维度进行分类，常见分类方法如下：

1. **根据功能分类**：
   - **主键索引**：强制唯一性约束，用于主键字段。
   - **唯一索引**：限制字段值唯一性，可包含空值。
   - **普通索引**：无约束，仅提升查询性能。
   - **复合索引**：包含多个字段的索引，用于多条件优化。
2. **根据数据结构分类**：
   - **B-Tree 索引**：大多数数据库的默认索引类型，支持范围查询和排序。
   - **Hash 索引**：基于 Hash 表，适合精确匹配。
   - **R-Tree 索引**：用于多维数据查询（如地理坐标）。
   - **全文索引（倒排索引）**：为文本字段设计，支持关键词搜索。
3. **根据使用场景分类**：
   - **单字段索引**：优化单个字段的查询。
   - **多字段索引（复合索引）**：优化多个字段组合的查询。
   - **覆盖索引**：索引字段包含查询中所有需要的字段，避免回表。
   - **唯一约束索引**：同时保证字段唯一性和查询效率。
4. **根据存储方式分类**：
   - **聚簇索引（Clustered Index）**：数据存储顺序与索引顺序一致，每张表只能有一个。
   - **非聚簇索引（Non-Clustered Index）**：索引存储与数据分离，可有多个非聚簇索引。
   - **物化索引（Materialized Index）**：预计算并存储查询结果的索引。
5. **根据生命周期分类**：
   - **永久索引**：手动创建并长期存在。
   - **临时索引**：数据库在查询优化时自动生成，生命周期仅限于查询。

------

### 详细解析

#### **1. 功能分类**

| **索引类型** | **描述**                       | **适用场景**                             |
| ------------ | ------------------------------ | ---------------------------------------- |
| 主键索引     | 确保主键唯一，自动生成         | 表的主键字段，如 ID。                    |
| 唯一索引     | 确保字段值唯一，允许 `NULL` 值 | 如邮箱、用户名字段。                     |
| 普通索引     | 无唯一性约束，用于提升查询性能 | 经常作为查询条件的普通字段。             |
| 复合索引     | 基于多个字段的索引             | 多条件组合查询优化，如 `WHERE A AND B`。 |

------

#### **2. 数据结构分类**

| **数据结构** | **特点**                             | **适用场景**                         |
| ------------ | ------------------------------------ | ------------------------------------ |
| B-Tree       | 默认索引结构，支持范围查询和排序     | 大多数查询场景，如范围查询、排序等。 |
| Hash         | 精确匹配查询速度快，不支持范围查询   | 需要高效键值查找的场景。             |
| R-Tree       | 支持多维数据（如地理坐标）的范围查找 | GIS 数据存储和查询。                 |
| 倒排索引     | 将关键词映射到文档，适合全文检索     | 文本搜索，如商品描述、文章内容等。   |

------

#### **3. 使用场景分类**

| **索引类型** | **描述**                           | **适用场景**                                      |
| ------------ | ---------------------------------- | ------------------------------------------------- |
| 单字段索引   | 优化单个字段的查询                 | 针对单一条件查询优化，如 `WHERE name = 'Alice'`。 |
| 复合索引     | 基于多字段，按最左前缀顺序优化查询 | 多条件联合查询，如 `WHERE A = x AND B = y`。      |
| 覆盖索引     | 包含查询中所有字段，避免回表       | 查询字段与索引完全重合的场景。                    |
| 唯一约束索引 | 同时确保字段唯一性与性能           | 唯一性和查询优化，如用户名或邮箱。                |

------

#### **4. 存储方式分类**

| **索引类型** | **描述**                               | **适用场景**                                 |
| ------------ | -------------------------------------- | -------------------------------------------- |
| 聚簇索引     | 数据按索引排序存储，主键字段上自动创建 | 表的主键索引，适合经常排序、范围查询的字段。 |
| 非聚簇索引   | 索引存储与数据分离，可有多个非聚簇索引 | 非主键字段的优化，如 `name` 或 `email`。     |
| 物化索引     | 预计算并存储查询结果                   | 大量复杂查询结果重复的场景。                 |

------

### 知识扩展

#### **聚簇索引 vs 非聚簇索引**

1. 聚簇索引：
   - 数据物理顺序与索引顺序一致，主键索引为聚簇索引。
   - 每张表仅有一个聚簇索引。
   - 优点：查询快，特别是范围查询。
   - 缺点：插入新记录可能导致数据页重新排序。
2. 非聚簇索引：
   - 索引和数据独立存储，可有多个非聚簇索引。
   - 优点：灵活，可用于多个字段。
   - 缺点：查询需要回表增加开销。

#### **B-Tree vs Hash**

1. B-Tree 索引：
   - 支持范围查询（如 `<`、`>`）。
   - 适合排序和范围条件。
2. Hash 索引：
   - 查询复杂度 O(1)，但不支持排序和范围条件。
   - 适合等值查询。

------

### 总结

索引分类方式多样化，具体选择要结合业务需求。功能、数据结构和存储方式分类是最常用的角度。合理使用索引可以有效提升查询性能，同时避免索引过多导致写入开销增加。

------

## 什么是索引下推

### 回答重点

**索引下推**（Index Condition Pushdown, ICP）是 MySQL 5.6 引入的一种优化技术，用于减少回表次数，提升查询效率。

在传统的索引查询中，如果有索引覆盖了部分查询条件，查询会通过索引找到匹配的记录指针，然后回表检查剩余的条件是否满足。而索引下推技术允许 MySQL 在**存储引擎层**直接使用部分查询条件过滤数据，减少需要回表的记录数。

------

### 详细解析

#### **1. 索引下推的工作原理**

![image-20241213222557566](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213222557566.png)

- **传统索引查询（无索引下推）**：
   查询条件在 MySQL **服务器层**处理，存储引擎只通过索引查找到记录的主键值或行位置。对于每条候选记录，存储引擎都要回表读取完整记录，返回给服务器层，再由服务器层判断是否符合其他查询条件。
- **索引下推**：
   一部分查询条件（与索引相关的条件）被下推到**存储引擎层**，存储引擎可以在索引中直接过滤数据，只有满足条件的记录才会回表。

#### **2. 索引下推的适用场景**

索引下推主要在以下场景中生效：

1. 复合索引

   ：

   - 查询条件中包含多个字段，但不全是最左前缀的字段。

2. 范围查询

   ：

   - 某些条件需要回表进一步判断，例如 `LIKE` 或范围过滤。

#### **3. 示例说明**

假设有如下表和索引：

```sql
CREATE TABLE employees (
    id INT NOT NULL,
    name VARCHAR(100),
    age INT,
    department VARCHAR(50),
    PRIMARY KEY (id),
    KEY idx_name_age (name, age)
);
```

**查询：**

```sql
SELECT * FROM employees WHERE name LIKE 'A%' AND age > 30;
```

- **无索引下推**：
  1. 使用索引 `idx_name_age` 找到 `name LIKE 'A%'` 的匹配记录。
  2. 对每条匹配记录进行回表操作，读取完整记录。
  3. 回表后，再由服务器层判断 `age > 30` 是否满足。
- **索引下推**：
  1. 存储引擎先在 `idx_name_age` 中找到 `name LIKE 'A%'` 的匹配记录。
  2. 同时直接在存储引擎中判断 `age > 30`，仅保留符合条件的记录。
  3. 只对符合两个条件的记录回表读取完整数据。

------

### 知识扩展

#### **索引下推的优点**

1. 减少回表次数

   ：

   - 存储引擎过滤掉不必要的记录，降低磁盘 I/O 开销。

2. 提升查询性能

   ：

   - 减少服务器层的计算压力。

#### **索引下推的限制**

1. 条件必须与索引相关

   ：

   - 只有能通过索引访问的字段条件才可以下推。

2. 不支持非索引字段的条件

   ：

   - 例如 `WHERE name LIKE 'A%' AND department = 'HR'`，`department` 的条件不会被下推。

------

### 索引下推的执行过程示意图

```plaintext
传统方式（无索引下推）：
索引匹配 → 回表所有候选记录 → 服务器层过滤剩余条件

索引下推：
索引匹配 → 存储引擎层过滤部分条件 → 回表符合条件的记录 → 服务器层完成剩余条件过滤
```

------

### 总结

![image-20241213222635662](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213222635662.png)

## 防止索引失效

![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b70720b0cb422fb2583fb80a745e99~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![image-20241213224322902](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213224322902.png)

![image-20241213224350318](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213224350318.png)

## B树与B+树的区别

*参考视频地址*：https://www.bilibili.com/video/BV1zE421F7TA?t=151.2

![image-20250120141331829](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250120141331829.png)

# Java集合

## Java 中的 HashSet 和 HashMap 有什么区别

![image-20241127144114391](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127144114391.png)

在 Java 中，`HashSet` 和 `HashMap` 都是基于哈希表的集合类，但它们的用途和底层实现有所不同。以下从理论角度详细解析两者的区别，重点在底层逻辑和使用场景。

------

### **1. 核心区别总结**

1. **用途**：
   - **`HashSet`**：用于存储 **唯一元素**，保证无重复。
   - **`HashMap`**：用于存储 **键值对**（Key-Value），通过键快速查找值。
2. **底层实现**：
   - **`HashSet`**：基于 `HashMap` 实现，内部使用 `HashMap` 存储元素。
   - **`HashMap`**：基于数组 + 链表 + 红黑树实现，是更底层的实现结构。
3. **存储结构**：
   - **`HashSet`**：将元素存储为 `HashMap` 的键（`Key`），值（`Value`）为固定的常量对象（`PRESENT`）。
   - **`HashMap`**：存储键和值，每个键值对是一个 `Node<K, V>`。
4. **唯一性**：
   - **`HashSet`**：元素的唯一性通过 `hashCode` 和 `equals` 保证。
   - **`HashMap`**：键的唯一性通过 `hashCode` 和 `equals` 保证，但值可以重复。

------

### **2. 理论深度解析**

#### **2.1 为什么 HashSet 基于 HashMap 实现？**

- `HashSet` 的主要功能是存储唯一元素，而 `HashMap` 的键（`Key`）本身就是唯一的。
- 利用 `HashMap` 的键存储元素，可以复用 `HashMap` 的底层哈希表、冲突处理（链表/红黑树）、扩容机制等复杂逻辑，从而简化 `HashSet` 的实现。

#### **2.2 HashSet 的底层结构**

- `HashSet` 使用 `HashMap` 存储元素，所有存储在 `HashSet` 的元素都作为 `HashMap` 的键（`Key`），对应的值（`Value`）是一个固定的常量对象（`PRESENT`）。

- 示例（内部实现逻辑）：

  ```java
  private static final Object PRESENT = new Object();
  private transient HashMap<E, Object> map;
  
  public boolean add(E e) {
      return map.put(e, PRESENT) == null;
  }
  ```

#### **2.3 HashMap 的底层结构**

- `HashMap` 使用 **数组 + 链表 + 红黑树** 存储键值对。
  - 数组：用来快速定位存储桶（Bucket）。
  - 链表：解决哈希冲突（多个键映射到同一个桶时）。
  - 红黑树：当冲突链表长度超过阈值（默认 8）时，将链表转换为红黑树，提高查找效率。
- 关键点：
  - 键（Key）的唯一性通过 `hashCode` 和 `equals` 保证。
  - 值（Value）可以重复。

------

### **3. 使用场景分析**

#### **3.1 HashSet**

- **去重**：用于存储唯一元素，例如去除重复的集合数据。

- **快速查找**：可以高效判断集合中是否存在某个元素。

- 示例：

  ```java
  HashSet<String> set = new HashSet<>();
  set.add("A");
  set.add("B");
  set.add("A"); // 无效，HashSet 保证唯一性
  ```

#### **3.2 HashMap**

- **存储键值对**：用于快速查找值，例如实现缓存。

- **统计计数**：可以通过键值对存储统计数据，例如单词频率计数。

- 示例：

  ```java
  HashMap<String, Integer> map = new HashMap<>();
  map.put("A", 1);
  map.put("B", 2);
  map.put("A", 3); // 键 "A" 的值被更新为 3
  ```

------

### **4. 关键区别总结**

| 特性           | **HashSet**         | **HashMap**                  |
| -------------- | ------------------- | ---------------------------- |
| **用途**       | 存储唯一元素        | 存储键值对                   |
| **底层实现**   | 基于 `HashMap` 实现 | 基于数组 + 链表 + 红黑树实现 |
| **存储内容**   | 仅存储键（Key）     | 存储键（Key）和值（Value）   |
| **键的唯一性** | 元素唯一            | 键唯一，值可重复             |
| **线程安全性** | 否                  | 否                           |

------

### **5. 面试高频问题**

#### **5.1 为什么 HashSet 基于 HashMap 实现？**

- `HashSet` 只需要存储唯一元素，而 `HashMap` 的键（Key）已经是唯一的。
- 复用 `HashMap` 的哈希表结构，可以避免重新实现复杂的哈希算法和冲突处理逻辑。

#### **5.2 HashSet 和 HashMap 的性能如何？**

- 两者性能基本相同，因为 `HashSet` 内部依赖于 `HashMap`。
- 在插入、删除和查找操作中，时间复杂度通常为 **O(1)**（哈希冲突少的情况下）。

#### **5.3 HashSet 是否允许 null？HashMap 是否允许 null？**

- **HashSet**：允许存储一个 `null`。
- **HashMap**：允许一个 `null` 键和多个 `null` 值。

#### **5.4 HashSet 和 HashMap 的线程安全性如何？**

- 都是 **非线程安全** 的。
- 在多线程场景下，可以使用：
  - `HashSet`：通过 `Collections.synchronizedSet` 实现线程安全。
  - `HashMap`：推荐使用 `ConcurrentHashMap`。

------

### **6. 总结复习**

- **核心点**：
  - `HashSet` 是基于 `HashMap` 实现的，内部通过 `HashMap` 存储元素。
  - `HashMap` 是一个底层结构复杂、功能更强大的数据结构，支持键值对存储。
- **适用场景**：
  - 使用 `HashSet` 存储唯一值。
  - 使用 `HashMap` 实现键值对映射或数据统计。
- **面试关键词**：
  1. 底层结构：数组 + 链表 + 红黑树。
  2. 唯一性：通过 `hashCode` 和 `equals` 保证。
  3. 线程安全：默认非线程安全，需使用同步包装类或并发实现。

# Mybatis

## 在 MyBatis 中，#{} 和 ${} 的区别？

###   回答重点

在 MyBatis 中，`#{} 和 ${}` 的区别主要体现在以下几个方面：

1. **SQL 参数处理方式**：
   - `#{}：` 预编译方式，使用占位符 `?`，可以有效防止 SQL 注入。
   - `${}`：直接将变量的值拼接到 SQL 语句中，可能存在 SQL 注入风险。
2. **使用场景**：
   - `#{}：` 用于传递参数值（安全优先）。
   - `${}`：用于动态拼接 SQL 语句（如表名、列名等）。
3. **性能与安全**：
   - `#{}：` 由于参数绑定是在预编译时完成的，性能和安全性更高。
   - `${}`：直接拼接字符串，易被恶意注入攻击，不建议用于用户输入的值。

------

### 详细解析

#### 1. `#{} 的工作机制`

当使用 `#{} 时，MyBatis 会：

- 将 `#{}` 内的参数转换为 SQL 语句中的 `?`。
- 在执行时，通过 PreparedStatement 对参数进行绑定。

**示例**：

```xml
<select id="selectById" parameterType="int" resultType="User">
  SELECT * FROM user WHERE id = #{id}
</select>
```

生成的 SQL：

```sql
SELECT * FROM user WHERE id = ?
```

#### 2. `${}` 的工作机制

当使用 `${}` 时，MyBatis 会：

- 直接将参数值替换到 SQL 语句中。

**示例**：

```xml
<select id="selectByColumn" parameterType="map" resultType="User">
  SELECT * FROM user WHERE ${column} = #{value}
</select>
```

假如参数为 `column="username"` 和 `value="John"`，生成的 SQL：

```sql
SELECT * FROM user WHERE username = ?
```

#### 3. SQL 注入风险

由于 `${}` 会直接拼接到 SQL 中，如果参数来自用户输入而未做严格校验，可能会导致 SQL 注入攻击。例如：

```xml
<select id="deleteByCondition">
  DELETE FROM user WHERE ${condition}
</select>
```

传入 `condition="1=1; DROP TABLE user"` 时，生成的 SQL：

```sql
DELETE FROM user WHERE 1=1; DROP TABLE user
```

这是非常危险的。

#### 4. 动态 SQL 的应用场景

对于动态 SQL，例如动态拼接表名或列名，必须使用 `${}`，因为 `#{} 不支持表名或列名的动态替换。例如：

```xml
<select id="selectDynamicTable" resultType="User">
  SELECT * FROM ${tableName} WHERE id = #{id}
</select>
```

此时的mapper的写法

```java
  /**
     * 查询动态表的数据
     * @param tableName 表名
     * @param id 主键 ID
     * @return 查询结果（可以是对象，也可以是 Map，根据需要定义返回值类型）
     */
    Map<String, Object> selectDynamicTable(@Param("tableName") String tableName, @Param("id") Long id);
}
```



------

### 知识扩展

#### 1. 安全性对比

| 特性         | `#{} (安全)` | `${} (不安全)`    |
| ------------ | ------------ | ----------------- |
| 预编译       | 是           | 否                |
| SQL 注入风险 | 无           | 高                |
| 使用场景     | 传递参数值   | 动态拼接表名/列名 |

#### 2. 优化建议

1. **优先使用 `#{}`**，避免 SQL 注入风险。
2. **动态 SQL 场景校验输入**：当必须使用 `${}` 时，务必对用户输入进行严格校验，避免拼接恶意数据。
3. **使用框架提供的工具**：如 MyBatis 动态 SQL 标签 `<if>、<choose>` 等，替代直接拼接。

#### 3. 动态 SQL 标签示例

```xml
<select id="findUserByCondition" parameterType="map" resultType="User">
  SELECT * FROM user
  <where>
    <if test="name != null"> AND name = #{name}</if>
    <if test="age != null"> AND age = #{age}</if>
  </where>
</select>
```

------

### 总结

1. `#{}` 和 `${}` 区别：
   - `#{}` 安全，预编译，传递参数值。
   - `${}` 灵活，直接拼接，存在风险。
2. **建议优先使用 `#{}`，仅在必要时使用 `${}`。**

# JUC

![img](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/java-concurrent-overview-1.png)

## 什么是协程？和进程的区别？java中支持协程吗

![image-20250109140053377](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109140053377.png)

### 协程的特点

- **轻量级**：减少了线程创建和销毁的开销，避免了内核态和用户态之间切换的时间成本
- **非抢占式调度**
- **异步化编排**

![image-20250109140139540](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109140139540.png)

### 和线程的区别

![image-20250109140321588](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109140321588.png)

## java中如何创建多线程

## 进程的几种状态

**新建、就绪、运行、阻塞、终止**

![image-20250109142500914](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142500914.png)

## 并发三要素

- 原子性 ：**进程的切换导致了原子性的问题**
- 可见性：**CPU存在缓存导致了引出可见性的问题**
- 有序性

![image-20250109142840594](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142840594.png)

![image-20250109142915097](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142915097.png)

![image-20250109142932419](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142932419.png)

**有序性**，jvm会优化指令的执行顺序

![image-20250109143356270](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109143356270.png)

# 设计模式

## 什么是设计模式？

- 设计模式是一种通用的代码编程手段，合适的场景用上合适的设计模式，**可以增强代码的灵活性、可维护性、还有可扩展性**

**结构型**：解决类与类之间搭建更大的积木产生的崩塌问题

## 设计模式分为哪三类

关键词：创建、结构、行为

![image-20250114163004851](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114163004851.png)

## 什么是策略模式？

![image-20250114162446726](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114162446726.png)

策略模式（Strategy Pattern）是一种行为型设计模式，用于定义一系列算法，将它们封装起来，并使它们可以互相替换，从而使算法的变化不会影响到使用算法的客户代码。

### 回答重点

1. **核心概念**：策略模式通过将算法封装到独立的类中，使得可以在运行时动态地选择合适的算法。
2. **参与角色**：
   - **抽象策略（Strategy）**：定义算法的接口。
   - **具体策略（ConcreteStrategy）**：实现算法的不同版本。
   - **上下文（Context）**：使用策略的环境，维护对策略对象的引用，并负责与策略的交互。
3. **应用场景**：
   - 系统需要动态地在多个算法之间切换。
   - 各种算法的逻辑是独立的，并且可能经常变化。
   - 需要避免在类中使用多个条件语句来选择算法。

------

### 详细解析

**示例代码**（以折扣计算为例）：
 假设一个电商系统根据不同用户类型（普通用户、会员用户、VIP用户）提供不同的折扣策略。

```java
// 抽象策略
public interface DiscountStrategy {
    double calculateDiscount(double amount);
}

// 具体策略
public class NoDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculateDiscount(double amount) {
        return amount;
    }
}

public class MemberDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculateDiscount(double amount) {
        return amount * 0.9;
    }
}

public class VIPDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculateDiscount(double amount) {
        return amount * 0.8;
    }
}

// 上下文
public class ShoppingCart {
    private DiscountStrategy discountStrategy;

    public ShoppingCart(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    public double calculateFinalAmount(double amount) {
        return discountStrategy.calculateDiscount(amount);
    }

    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
}

// 测试
public class StrategyPatternDemo {
    public static void main(String[] args) {
        //指定上下文
        ShoppingCart cart = new ShoppingCart(new NoDiscountStrategy());
        System.out.println("Final Amount: " + cart.calculateFinalAmount(100));
		
        //指定上下文为会员用户
        cart.setDiscountStrategy(new MemberDiscountStrategy());
        System.out.println("Final Amount: " + cart.calculateFinalAmount(100));
		
        //指定上下问使用VIP用户的策略
        cart.setDiscountStrategy(new VIPDiscountStrategy());
        System.out.println("Final Amount: " + cart.calculateFinalAmount(100));
    }
}
```

**运行结果**：

```
Final Amount: 100.0
Final Amount: 90.0
Final Amount: 80.0
```

------

### 知识扩展

1. **优点**：
   - **开闭原则**：增加新策略时无需修改上下文代码。
   - **代码清晰**：避免了冗长的条件语句。
   - **提高灵活性**：可以在运行时动态更改策略。
2. **缺点**：
   - 策略类数量可能过多，导致代码复杂度增加。
   - 客户端需要了解不同策略的行为。
3. **实际应用**：
   - 支付方式选择（支付宝、微信、银行卡等）。
   - 排序算法切换（快速排序、归并排序等）。
   - 日志策略（控制台日志、文件日志等）。

------

### 总结

![image-20250114162613592](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114162613592.png)

策略模式通过将算法或行为封装到独立的类中，提供了灵活、可扩展的解决方案，适合需要动态切换或增加算法的场景。然而，在使用策略模式时需要注意策略类的数量增长可能带来的复杂性。

------

### 相关面试题

1. **为什么策略模式比条件语句更优雅？**
2. **在策略模式中如何避免策略类过多的问题？**
3. **策略模式和工厂模式的区别和联系是什么？**
4. **在Java中，策略模式如何与Lambda表达式结合使用？**

## 什么是单例模式？

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

![image-20250114164137625](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114164137625.png)

### 单例模式的优缺点

![image-20250114164315335](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114164315335.png)

### 解决多线程模式下的单例重复创建

在多线程环境下实现单例模式时，需要确保单例实例的创建过程是线程安全的。下面是一个基于 **双重检查锁定（Double-Checked Locking）** 的线程安全单例模式示例，这是常见的高效实现方式。

#### 双重检查锁定的单例模式示例

```java
public class Singleton {
    // 使用 volatile 关键字确保变量的可见性和禁止指令重排序
    private static volatile Singleton instance;

    // 私有构造函数，防止外部实例化
    private Singleton() {
        System.out.println("单例实例被创建");
    }

    // 提供全局访问点
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    // 测试方法
    public void doSomething() {
        System.out.println("单例方法执行");
    }
}

// 测试类
public class SingletonTest {
    public static void main(String[] args) {
        // 启动多个线程同时获取单例实例
        Runnable task = () -> {
            Singleton singleton = Singleton.getInstance();
            singleton.doSomething();
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);
        Thread thread3 = new Thread(task);

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

#### 代码说明

1. **`volatile` 关键字**
    确保 `instance` 在多线程环境中可见，同时禁止指令重排序，避免初始化过程中未完成就被读取的问题。
2. **双重检查锁定**
   - 第一次检查：避免无意义的同步，提升性能。
   - 第二次检查：确保在 `synchronized` 块内也不会重复创建实例，保证线程安全。
3. **`synchronized` 块**
    只在实例未创建时进入同步块，确保性能损耗最小化。
4. **线程安全测试**
    在测试类中通过多个线程并发调用 `getInstance`，验证单例模式的线程安全性。

#### 输出示例（可能略有不同，取决于线程调度）：

```
单例实例被创建
单例方法执行
单例方法执行
单例方法执行
```

#### 优点

1. **线程安全**：使用 `synchronized` 和 `volatile` 确保线程安全。
2. **高效**：双重检查锁定避免每次获取实例时的同步操作，性能更优。
3. **懒加载**：只有在首次调用 `getInstance` 时才会创建实例，节省资源。

#### 缺点

1. 实现稍微复杂，需要理解 `volatile` 和指令重排序问题。
2. 如果系统对性能要求极高，可以考虑其他方式，如静态内部类实现单例。

#### 静态内部类实现单例的替代方式（更简单的线程安全实现）

```java
public class Singleton {
    // 静态内部类
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // 私有构造函数
    private Singleton() {
        System.out.println("单例实例被创建");
    }

    // 提供全局访问点
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

这种方式基于类加载机制，线程安全且简单，无需显式同步。








# 实习问点

## 树优

**适配器相关**

```java
package com.soyotec.unixde.prm.core.service.adapter;

import com.soyotec.unixde.prm.common.enums.ProjectTypeEnum;
import com.soyotec.unixde.prm.common.vo.ProjectTaskExtensionBaseVO;
import com.soyotec.unixde.prm.core.service.NpmProjectTaskExtensionService;
import com.soyotec.unixde.uap.framework.exception.UnixdeException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.util.*;

/**
 * @author edward
 * @description
 * @date 2025/3/31
 */

@Slf4j
@Service
@RequiredArgsConstructor
public class NpmProjectTaskExtensionServiceAdapter {

    /** bean 前缀 */
    public static final String PREFIX = "taskExtension";

    /** 带扩展表的项目种类列表 */
    private final List<String> extensions = new ArrayList<>(
            Arrays.asList(ProjectTypeEnum.KSM.code(), ProjectTypeEnum.HUB.code())
    );

    private final Map<String, NpmProjectTaskExtensionService<?>> map;

    /**
     * 获取指定服务实例
     *
     * @param beanName 服务名称
     * @return 服务实例
     * @author edward
     */
    @SuppressWarnings("unchecked")
    public NpmProjectTaskExtensionService<ProjectTaskExtensionBaseVO> getService(@NotNull String beanName) {
        if (StringUtils.isEmpty(beanName)) {
            throw new UnixdeException("service key is null.");
        } else if (MapUtils.isEmpty(map) || Objects.isNull(map.get(beanName))) {
            log.warn("no available bean for this service, beanName={}", beanName);
            return null;
        }
        return (NpmProjectTaskExtensionService<ProjectTaskExtensionBaseVO>) map.get(beanName);
    }

    /**
     * 根据项目类型适配服务
     *
     * @param projectTypeCode 项目类型代码
     * @return 适配的服务实例
     * @author edward
     */
    public NpmProjectTaskExtensionService<ProjectTaskExtensionBaseVO> adaptService(String projectTypeCode) {
        if (StringUtils.isEmpty(projectTypeCode) || !extensions.contains(projectTypeCode)) {
            return null;
        }
        return getService(PREFIX + projectTypeCode);
    }
}
```

部分代码：二级缓存

```java
package com.soyotec.unixde.uap.sysconfig.service.impl;

import com.alibaba.fastjson2.JSON;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.soyotec.unixde.uap.framework.base.PageVO;
import com.soyotec.unixde.uap.framework.exception.UnixdeException;
import com.soyotec.unixde.uap.sysconfig.domain.DTypeEntity;
import com.soyotec.unixde.uap.sysconfig.dao.DTypeMapper;
import com.soyotec.unixde.uap.framework.base.BaseServiceImpl;
import com.soyotec.unixde.uap.sysconfig.service.DTypeService;
import com.soyotec.unixde.uap.sysconfig.util.RedisStoreUtils;
import com.soyotec.unixde.uap.sysconfig.vo.DocumentTypeVO;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
* <p>
*  服务实现类
* </p>
*
* @author edward
* @since 2025-03-05
*/
@Service
public class DTypeServiceImpl extends BaseServiceImpl<DTypeMapper, DTypeEntity> implements DTypeService {
    @Autowired
    private DTypeMapper documentTypeMapper;

    @Autowired
    private RedisStoreUtils redisStoreUtils;

    @Autowired
    private Environment environment;

    public static final Map<String,DocumentTypeVO> documentTypeMap=new ConcurrentHashMap<>();
    public static final Map<String,DocumentTypeVO> documentCodeMap=new ConcurrentHashMap<>();

    private static final String VUE_CACHE_DOC_TYPE_KEY = "VUE_CACHE_DOC_TYPE_KEY";




    @Override
    public Map<String,DocumentTypeVO> findAll() {
        if (documentTypeMap.size()==0){
            List<DTypeEntity> types = documentTypeMapper.selectList(null);
            if (!types.isEmpty()){
                for (DTypeEntity type:types){
                    DocumentTypeVO documentTypeVO=new DocumentTypeVO();
                    BeanUtils.copyProperties(type,documentTypeVO);
                    documentTypeMap.put(type.getId(),documentTypeVO);
                }
            }
        }
        return documentTypeMap;
    }

    @Override
    public void findPage(PageVO<DocumentTypeVO> pageVO) {
        DocumentTypeVO condition = JSON.parseObject(pageVO.getContent(), DocumentTypeVO.class);
        // 构建查询条件
        QueryWrapper<DTypeEntity> queryWrapper = new QueryWrapper<>();
        if (condition != null) {
            if (StringUtils.hasText(condition.getStatus())) {
                queryWrapper.eq("status", condition.getStatus());
            }
            if (StringUtils.hasText(condition.getName())) {
                queryWrapper.like("name", condition.getName());
            }
            if (StringUtils.hasText(condition.getCode())) {
                queryWrapper.eq("code", condition.getCode());
            }
        }
        queryWrapper.orderByDesc("modify_time");
        Page<DTypeEntity> page = new Page<>(pageVO.getPageNo(), pageVO.getPageSize());
        page = documentTypeMapper.selectPage(page, queryWrapper);
        // 转换结果
        List<DocumentTypeVO> result = page.getRecords().stream().map(type -> {
            DocumentTypeVO typeVO = new DocumentTypeVO();
            BeanUtils.copyProperties(type, typeVO);
            return typeVO;
        }).collect(Collectors.toList());
        // 设置返回结果
        pageVO.setResult(result);
        pageVO.setTotal(page.getTotal());
    }

    /**
     * 更新接口
     * @param documentTypeVO
     * @param tenantId
     */
    @Override
    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRES_NEW)
    public void update(DocumentTypeVO documentTypeVO, String tenantId) {
        QueryWrapper<DTypeEntity> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("code",documentTypeVO.getCode())
                .ne("id",documentTypeVO.getId());
        Long count = documentTypeMapper.selectCount(queryWrapper);
        if(count > 0){
            throw new UnixdeException("编码重复,请重新输入");
        }
        // 查询现有记录
        QueryWrapper<DTypeEntity> idWrapper = new QueryWrapper<>();
        idWrapper.eq("id", documentTypeVO.getId());
        List<DTypeEntity> documentTypeList = documentTypeMapper.selectList(idWrapper);
        if (documentTypeList == null || documentTypeList.isEmpty()) {
            throw new UnixdeException("找不到该类型");
        }
        String oldCode = documentTypeList.get(0).getCode();
        DTypeEntity documentType = new DTypeEntity();
        BeanUtils.copyProperties(documentTypeVO, documentType);
        documentType.setUpdateTenantId(tenantId);
        documentTypeMapper.updateById(documentType);
        // 更新后的对象复制回 VO
        BeanUtils.copyProperties(documentType, documentTypeVO);
        // 更新内存缓存
        documentTypeMap.put(documentType.getId(), documentTypeVO);
        if (!ObjectUtils.equals(oldCode, documentType.getCode())) {
            documentCodeMap.remove(oldCode);
        }
        documentCodeMap.put(documentType.getCode(), documentTypeVO);
        // 设置修改标记
        setModifyMark();
    }

    /**
     * 删除接口
     * @param id
     */
    @Override
    public void delete(String id) {
        QueryWrapper<DTypeEntity> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("id", id);
        //TODO确认原逻辑为什么这里是拿去一个list 不理解
        List<DTypeEntity> type = documentTypeMapper.selectList(queryWrapper);
        if(type!=null&& !type.isEmpty()){
            documentTypeMap.remove(type.get(0).getId());
            documentCodeMap.remove(type.get(0).getCode());
        }
        baseMapper.deleteById(id);
        setModifyMark();
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void add(DocumentTypeVO documentTypeVO, String userId) {
        // 检查 code 是否重复
        QueryWrapper<DTypeEntity> codeWrapper = new QueryWrapper<>();
        codeWrapper.eq("code", documentTypeVO.getCode());
        Long count = documentTypeMapper.selectCount(codeWrapper);
        if (count > 0) {
            throw new UnixdeException("code不能重复");
        }
        // 创建新记录
        DTypeEntity documentType = new DTypeEntity();
        BeanUtils.copyProperties(documentTypeVO, documentType);
        documentType.setCreator(userId);
        documentType.setTenantId("0");
        documentTypeMapper.insert(documentType);
        BeanUtils.copyProperties(documentType, documentTypeVO);
        // 更新内存缓存
        documentTypeMap.put(documentType.getId(), documentTypeVO);
        documentCodeMap.put(documentType.getCode(), documentTypeVO);
        // 设置修改标记
        setModifyMark();
    }

    /**
     * 查询所有状态为有效的文档类型列表
     * @author edward
     * @return 文档类型视图对象列表
     */
    public List<DocumentTypeVO> find() {
        // 获取数据源 URL，用于适配不同数据库
        String url = environment.getProperty("spring.datasource.url", "");
        if (StringUtils.isEmpty(url)) {
            log.warn("数据源URL未配置");
            return new ArrayList<>(); // 返回空列表
        }
        // 构建查询条件
        List<DTypeEntity> types;
        if (url.startsWith("jdbc:dm") || url.startsWith("jdbc:postgresql")) {
            types = queryTypesForDM(); // 适配 DM 或 PostgreSQL
        } else {
            types = queryTypesForDefault(); // 适配其他数据库（如 MySQL）
        }
        // 转换实体为 VO 对象
        List<DocumentTypeVO> typeVOS = new ArrayList<>();
        for (DTypeEntity type : types) {
            DocumentTypeVO typeVO = new DocumentTypeVO();
            BeanUtils.copyProperties(type, typeVO);
            typeVOS.add(typeVO);
        }
        return typeVOS;
    }

    /**
     * 查询状态为 '1' 的文档类型（适配 DM 或 PostgreSQL）
     * @author edward
     * @return 文档类型实体列表
     */
    private List<DTypeEntity> queryTypesForDM() {
        return documentTypeMapper.selectList(
                new QueryWrapper<DTypeEntity>()
                        .eq("status", "1")
                        .orderByAsc("cast(sequence as NUMERIC)")
        );
    }
    /**
     * 查询状态为 1 的文档类型（适配默认数据库，如 MySQL）
     * @author edward
     * @return 文档类型实体列表
     */
    private List<DTypeEntity> queryTypesForDefault() {
        return documentTypeMapper.selectList(
                new QueryWrapper<DTypeEntity>()
                        .eq("status", 1)
                        .orderByAsc("cast(sequence as SIGNED)")
        );
    }

    private void setModifyMark() {
        try {
            redisStoreUtils.putHashValue(RedisStoreUtils.VUE_CACHE_HASH_KEY, VUE_CACHE_DOC_TYPE_KEY, String.valueOf(System.currentTimeMillis()));
        } catch (Exception e) {
            log.error("DocumentTypeServiceImpl setModifyMark: ", e);
        }
    }
}
```

### 简历点：

这块先进行简单的描述，后续给出更加具体的业务描述以及相关代码

- ConcurrentHashMap+redis乐观锁实现的内存缓存，前端携带缓存key查看是否变化
- @Lazy注解完成懒加载，解决缓存依赖的问题
- 设计模式，功能存在不同数据库，使用策略模式解决问题
- @UtilityClass，工具类注解，使得工具类不可被实例化

![image-20250326104705573](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250326104705573.png)

**出现了循环依赖**

```
@Lazy //解决循环依赖
@Resource
private NpmProjectTaskService npmProjectTaskService;
```

- 适配器模式+服务中心模式

bg：根据不同的项目模式调用不同的服务中心，服务中心通过转换对接不同的适配

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ProjectTaskExtensionServiceAdapter {

    /** bean前缀 */
    public static final String PREFIX = "taskExtension";

    /** 带扩展表的项目种类列表 */
    private final List<String> extensions = new ArrayList<>(
            Arrays.asList(ProjectTypeEnum.KSM.code(),ProjectTypeEnum.HUB.code())
    );

    private final Map<String, ProjectTaskExtensionService<?>> map;

    @SuppressWarnings("unchecked")
    public ProjectTaskExtensionService<ProjectTaskExtensionBaseVO> getService(@NotNull String beanName) {
        if (StringUtils.isEmpty(beanName)) {
            throw new SkrException("service key is null.");
        } else if (MapUtils.isEmpty(map) || Objects.isNull(map.get(beanName))) {
            log.warn("no available bean for this service, beanName={}", beanName);
            return null;
        }
        return (ProjectTaskExtensionService<ProjectTaskExtensionBaseVO>) map.get(beanName);
    }

    public ProjectTaskExtensionService<ProjectTaskExtensionBaseVO> adaptService(String projectTypeCode) {
        if (StringUtils.isEmpty(projectTypeCode) || !extensions.contains(projectTypeCode)) {
            return null;
        }
        return getService(PREFIX + projectTypeCode);
    }
}

```



```java
/**
 * 任务扩展表接口，根据项目种类适配。
 * @param <T> 扩展表VO
 */
public interface ProjectTaskExtensionService<T extends ProjectTaskExtensionBaseVO> {

    T getExtensionByTaskId(String taskId, SkrUserDetails userDetails);

    List<T> getExtensionListByTaskId(List<String> taskIdList, SkrUserDetails userDetails);

    T create(T entity, SkrUserDetails userDetails);

    T create(String entityJson, SkrUserDetails userDetails);

    T update(T entity, SkrUserDetails userDetails);

    T update(String entityJson, SkrUserDetails userDetails);

    void deleteByTaskId(String taskId, SkrUserDetails userDetails);
}
```

## 用友

### **JWT + Token 认证及缓存优化整理**

------

#### **1️⃣ JWT（JSON Web Token）身份认证**

##### **✅ 什么是 JWT？**

- **JWT（JSON Web Token）** 是一种 **无状态认证** 机制，服务器**不存储 Token**，而是通过 Token 本身来进行身份验证。
- 适用于 **单点登录（SSO）、API 认证、微服务鉴权** 等场景。

##### **✅ 为什么使用 JWT？**

| 方案             | 服务器是否存 Token         | 适用场景                          |
| ---------------- | -------------------------- | --------------------------------- |
| **Session 认证** | ✅ 需要存 Session           | 传统 Web 应用，适用于单机         |
| **JWT 认证**     | ❌ 无状态，服务器不存 Token | 适用于微服务、跨系统认证          |
| **JWT + Redis**  | ✅ 服务器存 Token           | 适用于需要 Token 可主动失效的场景 |

- **传统 Session 认证**：需要在服务器存储用户 Session，分布式环境下需要共享 Session，成本高。
- **JWT 认证**：Token 存储在客户端，服务器只需验证 Token 是否有效，不需要存储 Session。
- **JWT + Redis 缓存**：服务器可主动让 Token 失效，增强安全性。

------

#### **2️⃣ JWT 结构**

JWT 由 **三部分** 组成：

```
Header.Payload.Signature
```

示例：

```json
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjMiLCJleHAiOjE3MDAyNTgwMDB9.XiJJcZp9dFZhXHnx_FTBlahkPT6pXtsfDtw4CD13EXE
```

##### **✅ 解析 JWT 三部分**

| 部分                  | 作用                                                |
| --------------------- | --------------------------------------------------- |
| **Header（头部）**    | 说明 JWT 类型 + 签名算法（如 HS256）                |
| **Payload（载荷）**   | 记录用户信息（如 `userId`、`role`、`exp` 过期时间） |
| **Signature（签名）** | 服务器签名，防止 Token 被篡改                       |

------

#### **3️⃣ JWT 认证流程**

##### **✅ 认证流程**

1. **用户登录**，服务器验证身份后生成 **JWT Token** 并返回给客户端。

2. **客户端存储 Token**（如 `localStorage` / `cookie`）。

3. 客户端每次请求时，携带 Token

   ：

   ```http
   Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
   ```

4. **服务器解析 Token**，验证 Token 是否有效，返回数据。

5. **Token 过期后，用户需要重新登录**。

##### **✅ 服务器如何验证 Token？**

```java
import io.jsonwebtoken.*;

public class JWTUtil {
    private static final String SECRET_KEY = "your-secret-key";

    public Claims parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();  // 解析 Token，获取 Claims
    }

    public boolean validateToken(String token) {
        try {
            return parseToken(token) != null;
        } catch (Exception e) {
            return false;  // Token 无效或过期
        }
    }
}
```

------

#### **4️⃣ JWT + Redis 结合优化**

##### **✅ 为什么要结合 Redis？**

纯 JWT **无法主动失效**，如果用户登出或权限变更，旧 Token 仍然有效。结合 Redis 可以：

1. **主动让 Token 失效**（登出、密码修改、权限变更）。
2. **黑名单机制**，防止 Token 被盗用。
3. **减少 JWT 解析计算量**，提高 API 认证效率。

------

##### **✅ JWT + Redis 方案**

**1️⃣ 用户登录时，将 Token 存入 Redis**

```java
redisTemplate.opsForValue().set("token:" + userId, token, 1, TimeUnit.DAYS);
```

**2️⃣ 解析 Token 时，先查询 Redis**

```java
public boolean validateToken(String token, String userId) {
    String cachedToken = redisTemplate.opsForValue().get("token:" + userId);
    return cachedToken != null && cachedToken.equals(token) && parseToken(token) != null;
}
```

**3️⃣ 用户登出时，让 Token 立即失效**

```java
@GetMapping("/logout")
public String logout(@RequestParam String userId) {
    redisTemplate.delete("token:" + userId);
    return "用户已登出，Token 失效";
}
```

------

#### **5️⃣ JWT + 刷新 Token（Refresh Token 机制）**

**🚀 目标：让用户长时间免登录，提升安全性**

| Token 类型              | 作用                     |
| ----------------------- | ------------------------ |
| **短 Token（30 分钟）** | 访问 API，短时间有效     |
| **刷新 Token（7 天）**  | 续期 Token，防止频繁登录 |

##### **✅ 方案**

1. **短 Token**（30 分钟），用于 API 访问。

2. 刷新 Token

   （7 天），用于获取新 Token：

   ```http
   POST /auth/refresh
   Authorization: Bearer <refresh_token>
   ```

3. 服务器验证刷新 Token 后，返回新 Token

   ：

   ```json
   {
     "access_token": "new_access_token",
     "refresh_token": "new_refresh_token"
   }
   ```

------

#### **✅ 代码实现**

**1️⃣ 生成短 Token + 刷新 Token**

```java
public Map<String, String> generateTokens(String userId) {
    String accessToken = Jwts.builder()
            .setSubject(userId)
            .setExpiration(new Date(System.currentTimeMillis() + 1800000)) // 30 分钟
            .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
            .compact();

    String refreshToken = Jwts.builder()
            .setSubject(userId)
            .setExpiration(new Date(System.currentTimeMillis() + 604800000)) // 7 天
            .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
            .compact();

    return Map.of("access_token", accessToken, "refresh_token", refreshToken);
}
```

**2️⃣ 处理刷新 Token**

```java
@PostMapping("/refresh")
public ResponseEntity<?> refresh(@RequestParam String refreshToken) {
    try {
        Claims claims = jwtUtil.parseToken(refreshToken);
        String userId = claims.getSubject();
        Map<String, String> newTokens = generateTokens(userId);
        return ResponseEntity.ok(newTokens);
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("无效的刷新 Token");
    }
}
```





# HOT100

## 滑动窗口

### 无重复最长字符串字串



#### 2. 核心思路

要找到不含重复字符的最长子串，我们可以使用 **滑动窗口** 技术，动态维护一个无重复字符的子串窗口。

##### 2.1 滑动窗口的核心思想

- 使用两个指针 l（左边界）和 r（右边界）表示当前窗口。
- 向右扩展窗口（移动 r），将新字符加入窗口。
- 如果遇到重复字符，收缩窗口（移动 l），直到窗口内没有重复字符。
- 在每次窗口更新后，记录当前窗口长度（r - l + 1），维护最大长度。

##### 2.2 实现细节

- 数据结构：使用 HashSet 或 HashMap 记录窗口内字符的出现情况：
  - HashSet：记录字符是否出现。
  - HashMap：记录字符及其最新索引，便于快速定位重复字符。
- 步骤：
  1. 初始化窗口：l = 0，r = 0，最大长度 nums = 0。
  2. 遍历字符串（r右移）：
     - 检查当前字符 s.charAt(r) 是否在窗口内：
       - 如果不在，加入窗口，更新最大长度。
       - 如果在，移动 l 到重复字符的下一个位置，移除窗口内的重复字符。
  3. 返回最大长度。

```java
public int lengthOfLongestSubstring(String s) {
        int nums = 0; // 记录最大长度
        int r = 0;    // 右指针
        int l = 0;    // 左指针
        // 使用 HashSet 记录窗口内字符
        Set<Character> set = new HashSet<>();
        
        while (r < s.length()) {
            // 如果当前字符不在窗口内
            if (!set.contains(s.charAt(r))) {
                set.add(s.charAt(r));
                nums = Math.max(nums, r - l + 1); // 更新最大长度
            } else {
                // 遇到重复字符，移除左边界字符，直到重复字符被移除
                while (set.contains(s.charAt(r))) {
                    set.remove(s.charAt(l));
                    l++;
                }
                set.add(s.charAt(r)); // 加入新字符
            }
            r++; // 右指针右移
        }
        
        return nums;
    }
```



## 查找

### 二分查找

#### [搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**核心：**

- mid的计算 **l + (r - l) / 2**，通过计算左边界与相对偏移来得出mid的位置
- 最后插入的地方是左边界，l指向的是比target大的第一个数

 

code

```java
public int searchInsert(int[] nums, int target) {
        int l = 0;
        int r = nums.length - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2; // 每次循环重新计算 mid 通过计算偏移量的方式
            if (nums[mid] == target) {
                return mid; // 找到目标值，直接返回
            } else if (nums[mid] < target) {
                l = mid + 1; // 目标值在右半部分
            } else {
                r = mid - 1; // 目标值在左半部分
            }
        }

        return l; // l 指向插入位置
    }
```



## 二叉树

### 理论基础

- 深度：叶子节点到根节点的距离
- 高度：节点到叶子节点的距离

### 1.二叉树的最大深度

- 递归版实现-----**1.确定返回类型和参数，2.确定边界条件，3.确定单层递归的逻辑**

```java
 public int maxDepth(TreeNode root) {
     	
        if(root == null) return 0;
        int leftHeight = maxDepth(root.left);
        int rightHeight = maxDepth(root.right);
        int depth = Math.max(leftHeight,rightHeight) + 1;
        return depth;
    }
```

### 2.判断二叉树是否对称

#### 核心思路

- 递归法

**判断左子树的左节点和右子树的右节点  以及 左子树的右节点和右子树的左节点是否相同**

代码：

```java
 public boolean isSymmetric(TreeNode root) {
        // 如果树是空的，肯定是对称的
        if (root == null) {
            return true;
        }
        // 从根节点的左右子树开始检查
        return checkMirror(root.left, root.right);
    }
    private boolean checkMirror(TreeNode left, TreeNode right){
        //处理两个都为null
        if(left == null && right == null){
            return true;
        }
        //左右有一个为null代表不对称
        if(left == null || right == null){
            return false;
        }
        //都有值且值相等
        if(left.val == right.val){
            return checkMirror(left.left,right.right) && checkMirror(left.right,right.left);
        }else{
            return false;
        }
    }
```



## 矩阵

### 1.螺旋矩阵

#### 1. 描述

给定一个 m x n 的矩阵 matrix，按照 **顺时针螺旋顺序** 返回矩阵中的所有元素。

**示例**：

- 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
- 输出：[1,2,3,6,9,8,7,4,5]
- 解释：按照顺时针螺旋顺序遍历。

**约束**：

- m == matrix.length
- n == matrix[0].length
- 1 <= m, n <= 10
- -100 <= matrix[i][j] <= 100

#### 核心思路：

- 首先需要模拟正常情况遍历顺序

使用 **边界模拟法**：

1. 定义四个边界：top（上）、bottom（下）、left（左）、right（右）。
2. 按照顺时针方向遍历：
   - 从左到右（top 行）。
   - 从上到下（right 列）。
   - 从右到左（bottom 行）。
   - 从下到上（left 列）。
3. 每次遍历后更新边界，重复直到所有元素被访问。

#### 2.1 详细步骤

- 初始边界：top = 0, bottom = m-1, left = 0, right = n-1。
- 遍历顺序：
  1. 从 left 到 right，遍历 top 行，top++。
  2. 从 top 到 bottom，遍历 right 列，right--。
  3. 从 right 到 left，遍历 bottom 行，bottom--。
  4. 从 bottom 到 top，遍历 left 列，left++。
- 循环条件：top <= bottom 且 left <= right。

**注意：在while循环内由于top会先++,所以之后的每个遍历都需要先判断一下是否越界！**

#### code

```java
public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> retList = new ArrayList<>();
        //定义四个边界
        int top = 0;
        int right = matrix[0].length - 1;
        int bottom = matrix.length - 1;
        int left = 0;

        //循环遍历所有元素
        while(top <= bottom && right >= left){
            //遍历top
            for(int i = left;i <= right; i++){
                retList.add(matrix[top][i]);
            }
            top++;
            //后续遍历之前先检查一下是否已经越界！
            if(top <= bottom){
                //遍历right
                for(int i = top; i <= bottom; i++){
                    retList.add(matrix[i][right]);
                }
                right--;
            }
            if(bottom >= top){
                //遍历bottom
                for(int i = right; i >= left; i--){
                    retList.add(matrix[bottom][i]);
                }
                bottom--;
            }

            if(left <= right){
                //遍历left
                for(int i = bottom; i >= top; i--){
                    retList.add(matrix[i][left]);
                }
                left++;
            }

        }
        return retList;
    }
```



## 链表

### 1.环形链表

#### 描述

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 核心思路

`使用快慢指针`,**如果快指针追上满指针**，就证明有环的存在

- 步长定义：快指针一次走两步，慢指针一次走一步，相对运动速度为1，肯定会相遇

#### Code

```java
//快慢指针
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        //快指针一次走两个，这样保证快慢相遇
        ListNode fast = head;
        ListNode slow = head;

        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) return true;
        }
        return false;
    }
```

### 2. 环形链表 II（LeetCode 142）

#### 描述

给你一个链表的头节点 head，返回链表中环的入口节点。如果链表中没有环，则返回 null。
 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：pos 不作为参数进行传递**，仅用于标识链表的实际情况。
 如果链表中存在环，则返回环的入口节点；否则，返回 null。

**示例**：

- 输入：head = [3,2,0,-4], pos = 1
- 输出：2（返回值为节点 2）
- 解释：链表中有一个环，其尾部连接到第二个节点（索引 1 的节点 2），环的入口是 2。

**约束**：

- 链表中节点的数目范围在 [0, 10^4] 之间。
- -10^5 <= Node.val <= 10^5。
- pos 的值为 -1 或者链表中的一个有效索引。

#### 核心思路

使用 **快慢指针法**（Floyd 判圈算法）来检测环并找到入口：

1. 检测环

   - 慢指针（slow）：每次移动 1 步。
   - 快指针（fast）：每次移动 2 步。
   - 如果快慢指针相遇，说明有环；否则，返回 null。

2. 找到环的入口

   **第一次相遇点不一定是入口，但第二次相遇点一定是入口。**

   - 相遇后，将慢指针移回链表头节点，快指针保持在相遇点。
   - 然后，慢指针和快指针都以相同速度（每次 1 步）移动。
   - 两者再次相遇时，相遇点即为环的入口。

3. 数学原理

   - 设：
     - a：从链表头到环入口的距离。
     - c：环的长度。
     - b：慢指针在环内走了多远才与快指针相遇。
   - 慢指针相遇时走了 a + b 步，快指针走了 2(a + b) 步，且快指针可能在环内多转了 k 圈：
      2(a + b) = a + b + k * c
      化简：a = k * c - b。
   - 这表明，从链表头到入口的距离 a，等于从相遇点沿环走 k 圈再减去 b 的距离。
   - 因此，慢指针从头走 a 步到达入口时，快指针从相遇点走 a 步（a = k * c - b），正好绕环 k 圈回到入口，两者会在入口相遇。

#### 代码实现

```java
public ListNode detectCycle(ListNode head) {
    // 边界检查：空链表或单节点无环
    if (head == null || head.next == null) {
        return null;
    }
    
    // 步骤1：快慢指针检测环
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            // 步骤2：从头和相遇点同步移动，寻找环入口
            ListNode ptr1 = head;
            ListNode ptr2 = fast;
            while (ptr1 != ptr2) {
                ptr1 = ptr1.next;
                ptr2 = ptr2.next;
            }
            return ptr1; // 循环结束后返回环入口
        }
    }
    
    // 无环，返回 null
    return null;
}
```

#### 复杂度分析

- 时间复杂度O(n)
  - n 是链表节点数。
  - 检测环阶段：快慢指针在 O(n) 时间内相遇。
  - 找入口阶段：从头到入口的距离为 a，最多 O(n) 步。
- 空间复杂度O(1)
  - 只使用常数级额外空间（几个指针）。

#### 注意事项

- 边界条件
  - 空链表或单节点无环，直接返回 null。
  - 环可能在链表头（如 [1,2]、pos=0）。
- 快指针移动
  - 必须检查 fast.next != null，避免空指针异常。
- 相遇点
  - **第一次相遇点不一定是入口，但第二次相遇点一定是入口。**



## 双指针

### 1.移动零

**描述**：给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**核心思想：**

- 使用双指针 left和 right
  - left：指向下一个非 0 元素应该放置的位置。
  - right：遍历数组，寻找非 0 元素。
- 将非 0 元素移动到 left 位置，left 前进。
- 最后将 left 之后的元素置为 0。

**步骤：**

1. 初始化 left = 0，right = 0。

2. right

    遍历数组：

   - 如果 nums[right] != 0，将 nums[right] 赋值给 nums[left]，left++。
   - right 继续向前移动。

3. 遍历结束后，从 left 到数组末尾补 0。

CODE

```java
class Solution {
    public void moveZeroes(int[] nums) {
       if(nums.length == 0 || nums.length == 1){
        return;
       } 
       int left = 0;
       for(int right = 0; right < nums.length; right++){
        //右指针找到非零元素
          if(nums[right] != 0){
            if(right != left){
                nums[left] = nums[right];
                left++;
            }else{
                left++;
            }
          }
       }
       //补0
       while(left <= nums.length - 1){
            nums[left] = 0;
            left++;
       }
    }
}
```



### 2.盛水最多的容器

#### 1. 题目描述

- **问题：** 给定一个整数数组 height，数组中的每个元素表示一个垂直线的高度，垂直线的宽度为 1。找到两条垂直线，使得它们与 x 轴形成的容器能装最多的水。

- 规则：

  - 容器的面积 = 两线之间的距离 × 较短的垂直线的高度。
  - 距离 = 两线下标之差（绝对值）。
  - 高度 = 两线中较短者。

- **输入：** 整数数组 height。

- **输出：** 最大面积。

- 示例：

  - 输入：height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
  - 输出：49
  - 解释：用下标 1（高度 8）和下标 7（高度 7）的线，面积 = (7-1) * min(8, 7) = 6 * 7 = 42。但最佳组合可能是其他位置（如调整后计算），实际最大为 49。

  

  

  #### 核心思想：

  - 使用双指针从两端向中间移动，动态计算最大面积。
  - 面积由两个因素决定：宽度（r - l）和高度（较短的线的高度）。
  - 每次移动较短的线一端，因为：
    - 如果移动较高的线，面积不会增加（因为高度不会变大，宽度减小）。
    - 移动较低的线可能找到更高的线，从而增加面积。

  **步骤：**

  1. 初始化 left = 0（左指针），right = height.length - 1（右指针）。

  2. 计算初始面积：area = (right - left) * min(height[left], height[right])。

  3. 循环直到 

     left >= right

     ：

     - 比较 height[left] 和 height[right]。
     - 如果 height[left] < height[right]，移动 left++（尝试找更高的左线）。
     - 否则，移动 right--（尝试找更高的右线）。
     - 计算新面积，更新最大值。

  4. 返回最大面积。

  #### 代码

  ```java
  /**
   * 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
   * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
   * 返回容器可以储存的最大水量。
   * 说明：你不能倾斜容器。
   * @author edward
   * @date 2025/3/19
   */
  
  public class ContainerMostWater {
      public static void main(String[] args) {
          // 创建一个ContainerMostWater对象
          ContainerMostWater containerMostWater = new ContainerMostWater();
          // 定义一个数组，存储容器的高度
          int[] height = {1,8,6,2,5,4,8,3,7};
          // 输出容器中水的最大面积
          System.out.println(containerMostWater.maxArea(height));
      }
      public int maxArea(int[] height) {
          // 定义右指针
          int r = height.length - 1;
          // 定义左指针
          int l = 0;
          int high = height[r] > height[l] ? height[l] : height[r];//取比较短的高度
          int res = (r - l) * high;
  
          while(l < r){
              if(height[l] < height[r]){
                  l++;
              }else{
                  r--;
              }
              int tempRes = (r - l) * (height[r] > height[l] ? height[l] : height[r]);
              // 更新最大面积
              if(tempRes > res){
                  res = tempRes;
              }
          }
          return res;
      }
  }
  ```

  
  
  ### LeetCode 15. 三数之和 解题笔记
  
  #### 1. 描述
  给定整数数组 `nums`，找出所有满足 `nums[i] + nums[j] + nums[k] == 0` 且 `i != j != k` 的三元组，答案不可重复。
  
  **示例**：  
  - 输入：`nums = [-1,0,1,2,-1,-4]`  
  - 输出：`[[-1,-1,2],[-1,0,1]]`
  
  **约束**：  
  - `0 <= nums.length <= 3000`  
  - `-10^5 <= nums[i] <= 10^5`
  
  ---
  
  #### 2. 核心思路
  使用 **排序 + 双指针**：  
  1. 排序数组：`O(n log n)`。  
  2. 固定 `nums[i]`，用双指针 `left` 和 `right` 找 `nums[left] + nums[right] = -nums[i]`。  
  3. 去重：跳过重复的 `nums[i]`、`nums[left]` 和 `nums[right]`。  
  4. 提前终止：若 `nums[i] > 0`，退出。
  
  ---
  
  ### 3. 代码实现
  ```java
  class Solution {
      public List<List<Integer>> threeSum(int[] nums) {
          List<List<Integer>> ret = new ArrayList<>();
          int n = nums.length;
          if (n < 3) return ret; // 边界检查
          
          Arrays.sort(nums); // 排序
          if (nums[0] > 0) return ret; // 提前终止
          
          for (int i = 0; i < n - 2; i++) {
              if (i > 0 && nums[i] == nums[i - 1]) continue; // 去重 nums[i]
              
              int left = i + 1, right = n - 1;
              while (right > left) {
                  int sum = nums[i] + nums[left] + nums[right];
                  if (sum == 0) {
                      ret.add(Arrays.asList(nums[i], nums[left], nums[right]));
                      while (right > left && nums[left] == nums[left + 1]) left++; // 去重 nums[left]
                      while (right > left && nums[right] == nums[right - 1]) right--; // 去重 nums[right]
                      left++;
                      right--;
                  } else if (sum < 0) {
                      left++;
                  } else {
                      right--;
                  }
              }
          }
          return ret;
      }
  }
  ```
  
  ---
  
  #### 4. 复杂度分析
  - **时间复杂度**：`O(n^2)`  
    - 排序：`O(n log n)`  
    - 双指针：`O(n^2)`  
  - **空间复杂度**：`O(n)`（存储结果）
  
  ---
  
  #### 5. 注意事项
  - **去重**：通过比较相邻元素去重，避免使用 `List.contains()`（`O(n)` 效率低）。  
  - **边界**：检查 `n < 3` 和 `nums[0] > 0`。  
  - **循环范围**：`i < n - 2` 确保右侧有足够元素。
  
  #### 编码习惯问题与改进
  - **问题**：  
    - 使用 `List.contains()` 去重效率低，可能超时。  
    - 去重逻辑错误（如比较 `nums[i] == nums[left]`）。  
  - **改进**：  
    1. 去重用排序特性，跳过重复元素。  
    2. 确保边界检查完整，先检查长度再访问元素。  
  - **好处**：提高效率，降低复杂度。
  
  ---
  
  #### 6. 总结与学习建议
  - **总结**：排序 + 双指针是高效解法，注意去重和边界。  
  - **建议**：  
    1. 练习去重技巧：排序后跳过重复元素。  
    2. 避免低效操作：不用 `List.contains()`。  
    3. 扩展题目：**LeetCode 18. 四数之和**、**LeetCode 16. 最接近的三数之和**。

## 动态规划

### 最大子数组和（LeetCode 53）

#### 题目描述

给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

------

#### 示例

- 输入: `nums = [-2,1,-3,4,-1,2,1,-5,4]`
   输出: `6`
   解释: 子数组 `[4,-1,2,1]` 的和最大，为 6。
- 输入: `nums = [1]`
   输出: `1`
- 输入: `nums = [5,4,-1,7,8]`
   输出: `23`

------

#### 解题思路

##### 方法一：暴力解法

1. 遍历所有可能的子数组。
2. 计算每个子数组的和，并维护一个变量 `maxSum` 保存最大的子数组和。
3. 时间复杂度为 O(n^2)。

**暴力解法代码：**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = Integer.MIN_VALUE; // 初始最大值
        for (int i = 0; i < nums.length; i++) {
            int currentSum = 0;
            for (int j = i; j < nums.length; j++) {
                currentSum += nums[j]; // 累加子数组元素
                maxSum = Math.max(maxSum, currentSum); // 更新最大值
            }
        }
        return maxSum;
    }
}
```

------

##### 方法二：动态规划（Kadane's算法）

1. 定义状态：

   - `dp[i]` 表示以第 `i` 个元素结尾的最大子数组和。

2. 状态转移方程：

   - 如果将 `nums[i]` 与前面的子数组连接，结果比 `nums[i]` 大，则选择连接。

   - 否则以 `nums[i]` 开始新的子数组。

   - 转移方程为：

     ```java
     dp[i] = Math.max(dp[i-1] + nums[i], nums[i])
     ```

3. 初始状态：

   - `dp[0] = nums[0]`

4. 优化：动态规划只需记录当前状态和最大值，因此可以将空间复杂度优化为 O(1)。

**动态规划代码：**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = nums[0]; // 初始化最大值
        int currentSum = nums[0]; // 当前子数组和

        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(currentSum + nums[i], nums[i]); // 状态转移
            maxSum = Math.max(maxSum, currentSum); // 更新最大值
        }

        return maxSum;
    }
}
```

------

#### 比较分析

| 方法     | 时间复杂度 | 空间复杂度 | 优点                         | 缺点                   |
| -------- | ---------- | ---------- | ---------------------------- | ---------------------- |
| 暴力解法 | O(n^2)     | O(1)       | 逻辑简单，容易实现           | 时间复杂度较高，效率低 |
| 动态规划 | O(n)       | O(1)       | 时间复杂度低，适合大规模数据 | 需要理解状态转移方程   |

------

#### 笔记总结

1. **动态规划核心**：
    将问题分解为子问题，利用子问题的最优解来推导整个问题的最优解。
2. **Kadane's算法** 是动态规划的简化实现，优化了空间复杂度。
3. 推荐使用动态规划解法，尤其在输入规模较大的情况下，时间复杂度 O(n) 更高效

## 哈希表

### 1.两数字之和

- 直接暴力

复杂度O（n方）

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
}

```

- 哈希表

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++){
            int subSum = target - nums[i];
            if(map.containsKey(subSum)){
                return new int[]{map.get(subSum),i};
            }
            else map.put(nums[i],i);
        }
        return null;
    }
}

```

### 2.最长序列和(复杂度on)

#### 题目描述

​	给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4
```

#### 优化思路（使用 HashSet）

- 核心思想：

  - 将所有数字放入 HashSet，利用其 O(1) 的查找效率。
  - 只从每个可能的序列起点（即没有前驱的数字）开始扩展，这样避免重复计算。
  - 一个数字 num 如果是序列起点，说明 num - 1 不在集合中。

- 步骤：

  1. 将数组 nums 放入 HashSet。

  2. 遍历数组中的每个数字 

     num

     ：

     - 如果 num - 1 不在 HashSet 中，则以 num 为起点，扩展连续序列。
     - 从 num 开始，检查 num + 1, num + 2, ...，直到序列断开。
     - 记录当前序列长度，并更新最大长度。

  3. 返回最大长度。

- **时间复杂度：** O(n)（每个数字最多被访问一次）。

- **空间复杂度：** O(n)（存储 HashSet）。

#### 为什么是 O(n)？

- 每个数字最多被访问两次：一次作为起点，一次作为扩展中的元素。
- HashSet 的查找和添加操作是 O(1)。
- 总时间复杂度由数组长度 n 决定。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0) return 0;
        Set<Integer> set = new HashSet<>();
        for(int num : nums){
            set.add(num);
        }
        int max = 1;
        for(Integer num : set){
            int tempMax = 1;
            if(set.contains(num - 1)){
                continue;
            }
            //是起点
            while(set.contains(num + 1)){
                //向后扩展
                num = num + 1;
                tempMax++;
            }
            if(max < tempMax){
                max = tempMax;
            }
        }
        return max;
    }
}
```



### 3.[和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

**描述**： 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

 

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**核心思路**：前缀和+哈希表

**用当前前缀和  - k值，如果这个值存在在原有的哈希表中，那就存在子数组**

​	





 code

```java
 public int subarraySum(int[] nums, int k) {
        //用哈希表存储前缀和和出现的次数
        Map<Integer,Integer> preSum = new HashMap<>();
        //0默认在前缀和里面
        preSum.put(0,1);
        int sum = 0;
        int ret = 0;
        //存储前缀和
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            //如果存在sum-k的前缀和，则说明存在子数组
            if(preSum.containsKey(sum - k)){
                ret += preSum.get(sum - k);
            }
            //更新前缀和
            preSum.put(sum,preSum.getOrDefault(sum,0) + 1);
        }

        return ret;
    }
```



## 链表

### 删除倒是第n个节点

#### 1. 描述
给定一个链表，删除倒数第 `n` 个节点，并返回头节点。

**示例**：  
- 输入：`head = [1], n = 1`  
- 输出：`[]`  
- 解释：删除唯一节点后，链表为空。

**约束**：  
- 链表节点数为 `sz`，`1 <= sz <= 30`  
- `0 <= Node.val <= 100`  
- `1 <= n <= sz`

---

#### 2. 方法 1：计算长度法
##### 2.1 核心思路
1. 遍历链表，计算长度 `count`。  
2. 处理特殊情况：  
   - 如果 `count == 1`，返回 `null`。  
   - 如果 `n == count`，删除头节点，返回 `head.next`。  
3. 遍历到倒数第 `n+1` 个节点，删除其下一个节点。

##### 2.2 代码实现
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 计算链表长度
        int count = 0;
        ListNode countNode = head;
        while (countNode != null) {
            count++;
            countNode = countNode.next;
        }
        
        // 特殊情况：只有一个节点
        if (count == 1) {
            return null;
        }
        
        // 特殊情况：删除头节点
        if (n == count) {
            return head.next;
        }
        
        // 找到倒数第 n+1 个节点
        ListNode curNode = head;
        int tarIndex = 1;
        while (tarIndex < count - n) {
            curNode = curNode.next;
            tarIndex++;
        }
        // 删除倒数第 n 个节点
        curNode.next = curNode.next.next;
        
        return head;
    }
}
```

##### 2.3 复杂度分析
- **时间复杂度**：`O(n)`  
  - 第一次遍历：`O(n)`。  
  - 第二次遍历：`O(n)`。  
- **空间复杂度**：`O(1)`  
  - 只使用常数额外空间。

##### 2.4 优缺点
- **优点**：  
  - 逻辑直观，易于理解。  
  - 特殊情况处理清晰。  
- **缺点**：  
  - 需要两次遍历，实际操作次数较多。  
  - 命名不够直观（`countNode`、`tarIndex`）。  
  - 缺少防御性检查（如 `head == null`）。

---

#### 3. 方法 2：快慢指针法
##### 3.1 核心思路
1. 使用哑节点，统一处理删除头节点的情况。  
2. 快指针先走 `n` 步。  
3. 快慢指针一起走，直到快指针到达末尾，慢指针指向倒数第 `n+1` 个节点。  
4. 删除慢指针的下一个节点。

##### 3.2 代码实现
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 防御性检查
        if (head == null) return null;
        
        // 使用快慢指针
        ListNode dummy = new ListNode(0, head);
        ListNode fast = dummy;
        ListNode slow = dummy;
        
        // 快指针先走 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        
        // 快慢指针一起走
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        // 删除倒数第 n 个节点
        slow.next = slow.next.next;
        
        return dummy.next;
    }
}
```

##### 3.3 复杂度分析
- **时间复杂度**：`O(n)`  
  - 一次遍历：`O(n)`。  
- **空间复杂度**：`O(1)`  
  - 只使用常数额外空间。

##### 3.4 优缺点
- **优点**：  
  - 一次遍历，效率更高。  
  - 使用哑节点，统一处理特殊情况。  
  - 命名直观（`fast`、`slow`）。  
- **缺点**：  
  - 逻辑稍复杂，初学者可能不易理解。  
  - 需要额外哑节点（空间仍为 `O(1)`）。

---

#### 4. 方法对比
| **方面**         | **计算长度法**                      | **快慢指针法**         |
| ---------------- | ----------------------------------- | ---------------------- |
| **时间复杂度**   | `O(n)`（两次遍历）                  | `O(n)`（一次遍历）     |
| **实际效率**     | 较慢（操作次数接近 `2n`）           | 较快（操作次数为 `n`） |
| **空间复杂度**   | `O(1)`                              | `O(1)`                 |
| **代码可读性**   | 直观，适合初学者                    | 稍复杂，但逻辑更优雅   |
| **特殊情况处理** | 显式处理，分支较多                  | 使用哑节点，统一处理   |
| **命名**         | 不够直观（`countNode`、`tarIndex`） | 直观（`fast`、`slow`） |

---



### 相交链表

- 通过hash表，先把A链表的所有node存入set集合，然后再遍历B链表，如果b链表的某个node在集合中，就直接返回这个节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> nodeSet = new HashSet<>();
        ListNode visitA = headA;
        while(visitA != null){
            nodeSet.add(visitA);
            visitA = visitA.next;
        }
        visitA = headB;
        while(visitA != null){
            if(nodeSet.contains(visitA)) return visitA;
            else visitA = visitA.next;
        }
        return null;
    }
}
```



# 简历库

## 有用友实习参考

<img src="https://uploadfiles.nowcoder.com/message_images/20241025/850730041_1729829149938/discuss_1729829150082.jpeg?x-oss-process=image%2Fresize%2Cw_276%2Ch_276%2Cm_mfit%2Fformat%2Cpng" alt="img"  />

# 计网

## Http和Https的区别？他是如何解决加密问题的

- 除此之外，**性能上Https会消耗更多的服务器资源**

![image-20250109155510570](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109155510570.png)

### 如何解决加密



### 关键词

- **混合加密+摘要算法+数字签名+CA认证**

主要解决了三个问题：

- **信息加密**：防止传输过程的明文被窃取，使用**混合加密**（建立连接前非对称加密，建立连接之后对称加密）的方式。
- **校验机制**：使用**摘要算法（哈希函数）+数字签名**，为原始数据生成独一无二的指纹（code），检验前后的指纹是否一致，如果不一致的话就不展示，解决了**篡改风险**	
- **身份验证**：通过公钥来验证服务器身份。

**哈希函数**来保证加密的完整性，**数字签名来保证消息来源的可靠性**

![image-20250109161258652](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109161258652.png)

*还没有增加数字签名之前的流程*

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png)

### 数字签名算法

![image-20250109164021436](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109164021436.png)

加了数字签名之后

![image-20250109164132370](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109164132370.png)

### 数字证书

私钥加密，公钥解密的方式可以确定一组签名的可靠性，但是无法辨别**私钥的来源是否是想要来源**，就比如吧私钥和公钥一起篡改了，那这样识别是可以通过，但是却是冒牌的数据

![image-20250109164607956](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109164607956.png)

所以需要通过将私钥放入**CA**服务器进行认证，来认证一下发送的数据源是否是想要的

![image-20250109165001375](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109165001375.png)

## TCP

**文档**：[TCP小林Coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#)

### TCP和UDP的区别？

![TCP 头格式](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png)

![image-20250107173309905](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173309905.png)

![image-20250107172916015](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107172916015.png)

![image-20250107172938404](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107172938404.png)

![image-20250107173012445](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173012445.png)

![image-20250107173210993](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173210993.png)

- UDP的头部没有**首部长度**，因为UDP的首部长度是固定的
- TCP没有**包长度**，因为TCP的包长度可以使用一定的公式计算出来

![image-20250107173444882](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107173444882.png)

```
+-------------------------+-------------------------+
|         TCP             |         UDP             |
+-------------------------+-------------------------+
| 面向连接               | 无连接                 |
| 可靠性高               | 不保证可靠性           |
| 有序数据传输           | 数据可能乱序           |
| 速度较慢               | 速度较快               |
| 应用场景：文件传输等   | 应用场景：实时流媒体等 |
+-------------------------+-------------------------+
```



### TCP的三次握手

#### 回答重点

TCP 的三次握手是建立可靠连接的过程，用于确保通信双方准备就绪并交换必要信息。具体步骤如下：

1. **第一次握手**：
    客户端发送 `SYN` 报文，表示请求建立连接，并附上初始序列号（`ISN(client)`）。
   - 报文：`SYN=1, seq=ISN(client)`
   - 意图：告诉服务端自己准备好并请求通信。
2. **第二次握手**：
    服务端收到 `SYN` 后，回复 `SYN+ACK`，表示同意建立连接，并附上自己的初始序列号（`ISN(server)`）。
   - 报文：`SYN=1, ACK=ISN(client)+1, seq=ISN(server)`
   - 意图：告诉客户端自己也已准备好，并确认客户端的请求。
3. **第三次握手**：
    客户端收到 `SYN+ACK` 后，回复一个 `ACK` 报文，确认服务端的信息。
   - 报文：`ACK=ISN(server)+1, seq=ISN(client)+1`
   - 意图：告诉服务端连接已确认完成。

完成上述三次握手后，连接建立成功，双方可以开始数据传输。

------

#### 详细解析

##### 为什么需要三次握手？

- 确保通信双方准备就绪：
  - 第一次握手：客户端确认自己能发送，服务端能接收。
  - 第二次握手：服务端确认自己能发送，客户端能接收。
  - 第三次握手：客户端确认服务端的确认信息，双方同步通信状态。
- **防止历史连接误触：**
   旧的 SYN 请求可能被误处理，如果没有第三次握手确认，会导致服务端误以为建立了新的连接，浪费资源。

##### 示例状态变化

1. 客户端从 `CLOSED → SYN-SENT`。
2. 服务端从 `CLOSED → SYN-RECEIVED`，发送 `SYN+ACK`。
3. 客户端从 `SYN-SENT → ESTABLISHED`，发送 `ACK`。
4. 服务端从 `SYN-RECEIVED → ESTABLISHED`，完成连接。

------

#### 知识扩展

下图展示了三次握手的交互流程：

```
客户端                        服务端
  | ----SYN(seq=x)---->        |
  |                           |
  | <----SYN+ACK(seq=y, ack=x+1)-- |
  |                           |
  | ----ACK(ack=y+1)---->      |
  |                           |
```

- `SYN`：同步序列号，用于建立连接。
- `ACK`：确认序列号，确保报文接收无误。

------

#### 总结

TCP 的三次握手通过 `SYN` 和 `ACK` 报文协调双方状态，确保可靠连接的建立，同时防止历史连接干扰，是 TCP 协议可靠性的基础机制之一。

![image-20250107174809806](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250107174809806.png)

**前两次的握手是不携带数据的**

### 为什么是三次握手？不是两次、四次？

**回答的重点从TCP**为什么三次握手**才**可以**初始化 Socket、序列号和窗口大小并建立 TCP 连接**。入手

两次握手：![image-20250108144916879](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108144916879.png)

![image-20250108145018726](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108145018726.png)

![两次握手会造成资源浪费](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png)

四次握手：![image-20250108144957600](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108144957600.png)

#### 小结

![image-20250108144744417](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250108144744417.png)

## WebSocket和http

> websocket最主要的特征就是，服务器可以主动给客户端发送数据

### **1. HTTP vs WebSocket**

- **HTTP 协议特点**：
  - **半双工**：客户端发起请求，服务端响应，通信过程有明确的主从关系。
  - **请求/响应模型**：服务端无法主动推送数据给客户端。
  - **适用场景**：静态网页、普通接口调用等单次请求-响应的场景。
  
- **WebSocket 协议特点**：
  - **全双工**：基于 TCP，通信双方可随时主动发送数据。
  - **长连接**：只需一次握手，连接保持期间可多次发送数据，无需重复创建连接。
  - **适用场景**：需要频繁交互、服务端主动推送的场景，如实时聊天、网页游戏、协作办公。

- **为什么需要 WebSocket？**
  - HTTP 适用于静态内容交互，但在 **实时通信** 场景下效率低（如扫码登录、实时推送）。
  - WebSocket 补足了 HTTP 的不足，为实时性需求提供了高效解决方案。

---

### **2. WebSocket 连接建立过程**

1. **HTTP 升级机制**：
   - 浏览器发起 HTTP 请求时，带上以下 Header：
     - `Connection: Upgrade`
     - `Upgrade: websocket`
     - `Sec-WebSocket-Key`：随机 Base64 字符串，用于校验。
   - 服务器返回：
     - 状态码 `101 Switching Protocols` 表示协议切换。
     - `Sec-WebSocket-Accept`：根据客户端的 `Sec-WebSocket-Key` 计算得到，用于验证合法性。

2. **通信建立后**：
   - 双方通过 WebSocket 的数据格式通信，完全脱离 HTTP。

---

### **3. WebSocket 报文格式**
- **帧（Frame）结构**：
  - **FIN**：是否是消息的最后一帧。
  - **Opcode**：
    - `0x1`：文本数据（string）。
    - `0x2`：二进制数据（byte[]）。
    - `0x8`：关闭连接。
  - **Payload length**：数据长度（动态编码，可能是 7、7+16 或 7+64 bits）。
  - **Masking-key**：客户端向服务端发送数据时的掩码，用于数据加密。
  - **Payload data**：实际数据。

- **Payload 长度编码规则**：
  - 0-125：直接使用 7 bits 表示长度。
  - 126：额外使用 16 bits 表示长度。
  - 127：额外使用 64 bits 表示长度。

---

### **4. HTTP 长轮询（Long Polling）**
- **机制**：
  - 客户端发起请求，服务端不立即响应，而是保持连接直到有数据或超时。
  - 若超时无响应，客户端重新发起下一次请求。
- **优点**：
  - 减少重复请求的带宽浪费，提升用户体验。
- **缺点**：
  - 保持连接时间较长，占用服务端资源，非最佳实时通信方式。

---

### **5. 服务器推送技术**
- **伪推送：轮询**：
  - 客户端主动发起请求（短轮询、长轮询），看似服务端推送，实际是客户端请求。
- **真推送：WebSocket**：
  - 服务端主动将消息发送到客户端，无需等待客户端请求。

---

### **6. 使用场景**
1. **HTTP 定时轮询**：
   - 场景：扫码登录、简单状态检查。
   - 特点：实现简单，但不适合复杂实时需求。
2. **HTTP 长轮询**：
   - 场景：文件上传进度通知、即时通知。
   - 特点：减少轮询次数，但资源占用较大。
3. **WebSocket**：
   - 场景：实时游戏、在线聊天、协作工具（如飞书）。
   - 特点：高效、实时、适合频繁通信。

---

### **7. 总结对比**
| **特性**     | **HTTP**            | **WebSocket**          |
| ------------ | ------------------- | ---------------------- |
| **通信模式** | 半双工              | 全双工                 |
| **连接方式** | 短连接              | 长连接                 |
| **数据推送** | 客户端主动拉取      | 服务端可主动推送       |
| **适用场景** | 请求-响应式应用场景 | 实时性强的场景         |
| **协议建立** | 无需额外操作        | 需进行协议升级（HTTP） |

---

### **8. 示例：WebSocket 与 HTTP 抓包分析**
- WebSocket 建立连接前：
  - HTTP 请求带特殊头部 (`Upgrade: websocket`)。
- WebSocket 协议切换后：
  - 不再使用 HTTP 报文，而是直接基于 WebSocket 帧结构通信。

---

### **9. 延伸问题**
- **WebSocket 与 Socket 的关系**：
  - WebSocket 是基于 TCP 的应用层协议，解决了应用层通信的格式和数据边界问题。
  - Socket 是编程接口（API），用于实现网络通信，不限制协议层级。

- **HTTP/2 与 WebSocket 的对比**：
  - HTTP/2 引入了流的概念，支持服务端推送，但在全双工通信和实时性上仍不如 WebSocket 专用。

---

这篇笔记系统化地总结了 HTTP 和 WebSocket 的区别、技术原理、使用场景和实践意义，适合初学者或复习时参考。

<img src="https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241117114500583.png" alt="image-20241117114500583" style="zoom:50%;" />

websocket和http是两种协议，只不过前者的建立实在后者先连接的基础上再header中put响应的请求头信息来升级协议

# 操作系统

# Java基础

## private和protected的区别

- ### 回答重点

  在Java中，`protected` 和 `private` 是两种访问修饰符，用于控制类的成员（字段、方法或构造方法）的可见性和访问权限：

  1. **`protected`**
     - 访问范围：
       - 当前类
       - 同一包中的其他类
       - 继承该类的子类（即使不在同一包中，也可以访问 `protected` 的成员）
     - **典型场景：**
        适合在继承关系中提供子类访问权限，同时对无关类隐藏。
  2. **`private`**
     - 访问范围：
       - 仅限当前类内部。
     - **典型场景：**
        用于隐藏类的实现细节，只允许通过公有方法（getter、setter）或其他内部逻辑访问。

  ------

  ### 详细解析

  #### `protected` 关键点

  - 跨包访问限制：

     只能通过子类访问，不能直接通过对象访问。例如：

    ```java
    package packageA;
    public class Parent {
        protected void display() {
            System.out.println("Protected method");
        }
    }
    
    package packageB;
    import packageA.Parent;
    
    public class Child extends Parent {
        public void test() {
            display(); // 合法，子类继承访问
        }
    }
    ```

    如果 

    ```
    Child
    ```

     和 

    ```
    Parent
    ```

     是不同包中的类，

    ```
    display
    ```

     方法只能通过继承访问，不能通过实例直接调用。

  #### `private` 关键点

  - **完全隐藏：** 任何其他类，包括子类，均无法直接访问。

    ```java
    public class Parent {
        private String secret = "Hidden";
    
        private void showSecret() {
            System.out.println(secret);
        }
    
        public void accessSecret() {
            showSecret(); // 可通过公有方法间接访问
        }
    }
    ```

  - **封装性：** 强制使用者通过控制方法（如 getter 或 setter）访问和修改数据，便于控制输入输出的合法性。

  ------

  ### 知识扩展

  | 关键字      | 当前类 | 同包 | 子类（跨包） | 其他包 |
  | ----------- | ------ | ---- | ------------ | ------ |
  | `public`    | ✔      | ✔    | ✔            | ✔      |
  | `protected` | ✔      | ✔    | ✔            | ✘      |
  | `default`   | ✔      | ✔    | ✘            | ✘      |
  | `private`   | ✔      | ✘    | ✘            | ✘      |

  1. **`protected` vs `default` (无修饰符)**
      默认访问修饰符（`default`）仅限于包内访问，而 `protected` 允许子类跨包访问。

  2. **访问控制优先级：** `private` < `default` < `protected` < `public`

  3. **示意图：**

     ```text
     包A:
     ----------------------
     [ 类A ]  protected成员
             ↗
     包B:
     ----------------------
     [ 类B (子类) ]
     ```

  ------

  ### 总结

  - `private` 提供最严格的封装，仅供类内部使用。
  - `protected` 提供包访问权限，并扩展到子类，**即在继承关系中提供更高的灵活性。**

  



## Java中抽象类和接口有什么区别

### 设计动机

![image-20250110112841711](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110112841711.png)



## Java中为什么不支持多继承

Java不支持多重继承是因为它可能导致 **“钻石问题”**（Diamond Problem），增加代码的复杂性和模糊性。通过接口（`interface`）的机制，Java在一定程度上实现了多继承的灵活性，同时避免了多重继承的主要缺陷。

**拓展：为什么接口可以实习多实现**

理解：对于相同的重复方法且有不同的写法，子类必须重写接口，相当于归一化。

![image-20250110111210207](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110111210207.png)

## 为什么继承只允许单继承，接口可以多实现呢？

从设计角度上理解

- 接口是决定类有哪些能力can-do ，一个对象类可以掌握多个能力（规范）（实现多个接口）
- 继承是决定这个类是什么，所以从合理性解释一个类也只能是某一个父类的继承

![image-20250110111836362](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110111836362.png)



## JDK 和 JRE 有什么区别？

**回答重点：**

**JRE(Java Runtime Environment)指的是 Java 运行环境，包含了 JVM、核心类库和其他支持运行 Java 程序的文件。**

- JVM（Java Virtual Machine）：执行 Java 字节码，提供了 Java 程序的运行环境。
- 核心类库：一组标准的类库（如 java.lang、java.util 等），供 Java 程序使用。
- 其他文件：如配置文件、库文件等，支持 JVM 的运行。

JDK（Java Development Kit）可以视为 JRE 的超集，是用于开发 Java 程序的完整开发环境，它包含了 JRE，以及用于开发、调试和监控 Java 应用程序的工具。

- JRE：JDK 包含了完整的 JRE，因此它也能运行 Java 程序。
- 开发工具：如编译器（javac）、调试器（jdb）、打包工具（jar）等，用于开发和管理 Java 程序。
- 附加库和文件：支持开发、文档生成和其他开发相关的任务。

## Java中Exception和Error的区别？

![image-20250110092220609](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110092220609.png)

![image-20250110092355583](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250110092355583.png)

## Java的传参本质

在 Java 中，所有的参数传递本质上是 **值传递**。然而，这种值传递在不同的情境下可能表现得像“引用传递”，这是因为 Java 的对象引用本身是以值的形式传递的。我们具体来看：

------

### 1. 基本数据类型

对于 **基本数据类型**（`int`, `double`, `char`, `boolean` 等），参数传递的是变量的值，即复制了一份变量的内容。

**示例：**

```java
public class Test {
    public static void main(String[] args) {
        int num = 10;
        modifyValue(num);
        System.out.println("num 的值: " + num); // 输出: num 的值: 10
    }

    public static void modifyValue(int value) {
        value = 20; // 修改的是 value 的副本，与 num 无关
    }
}
```

**结论：** 基本数据类型的值不会受到方法内修改的影响，因为方法内操作的是副本。

------

### 2. 引用数据类型

对于 **引用数据类型**（如数组、对象等），参数传递的仍然是值，但这个值是**对象的引用地址的副本**。因此，通过这个副本，方法可以修改引用所指向的对象内容，但不能改变引用本身的指向。

**示例 1：修改对象的内容**

```java
public class Test {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        modifyArray(arr);
        System.out.println("arr[0] 的值: " + arr[0]); // 输出: arr[0] 的值: 99
    }

    public static void modifyArray(int[] array) {
        array[0] = 99; // 修改了引用指向的对象
    }
}
```

**示例 2：尝试修改引用本身**

```java
public class Test {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        changeReference(arr);
        System.out.println("arr[0] 的值: " + arr[0]); // 输出: arr[0] 的值: 1
    }

    public static void changeReference(int[] array) {
        array = new int[]{99, 98, 97}; // 修改的是 array 的副本，与原引用无关
    }
}
```

**结论：**

- 方法可以通过引用地址修改对象的内容。
- 方法无法改变外部变量的引用地址。

------

### 总结

1. **基本数据类型**：值传递，方法内操作的是副本。
2. **引用数据类型**：值传递，方法内操作的是对象引用地址的副本，可以通过它修改对象的内容，但不能修改引用本身。

**进一步思考：**

- 如果需要实现类似“引用传递”的行为，可以使用包装类（如 `AtomicInteger`）或将变量封装在自定义对象中。



## Java中的序列化和反序列化是什么？

![image-20241127141207657](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141207657.png)

![image-20241127141230685](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141230685.png)

### 实现这个接口的意义

![image-20241127141255819](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141255819.png)

![image-20241127141711398](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127141711398.png)

**通过id来验证在反序列化的过程中是否出错**

## Java 中的 hashCode 和 equals 方法之间有什么关系？ 

在 Java 中，`hashCode` 和 `equals` 是 Object 类中定义的两个重要方法。它们在集合框架中（如 `HashMap`、`HashSet`）和对象比较中发挥重要作用。这两个方法之间有紧密的关系，并且需要遵循特定的约定。

------

### **`hashCode` 方法**

- **作用**：
  - 返回对象的哈希值（一个整数）。
  - 用于确定对象在基于哈希的集合（如 `HashMap`、`HashSet`）中的存储位置。
- **默认实现**：
  - 默认情况下，`Object` 的 `hashCode` 方法返回对象的内存地址的哈希码。
- **需要重写时**：
  - 当类重写了 `equals` 方法时，也必须重写 `hashCode` 方法，以确保逻辑一致性。

------

### **`equals` 方法**

- **作用**：
  - 比较两个对象的内容是否相等。
  - 默认比较对象的引用地址。
- **默认实现**：
  - 默认情况下，`Object` 的 `equals` 方法比较对象的引用地址，即 `obj1 == obj2`。
- **需要重写时**：
  - 如果希望按内容比较两个对象是否相等（例如比较两个 `Person` 对象的 `name` 和 `age`），需要重写 `equals` 方法。

------

### **`hashCode` 和 `equals` 的关系**

根据 Java 的规范，`hashCode` 和 `equals` 方法必须满足以下关系：

1. **一致性（Consistent Relationship）**：
   - 如果两个对象根据 `equals` 方法比较是相等的（即 `a.equals(b)` 返回 `true`），那么它们的 `hashCode` 值必须相同。
2. **非强制要求（Not Required but Encouraged）**：
   - 如果两个对象根据 `equals` 方法比较不相等，则它们的 `hashCode` 值可以相同，但不建议。
3. **一致性约束（HashCode Contract）**：
   - 在同一次程序运行中，只要对象的内容未发生变化，多次调用同一个对象的 `hashCode` 方法应该返回相同的值。

如果这两个方法的逻辑不一致，可能会导致基于哈希的数据结构（如 `HashMap` 或 `HashSet`）工作异常。

------

### **示例代码**

下面是一个类重写 `equals` 和 `hashCode` 的示例：

```java
import java.util.Objects;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // 同一对象
        if (obj == null || getClass() != obj.getClass()) return false; // 类型不同
        Person person = (Person) obj; // 类型转换
        return age == person.age && Objects.equals(name, person.name); // 比较内容
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age); // 生成哈希值
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person("Alice", 25);
        Person p2 = new Person("Alice", 25);
        Person p3 = new Person("Bob", 30);

        // equals 比较
        System.out.println("p1 equals p2: " + p1.equals(p2)); // true
        System.out.println("p1 equals p3: " + p1.equals(p3)); // false

        // hashCode 比较
        System.out.println("p1 hashCode: " + p1.hashCode());
        System.out.println("p2 hashCode: " + p2.hashCode());
        System.out.println("p3 hashCode: " + p3.hashCode());

        // 基于 HashSet
        HashSet<Person> set = new HashSet<>();
        set.add(p1);
        set.add(p2); // 不会添加，因为 p1.equals(p2)
        set.add(p3);
        System.out.println("HashSet 内容: " + set);
    }
}
```

------

### **重要注意点**

1. **一致性问题**： 如果只重写了 `equals` 而没有重写 `hashCode`，可能会导致在 `HashMap` 或 `HashSet` 中存储和查找对象时行为异常。
2. **性能问题**： 不建议两个不相等的对象产生相同的哈希值（哈希冲突），因为这会降低哈希结构的性能。
3. **推荐使用 `Objects.hash`**：
   - 使用 `Objects.hash` 方法生成哈希值，简化代码。

------

### **总结**

- `equals` 决定对象是否“逻辑相等”。
- `hashCode` 决定对象在基于哈希的数据结构中的位置。
- 必须同时重写 `equals` 和 `hashCode`，确保它们逻辑一致。



在 Java 中，`hashCode` 和 `equals` 的知识在集合框架和实际开发中非常重要，尤其是在面试中常被用作核心问题。以下是一些扩展问题及其解答，以帮助理解这些方法的实际应用和潜在挑战。

------

### **扩展问题 1：`hashCode` 和 `equals` 在集合中的作用**

#### **问题**：在 HashMap 和 HashSet 中，`hashCode` 和 `equals` 是如何发挥作用的？

#### **解答**：

- **HashMap**：

  1. 存储键值对时

     ：

     - `hashCode` 决定键存储在哪个哈希桶（bucket）中。
     - 如果两个键的 `hashCode` 相同，它们会被存储到同一个桶中，形成链表（或树形结构，Java 8 引入）。
     - 再通过 `equals` 方法检查链表中的对象，确保键的唯一性。

  2. 查找键值对时

     ：

     - 首先根据 `hashCode` 定位桶。
     - 然后在桶中通过 `equals` 方法找到匹配的键。

- **HashSet**：

  - 工作原理与 HashMap 类似，但 HashSet 底层是通过一个 HashMap 来实现的，其中键为对象，值是一个固定值（通常为 `null`）。

#### **示例代码**：

```java
import java.util.HashSet;

class Example {
    private int value;

    public Example(int value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Example example = (Example) obj;
        return value == example.value;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(value);
    }
}

public class Main {
    public static void main(String[] args) {
        HashSet<Example> set = new HashSet<>();
        set.add(new Example(1));
        set.add(new Example(1)); // 因为 equals 返回 true，不会加入
        set.add(new Example(2));
        System.out.println("HashSet 内容: " + set.size()); // 输出 2
    }
}
```

------

### **扩展问题 2：`hashCode` 和 `equals` 不一致的后果**

#### **问题**：如果 `hashCode` 和 `equals` 逻辑不一致会发生什么？

#### **解答**：

1. **结果错误**：
   - 如果对象的 `hashCode` 相同，但 `equals` 不一致（即两个对象哈希值相同，但内容不等），可能会导致哈希表存储错误，出现重复对象或无法找到对象。
2. **查找失败**：
   - 如果 `hashCode` 逻辑错误，即使 `equals` 返回 `true`，在基于哈希的集合中仍可能找不到对象。
3. **性能下降**：
   - 如果大量对象的 `hashCode` 值相同（哈希冲突严重），会导致哈希表退化成链表，查找性能从 O(1) 降低到 O(n)。

------

### **扩展问题 3：如何设计一个良好的 `hashCode` 和 `equals` 实现？**

#### **问题**：重写 `hashCode` 和 `equals` 时有哪些最佳实践？

#### **解答**：

1. **`hashCode` 的设计**：
   - 使用所有参与 `equals` 比较的字段。
   - 尽量减少哈希冲突，分布均匀。
   - 推荐使用 `Objects.hash` 方法，或者参考经典算法（如乘法散列法）。
2. **`equals` 的实现**：
   - 避免直接使用 `==` 比较引用。
   - 检查对象是否为 `null` 和类型是否匹配。
   - 使用所有重要字段进行比较。
   - 遵循对称性、传递性、一致性等规范。

------

### **扩展问题 4：为什么推荐在 `equals` 中使用 `getClass` 而不是 `instanceof`？**

#### **问题**：在 `equals` 方法中，用 `getClass` 和 `instanceof` 有什么区别？

#### **解答**：

- **`getClass`**：
  - 比较时要求对象必须是同一类。
  - 适用于精确比较，例如比较两个完全相同类型的类。
- **`instanceof`**：
  - 判断对象是否为某个类或其子类的实例。
  - 适用于允许子类逻辑相等的场景。

#### **示例**：

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false; // 精确匹配
    MyClass other = (MyClass) obj;
    return field == other.field;
}

// 或使用 instanceof
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof MyClass)) return false; // 允许子类
    MyClass other = (MyClass) obj;
    return field == other.field;
}
```

**区别**：

- `getClass` 更严格，适用于不可变类（例如 `Integer`、`String`）。
- `instanceof` 更宽松，适用于继承层次结构中的多态比较。

------

### **扩展问题 5：面试中可能衍生的进阶问题**

1. **在 `TreeSet` 或 `TreeMap` 中，`hashCode` 和 `equals` 是否重要？**
   - 答：它们不重要，因为 `TreeSet` 和 `TreeMap` 使用 `compareTo` 或自定义的 `Comparator` 方法进行排序和比较。
2. **如何实现对象的深拷贝（基于序列化）？**
   - 答：通过序列化和反序列化可以实现深拷贝，但需要类实现 `Serializable` 接口。
3. **如何避免 `HashMap` 中的哈希冲突？**
   - 答：设计一个好的 `hashCode` 方法以均匀分布对象；此外，Java 8 中的 `HashMap` 在冲突链超过一定长度后会使用红黑树优化。
4. **`hashCode` 和 `equals` 是否适用于多线程环境？**
   - 答：默认情况下它们是线程安全的，但如果涉及可变字段且这些字段被多个线程修改，则需要同步或使用不可变对象。

# Redis

## 缓存雪崩、击穿、穿透

### 回答重点

**大量的缓存key，在同一时间过期，所有的请求直接访问到数据库上**

### 解决方案

- 增加key过期时间的随机性

### 其他问题

![image-20250120172856643](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250120172856643.png)

# Spring

## Spring事务

### 1.Spring事务的传播行为

​	理解Spring的事务，主要从三种角度去理解

- 融入：**一个事务出现在另外一个含有事务的方法内**，取消自身的事务特效，与外部事务构成大事务
- 挂载：**一个事务出现在另外一个含有事务的方法内**，当外部事务执行到本身时候，**切换线程绑定**，同时暂停外部事务进程执行（挂载），等待自身事务执行后，**唤醒**外部事务。
- 嵌套：
- ![image-20250411143707686](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250411143707686.png)

![image-20250411142955443](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250411142955443.png)

## @Resource和@Autowire的区别？

`https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5`参考链接

### 回答重点

`@Resource` 和 `@Autowired` 是 Spring 框架中用来实现依赖注入的两个注解，功能相似但有一些关键区别：

- **来源**：
  - `@Resource` 是 JSR-250 规范的一部分，属于 Java 标准，位于 `javax.annotation` 包中。
  - `@Autowired` 是 Spring 提供的注解，位于 `org.springframework.beans.factory.annotation` 包中。
- **注入方式**：
  - `@Resource` 默认按 **名称** 注入，可以通过 `name` 属性指定注入的 Bean 名称。如果没有指定 `name` 且找不到对应的名称 Bean，会按 **类型** 注入。
  - `@Autowired` 默认按 **类型** 注入。如果需要按名称注入，可以结合 `@Qualifier` 注解使用。
- **配置属性**：
  - `@Resource` 提供了 `name` 和 `type` 两个属性，用于精确指定注入的目标。
  - `@Autowired` 提供了 `required` 属性，用于控制是否必须注入（默认值为 `true`，即必须注入）。
- **适用范围**：
  - `@Resource` 通常用于更通用的场景，与 Java EE 兼容。
  - `@Autowired` 是 Spring 特有的，依赖于 Spring 容器。

------

### 详细解析

#### 1. **`@Resource` 的使用**

```java
@Resource(name = "myService")
private MyService service;
```

- **按名称注入**：如果指定了 `name` 属性，Spring 会在容器中查找名为 `"myService"` 的 Bean 并注入。
- **按类型注入**：如果没有指定 `name` 属性，Spring 会根据字段或属性的类型寻找匹配的 Bean。

------

#### 2. **`@Autowired` 的使用**

```java
@Autowired
private MyService service;
```

- **按类型注入**：Spring 根据 `MyService` 的类型寻找匹配的 Bean。
- **可选性控制**：`@Autowired(required = false)` 表示注入是可选的，如果没有找到匹配的 Bean，字段将保持未赋值。

```java
@Autowired(required = false)
private Optional<MyService> service; // Java 8 的 Optional
```

------

#### 3. **两者的对比示例**

假设我们有以下配置：

```java
@Component("myService")
public class MyServiceImpl implements MyService {
    // 实现方法
}
```

使用 `@Resource` 和 `@Autowired` 注入：

```java
@Component
public class MyController {

    @Resource(name = "myService")
    private MyService service1; // 按名称注入

    @Autowired
    private MyService service2; // 按类型注入
}
```

**总结**：

- 如果 `@Resource(name = "myService")` 找不到指定名称的 Bean，会抛出异常。
- 如果 `@Autowired` 找到多个 `MyService` 类型的 Bean，会抛出歧义性异常。

------

### 知识扩展

#### Spring 框架中的依赖注入模式

1. **构造器注入**：通过构造函数实现依赖注入，推荐用于不可变字段。
2. **Setter 注入**：通过 Setter 方法注入，适合可选的依赖。
3. **字段注入**：通过注解直接注入，简洁但难以测试。

#### 依赖注入的优先级

Spring 中多个注解可能同时使用时的优先级：

- `@Resource` 的优先级高于 `@Autowired`，如果一个字段同时标注了两者，`@Resource` 生效。

#### 多 Bean 的注入

当有多个类型相同的 Bean 时：

1. `@Qualifier` 和 `@Autowired` 配合使用，明确指定 Bean 名称。
2. 使用 `@Primary` 在一个 Bean 上标记为默认注入。

------

### 总结

![image-20250109092346658](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092346658.png)

- **`@Resource` 更关注名称匹配，兼容性强，适合跨框架使用，是java原生的javax.annotation下。**

- **`@Autowired` 更灵活，强类型注入，与 Spring 框架深度集成，如果又多个相同Type的，可以结合Qualifier注解**

  ![结合Qualifer注解搭配Autowired](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092226343.png)

![image-20250109092039180](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092039180.png)

------

### 相关面试题

1. 如果容器中有两个相同类型的 Bean，分别使用 `@Resource` 和 `@Autowired`，结果会怎样？
2. 请解释 `@Primary` 和 `@Qualifier` 的作用及区别。
3. 如果同时使用了 `@Resource` 和 `@Autowired`，如何确定最终注入的 Bean？
4. 使用 `@Autowired` 注入时，如何处理可能为空的依赖？

## IoC和DI的区别？

IoC（Inverse of Control:控制反转）是一种设计思想或者说是某种模式。这个设计思想就是 **将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容器。** 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。

IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。

### 总结

| **对比维度** | **IOC**                        | **DI**                       |
| ------------ | ------------------------------ | ---------------------------- |
| 定义         | 一种设计原则                   | 实现IOC的具体方式            |
| 核心目标     | 反转对象创建和依赖管理的控制权 | 注入依赖，解耦对象           |
| 实现方式     | 可通过DI、服务定位器等实现     | 通过构造器、Setter等方式实现 |
| 依赖于容器   | 是                             | 是                           |



## Spring注入依赖的几种方式？

- Setter：在xml中注入setter方法

本质上包含两步：

1. **第一步，需要new UserServiceImpl()创建对象, 所以需要默认构造函数**
2. **第二步，调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数**

![image-20250109093938337](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093938337.png)、

- 构造函数注入

![image-20250109094055803](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109094055803.png)

- 最后一个就是最常用的注解注入

![image-20250109092526737](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109092526737.png)

## Spring注入IOC容器的几种方法

![image-20250109093716248](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093716248.png)

- 注解注入

![image-20250109093824147](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093824147.png)

- xm配置

![image-20250109093814489](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093814489.png)

- @Configuration+@Bean
- ![image-20250109093747283](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093747283.png)

## @Component和@Configuration的区别

### 主要回答

![image-20250109093542631](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109093542631.png)



## Bean的作用域有几种

![image-20250109100026118](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109100026118.png)

**官网最新的六种作用域**

![image-20250109095919790](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109095919790.png)

### 1.Singleton(默认)

- **描述**：默认作用域。Spring 容器中只会创建该 Bean 的一个实例，无论你获取多少次，始终是同一个对象。
- **使用场景**：适合无状态的、共享资源的 Bean。
- **声明方式**：`@Scope("singleton")` 或默认不声明。

### 2. **Prototype**

- **描述**：每次获取时都会创建一个新的实例。
- **使用场景**：适合需要频繁创建的 Bean，例如多线程中需要独立状态的 Bean。
- **声明方式**：`@Scope("prototype")`。

### 3. **Request**

- **描述**：每个 HTTP 请求都会创建一个新的实例，生命周期与请求相同。
- **使用场景**：适合 Web 应用中与单次请求关联的 Bean。
- **声明方式**：`@Scope("request")`。
- **前提**：需要在 Web 应用环境下运行。

### 4. **Session**

- **描述**：每个 HTTP Session 会创建一个新的实例，生命周期与会话相同。
- **使用场景**：适合 Web 应用中需要与用户会话绑定的 Bean。
- **声明方式**：`@Scope("session")`。
- **前提**：需要在 Web 应用环境下运行。

### 5. **Application**

- **描述**：在 ServletContext 级别共享同一个实例，生命周期与 Web 应用程序一致。
- **使用场景**：适合整个应用程序范围共享的 Bean。
- **声明方式**：`@Scope("application")`。
- **前提**：需要在 Web 应用环境下运行。

### 6. **WebSocket**

- **描述**：每个 WebSocket 会话都会创建一个新的实例。
- **使用场景**：适合基于 WebSocket 会话的 Bean。
- **声明方式**：`@Scope("websocket")`。
- **前提**：需要在支持 WebSocket 的应用中运行。



## 怎么绑定Bean的作用域？

**重点**：通过Scope来绑定

```java
@Component
@Scope(value = "request")
public class RequestScopedBean {
}

```



![image-20250109100457772](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109100457772.png)



## @RequestBody的作用？

### 回答重点

`@RequestBody` 是 Spring 框架中用于将 HTTP 请求体内容绑定到 Java 对象的注解，通常用于处理 JSON 或 XML 格式的数据。在 Spring 的 `@Controller` 或 `@RestController` 方法中，`@RequestBody` 解析请求体，并将其转换为方法参数对象。

------

### 详细解析

#### 使用场景

1. **处理 HTTP POST/PUT 请求的请求体**
   - 通常用于 RESTful 接口，在客户端提交 JSON 或 XML 数据时，服务器端需要将这些数据转换为 Java 对象以便进一步处理。
2. **结合 Jackson 序列化**
   - Spring MVC 使用 Jackson 库（默认）将 JSON 数据反序列化为对应的 Java 对象，或者将 Java 对象序列化为 JSON 数据返回。

#### 示例代码

```java
@RestController
public class UserController {
    @PostMapping("/users")
    public String createUser(@RequestBody User user) {
        return "User " + user.getName() + " created successfully!";
    }
}

class User {
    private String name;
    private int age;

    // getters and setters
}
```

#### 请求示例

**请求 URL:**
 `POST http://localhost:8080/users`

**请求体 (JSON):**

```json
{
    "name": "Alice",
    "age": 25
}
```

**服务器输出:**
 `User Alice created successfully!`

#### 工作原理

1. Spring MVC 使用 `HttpMessageConverter`（例如 `MappingJackson2HttpMessageConverter`）读取请求体并将其反序列化。
2. 通过 `@RequestBody` 注解标注的方法参数会被自动注入反序列化后的对象。
3. 如果请求体与目标对象结构不匹配，则会抛出异常，如 `HttpMessageNotReadableException`。

#### 特点与限制

- 优点

  :

  - 简化了手动解析请求体的工作。
  - 与 Spring 的依赖注入无缝集成。

- 限制

  :

  - 默认需要请求体，否则会抛出异常。如果请求体可选，可以通过设置 

    ```
    required = false
    ```

     来实现:

    ```java
    public ResponseEntity<?> update(@RequestBody(required = false) User user) { ... }
    ```

------

### 知识扩展

#### 常见错误及解决方法

1. **`HttpMessageNotReadableException`**
   - 原因：请求体与 Java 对象结构不匹配。
   - 解决：确保 JSON 数据与目标对象的字段和类型一致。
2. **缺少默认构造函数**
   - 原因：目标对象缺少无参构造函数。
   - 解决：为 POJO 添加无参构造函数。
3. **字符编码问题**
   - 确保客户端和服务器之间的字符集一致（如 UTF-8）。

#### 与其他注解的对比

| 注解              | 作用                                     |
| ----------------- | ---------------------------------------- |
| `@RequestBody`    | 将请求体绑定到方法参数对象               |
| `@RequestParam`   | 提取 URL 中的查询参数或表单参数          |
| `@PathVariable`   | 提取 URL 路径中的动态部分                |
| `@ModelAttribute` | 将表单数据绑定到对象（通常用于表单提交） |

------

### 总结

`@RequestBody` 是一个强大的工具，用于简化 JSON 或 XML 请求数据到 Java 对象的映射。它适合在 RESTful 风格的 API 中处理复杂的请求数据。通过结合 Spring 的序列化机制，开发者可以快速实现接口功能，同时提高代码的可读性和可维护性。





# MYSQL

## 什么是数据库的隔离级别

### **什么是事务隔离级别？**

**事务隔离级别**是数据库系统用来定义多个事务并发执行时，相互之间隔离程度的机制。它主要解决在并发事务环境下可能出现的数据不一致问题，比如**脏读**、**不可重复读**和**幻读**。

事务隔离级别通过设置不同的限制，来控制事务对共享资源（如表、行、页）的访问方式，以平衡数据一致性和系统性能。

------

### **事务的四大特性（ACID）与隔离性**

事务的四大特性是 **ACID**（Atomicity, Consistency, Isolation, Durability），其中的 **Isolation（隔离性）** 就是事务隔离级别的核心所在。
 隔离性确保一个事务的执行不会受到其他事务中间状态的干扰。

------

### **事务隔离级别的分类**

SQL标准定义了 4 种隔离级别，隔离性从低到高依次为：

| **隔离级别**            | **描述**                                                     | **解决的问题**               | **典型问题可能性**     |
| ----------------------- | ------------------------------------------------------------ | ---------------------------- | ---------------------- |
| **1. READ UNCOMMITTED** | 事务可以读取到其他事务未提交的数据（脏读）                   | 无限制，性能最高，但一致性差 | 脏读、不可重复读、幻读 |
| **2. READ COMMITTED**   | 事务只能读取到其他事务已提交的数据（防止脏读）               | 避免脏读                     | 不可重复读、幻读       |
| **3. REPEATABLE READ**  | 事务多次读取同一行数据，读取结果始终一致（防止不可重复读），但可能出现幻读 | 避免脏读和不可重复读         | 幻读                   |
| **4. SERIALIZABLE**     | 所有事务串行化执行（完全隔离，防止幻读），相当于加锁处理     | 避免脏读、不可重复读和幻读   | 无并发性，性能最低     |

------

### **四种隔离级别的行为差异**

隔离级别的定义决定了能防止哪些并发问题：

| 隔离级别             | 脏读 (Dirty Read) | 不可重复读 (Non-Repeatable Read) | 幻读 (Phantom Read) |
| -------------------- | ----------------- | -------------------------------- | ------------------- |
| **READ UNCOMMITTED** | 可能              | 可能                             | 可能                |
| **READ COMMITTED**   | 禁止              | 可能                             | 可能                |
| **REPEATABLE READ**  | 禁止              | 禁止                             | 可能                |
| **SERIALIZABLE**     | 禁止              | 禁止                             | 禁止                |

------

### **隔离级别的详细说明**

#### **1. READ UNCOMMITTED（读未提交）**

- 特点：
  - 事务可以读取到其他事务尚未提交的数据。
  - 并发性能最好，但可能导致数据一致性问题。
- 问题：
  - 可能发生 **脏读**、**不可重复读** 和 **幻读**。
- 适用场景：
  - 数据一致性要求较低的场景，例如日志系统。

#### **2. READ COMMITTED（读已提交）**

- 特点：
  - 一个事务只能读取到其他事务已提交的数据。
  - 避免了 **脏读**。
- 问题：
  - 可能发生 **不可重复读** 和 **幻读**。
- 适用场景：
  - 需要避免脏读，且对不可重复读和幻读容忍的业务场景，例如在线查询系统。
- MySQL中：
  - Oracle 数据库默认隔离级别。

#### **3. REPEATABLE READ（可重复读）**

- 特点：
  - 在同一事务中，多次读取同一行的数据时，结果是一致的。
  - 避免了 **脏读** 和 **不可重复读**。
- 问题：
  - 可能发生 **幻读**。
- 适用场景：
  - 读一致性要求高的场景，例如财务系统。
- MySQL中：
  - 默认的隔离级别。MySQL通过多版本并发控制（MVCC）机制解决了幻读问题。

#### **4. SERIALIZABLE（可串行化）**

- 特点：
  - 强制事务串行化执行，避免了所有并发问题（脏读、不可重复读、幻读）。
  - 等效于对每个查询加锁。
- 问题：
  - 并发性能最低，可能出现大量锁等待。
- 适用场景：
  - 数据一致性要求极高且并发需求较低的场景，例如银行转账系统。

------

### **如何选择事务隔离级别？**

选择隔离级别需要权衡**性能**与**一致性**：

1. 性能优先，容忍一定的不一致性：
   - 使用 **READ UNCOMMITTED** 或 **READ COMMITTED**。
2. 一致性优先，但需要较高并发：
   - 使用 **REPEATABLE READ**（MySQL 默认）。
3. 一致性绝对优先，完全避免并发问题：
   - 使用 **SERIALIZABLE**，但性能会显著下降。

------

### **MySQL中的事务隔离级别**

- 默认隔离级别：**REPEATABLE READ**。

- 配置方法：

  1. 修改全局或会话级别隔离级别：

     ```sql
     SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 全局修改
     SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; -- 会话修改
     ```

  2. 在事务中设置隔离级别：

     ```sql
     SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
     START TRANSACTION;
     ```

------

### **事务隔离级别与常见问题的示例**

#### **(1) 脏读问题**

- **场景：** 一个事务读取了另一个未提交事务的修改数据。
- **避免方式：** 选择 **READ COMMITTED** 或更高。

#### **(2) 不可重复读问题**

- **场景：** 一个事务两次读取同一行数据，但因为另一个事务修改了数据，导致结果不同。
- **避免方式：** 选择 **REPEATABLE READ** 或更高。

#### **(3) 幻读问题**

- **场景：** 一个事务两次查询同一条件的数据范围，但另一个事务插入了新数据，导致查询结果不一致。
- **避免方式：** 选择 **SERIALIZABLE**。

------

### **事务隔离级别的重要性**

1. **保护数据一致性：** 防止并发事务引发数据不一致问题。
2. **提升性能：** 通过适当的隔离级别，减少锁竞争，提升并发处理能力。
3. **灵活性：** 根据实际需求，权衡一致性和性能，选择适合的隔离级别。

如果需要更详细的实践代码或案例分析，欢迎进一步提问！

## 执行一条 select 语句，期间发生了什么？



## “**脏读**”、“**不可重复读**” 和 “**幻读**？

在数据库事务管理中，“**脏读**”、“**不可重复读**” 和 “**幻读**” 是与事务隔离性相关的三种典型问题。它们主要出现在多事务并发操作时，了解它们对于选择合适的隔离级别（Isolation Level）非常重要。以下是详细的解释：

------

### **1. 脏读 (Dirty Read)**

**定义：**
 一个事务能够读取到另一个事务尚未提交的数据。如果后者事务回滚，那么前者读取到的就是无效或“脏”的数据。

#### **示例：**

1. 事务A更新了一行数据，但尚未提交。
2. 事务B读取了这行未提交的数据。
3. 事务A回滚了更改，事务B此时读取的数据是无效的。

#### **代码示例：**

```sql
-- 假设有一张表 account(balance INT)，初始余额为 100。
-- 事务A
START TRANSACTION;
UPDATE account SET balance = balance - 50 WHERE id = 1; -- 将余额减少50

-- 事务B
START TRANSACTION;
SELECT balance FROM account WHERE id = 1; -- 事务B读取到未提交的新余额（可能为50）

-- 事务A
ROLLBACK; -- 事务A回滚更改

-- 事务B读取到的余额（50）是脏数据，因为实际上余额应该还是100。
```

#### **避免方法：**

选择隔离级别 **`READ COMMITTED`** 或更高。

------

### **2. 不可重复读 (Non-Repeatable Read)**

**定义：**
 一个事务在两次读取同一数据时，数据值因另一个事务的提交而发生变化，导致读取的结果不一致。

#### **示例：**

1. 事务A读取了某行数据。
2. 事务B更新了该行数据并提交。
3. 事务A再次读取同一行数据，发现内容已被修改。

#### **代码示例：**

```sql
-- 假设表 account(balance INT)，初始余额为 100。
-- 事务A
START TRANSACTION;
SELECT balance FROM account WHERE id = 1; -- 第一次读取，余额为100

-- 事务B
START TRANSACTION;
UPDATE account SET balance = balance + 50 WHERE id = 1; -- 更新余额为150
COMMIT; -- 提交更改

-- 事务A
SELECT balance FROM account WHERE id = 1; -- 第二次读取，余额变为150
-- 两次读取结果不同，不可重复读问题。
```

#### **避免方法：**

选择隔离级别 **`REPEATABLE READ`** 或更高。

------

### **3. 幻读 (Phantom Read)**

**定义：**
 一个事务两次查询某范围的数据时，因另一个事务插入了新的数据而导致结果集不一致。

#### **示例：**

1. 事务A查询满足某条件的记录集。
2. 事务B插入了一条新记录并提交。
3. 事务A再次查询相同条件，发现多了一条记录。

#### **代码示例：**

```sql
-- 假设表 account(balance INT)，初始有两条记录 (id=1, id=2)。
-- 事务A
START TRANSACTION;
SELECT * FROM account WHERE balance > 50; -- 查询余额大于50的记录，结果可能是两条

-- 事务B
START TRANSACTION;
INSERT INTO account (id, balance) VALUES (3, 60); -- 插入新记录
COMMIT; -- 提交更改

-- 事务A
SELECT * FROM account WHERE balance > 50; -- 再次查询，结果多了一条记录(id=3)
-- 事务A发现多出了数据，即为幻读。
```

#### **避免方法：**

选择隔离级别 **`SERIALIZABLE`**。

------

### **总结：不同问题与隔离级别的关系**

| 隔离级别             | 脏读 | 不可重复读 | 幻读 |
| -------------------- | ---- | ---------- | ---- |
| **READ UNCOMMITTED** | 可能 | 可能       | 可能 |
| **READ COMMITTED**   | 禁止 | 可能       | 可能 |
| **REPEATABLE READ**  | 禁止 | 禁止       | 可能 |
| **SERIALIZABLE**     | 禁止 | 禁止       | 禁止 |

------

### **实用建议**

1. **选择隔离级别**：
   - 如果读一致性要求较高且性能可接受，优先使用 **`REPEATABLE READ`**。
   - 如果完全避免并发问题且不关心性能，则选择 **`SERIALIZABLE`**。
2. **MySQL默认隔离级别：**
    MySQL 的默认隔离级别是 **`REPEATABLE READ`**，它避免了脏读和不可重复读问题，但可能存在幻读。
3. **测试环境中复现问题：**
    利用事务模拟上述三种问题，能加深对隔离级别的理解。

------

如果需要进一步的实践题或代码演练，欢迎继续提问！

## Mysql中如何存储NULL

在 MySQL 中，**NULL 值**的存储方式取决于表的存储引擎（如 InnoDB 或 MyISAM）以及列的定义情况。NULL 值表示字段没有值或未知，与数字 0、空字符串 `''` 并不相同。

以下是 MySQL 中 NULL 值的存储和处理方式的详细说明：

------

### **1. NULL 值在存储上的实现**

#### **1.1. InnoDB 存储引擎**

- **NULL 值在记录中的存储：**

  - 在 InnoDB 中，每一行记录有一个额外的 **位图（bitmap）**，用来标识列是否为 NULL。
  - 如果某列允许为 NULL，那么在该列的位图中会为它分配一位，用来存储“是否为 NULL”的状态：
    - **1：表示该列为 NULL**。
    - **0：表示该列非 NULL**。
  - NULL 值本身不会占用额外的存储空间（即该列的实际值未被存储）。

- **存储示例：**

  - 如果表定义为：

    ```sql
    CREATE TABLE example (
        id INT NOT NULL,
        name VARCHAR(50),
        age INT NULL
    );
    ```

    - `name` 列可以为 NULL。
    - `age` 列可以为 NULL，InnoDB 会为 `age` 列分配 1 位来表示是否为 NULL。

------

#### **1.2. MyISAM 存储引擎**

- 在 MyISAM 中，NULL 值的存储方式类似 InnoDB：
  - 使用额外的位来标识列是否为 NULL。
  - 如果一个表包含多个允许为 NULL 的列，MyISAM 会用一个 NULL 标志字节来存储这些列的 NULL 状态，每列对应一位。
- **存储效率：**
  - NULL 值本身不会占用实际存储空间，只会影响 NULL 标志位。

------

### **2. NULL 值与索引**

- **索引中存储 NULL 值的处理：**
  - InnoDB 引擎：
    - NULL 值可以存储在索引中。
    - 对于单列索引，NULL 值会被索引，且多次出现的 NULL 值会被视为相同的键值。
  - MyISAM 引擎：
    - NULL 值也会被索引，但处理方式与非 NULL 值类似。
- **主键和唯一索引：**
  - 主键列（`PRIMARY KEY`）**不允许为 NULL**，因为主键要求每一行记录唯一标识。
  - 唯一索引（`UNIQUE INDEX`）允许列为 NULL，并且多个 NULL 值被视为不同（SQL 标准的规定）。

------

### **3. NULL 值的处理逻辑**

#### **3.1. 比较操作**

NULL 值的比较与常规值不同，不能直接用 `=` 或 `!=` 判断。需要用 **`IS NULL`** 或 **`IS NOT NULL`** 判断是否为 NULL：

```sql
-- 查找某列值为 NULL 的记录：
SELECT * FROM example WHERE age IS NULL;

-- 查找某列值非 NULL 的记录：
SELECT * FROM example WHERE age IS NOT NULL;
```

#### **3.2. NULL 值的参与计算**

任何值与 NULL 进行算术或逻辑运算，结果都会是 NULL。例如：

```sql
SELECT 10 + NULL; -- 结果为 NULL
SELECT 'abc' || NULL; -- 结果为 NULL
```

#### **3.3. 聚合函数与 NULL**

聚合函数会自动忽略 NULL 值。例如：

```sql
SELECT AVG(age) FROM example; -- NULL 值不会参与平均值计算
SELECT COUNT(age) FROM example; -- COUNT 只统计非 NULL 值
```

------

### **4. NULL 对性能的影响**

- **存储效率：**

  - NULL 值不会占用实际的列存储空间，但会增加 NULL 标志位，通常不会显著影响存储效率。

- **查询效率：**

  - 查询 NULL 值时，通常无法利用索引，可能导致全表扫描。例如：

    ```sql
    SELECT * FROM example WHERE age IS NULL;
    ```

------

### **5. 特殊场景：NOT NULL 和 DEFAULT 的关系**

- 如果某列定义为 `NOT NULL` 且没有指定默认值（`DEFAULT`），那么插入时必须显式提供一个值，否则会报错。
- 如果某列定义为允许 NULL，则可以插入 `NULL` 值或不指定该列，默认值为 `NULL`。

------

### **6. NULL 值的常见问题与解决**

#### **6.1. 主键不支持 NULL**

```sql
CREATE TABLE example (
    id INT PRIMARY KEY, -- 主键不允许为 NULL
    name VARCHAR(50) NULL
);
```

解决方法：使用其他列作为主键，或设置非 NULL 的替代值。

#### **6.2. NULL 与默认值**

如果某列既允许 NULL，又设置了默认值，默认值仅在插入未提供该列值时生效。插入显式 NULL 时，列值为 NULL。

#### **6.3. 查询中的 NULL**

对于多条件查询，要注意 NULL 的特殊处理。例如：

```sql
SELECT * FROM example WHERE age = 30 OR age IS NULL;
-- 需要显式加入 IS NULL 条件
```

------

### **总结**

1. **存储：** NULL 值以额外的标志位存储，不占用实际的列存储空间。1表示null，占用一个bitmap也就是1字节来标识
2. **索引：** NULL 值会被索引，但主键列不允许为 NULL。
3. **比较：** 需要用 `IS NULL` 或 `IS NOT NULL` 判断 NULL 值。
4. **聚合：** 聚合函数自动忽略 NULL 值。

如果你有更具体的场景需求，欢迎继续提问！



## varchar(n) 中 n 最大取值为多少？

![image-20241126145754668](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126145754668.png)

### 单字段

![image-20241126145818613](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126145818613.png)

![image-20241126145831926](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126145831926.png)

### 如果需要更大的字段怎么办

![image-20241126150912928](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241126150912928.png)

### **5. 综合总结**

1. **理论上：** `VARCHAR(n)` 的 `n` 最大值是 65535，但受限于字符集和存储引擎的行大小限制。

> utf-8 3字节 ASCII1字节

1. 常用范围：
   - `latin1` 字符集：`VARCHAR(65535)`。
   - `utf8mb4` 字符集：实际 `n` 最大值约为 16383。
2. 优化建议：
   - 根据实际需要选择合适的字符集和字段长度。
   - 超长文本可以考虑使用 `TEXT` 类型。

同时null也会占用一个bitmap





## Mysqls索引

- 详细参考链接

`https://javaguide.cn/database/mysql/mysql-index.html`



## 有哪几类索引

### 回答重点

索引可以根据不同维度进行分类，常见分类方法如下：

1. **根据功能分类**：
   - **主键索引**：强制唯一性约束，用于主键字段。
   - **唯一索引**：限制字段值唯一性，可包含空值。
   - **普通索引**：无约束，仅提升查询性能。
   - **复合索引**：包含多个字段的索引，用于多条件优化。
2. **根据数据结构分类**：
   - **B-Tree 索引**：大多数数据库的默认索引类型，支持范围查询和排序。
   - **Hash 索引**：基于 Hash 表，适合精确匹配。
   - **R-Tree 索引**：用于多维数据查询（如地理坐标）。
   - **全文索引（倒排索引）**：为文本字段设计，支持关键词搜索。
3. **根据使用场景分类**：
   - **单字段索引**：优化单个字段的查询。
   - **多字段索引（复合索引）**：优化多个字段组合的查询。
   - **覆盖索引**：索引字段包含查询中所有需要的字段，避免回表。
   - **唯一约束索引**：同时保证字段唯一性和查询效率。
4. **根据存储方式分类**：
   - **聚簇索引（Clustered Index）**：数据存储顺序与索引顺序一致，每张表只能有一个。
   - **非聚簇索引（Non-Clustered Index）**：索引存储与数据分离，可有多个非聚簇索引。
   - **物化索引（Materialized Index）**：预计算并存储查询结果的索引。
5. **根据生命周期分类**：
   - **永久索引**：手动创建并长期存在。
   - **临时索引**：数据库在查询优化时自动生成，生命周期仅限于查询。

------

### 详细解析

#### **1. 功能分类**

| **索引类型** | **描述**                       | **适用场景**                             |
| ------------ | ------------------------------ | ---------------------------------------- |
| 主键索引     | 确保主键唯一，自动生成         | 表的主键字段，如 ID。                    |
| 唯一索引     | 确保字段值唯一，允许 `NULL` 值 | 如邮箱、用户名字段。                     |
| 普通索引     | 无唯一性约束，用于提升查询性能 | 经常作为查询条件的普通字段。             |
| 复合索引     | 基于多个字段的索引             | 多条件组合查询优化，如 `WHERE A AND B`。 |

------

#### **2. 数据结构分类**

| **数据结构** | **特点**                             | **适用场景**                         |
| ------------ | ------------------------------------ | ------------------------------------ |
| B-Tree       | 默认索引结构，支持范围查询和排序     | 大多数查询场景，如范围查询、排序等。 |
| Hash         | 精确匹配查询速度快，不支持范围查询   | 需要高效键值查找的场景。             |
| R-Tree       | 支持多维数据（如地理坐标）的范围查找 | GIS 数据存储和查询。                 |
| 倒排索引     | 将关键词映射到文档，适合全文检索     | 文本搜索，如商品描述、文章内容等。   |

------

#### **3. 使用场景分类**

| **索引类型** | **描述**                           | **适用场景**                                      |
| ------------ | ---------------------------------- | ------------------------------------------------- |
| 单字段索引   | 优化单个字段的查询                 | 针对单一条件查询优化，如 `WHERE name = 'Alice'`。 |
| 复合索引     | 基于多字段，按最左前缀顺序优化查询 | 多条件联合查询，如 `WHERE A = x AND B = y`。      |
| 覆盖索引     | 包含查询中所有字段，避免回表       | 查询字段与索引完全重合的场景。                    |
| 唯一约束索引 | 同时确保字段唯一性与性能           | 唯一性和查询优化，如用户名或邮箱。                |

------

#### **4. 存储方式分类**

| **索引类型** | **描述**                               | **适用场景**                                 |
| ------------ | -------------------------------------- | -------------------------------------------- |
| 聚簇索引     | 数据按索引排序存储，主键字段上自动创建 | 表的主键索引，适合经常排序、范围查询的字段。 |
| 非聚簇索引   | 索引存储与数据分离，可有多个非聚簇索引 | 非主键字段的优化，如 `name` 或 `email`。     |
| 物化索引     | 预计算并存储查询结果                   | 大量复杂查询结果重复的场景。                 |

------

### 知识扩展

#### **聚簇索引 vs 非聚簇索引**

1. 聚簇索引：
   - 数据物理顺序与索引顺序一致，主键索引为聚簇索引。
   - 每张表仅有一个聚簇索引。
   - 优点：查询快，特别是范围查询。
   - 缺点：插入新记录可能导致数据页重新排序。
2. 非聚簇索引：
   - 索引和数据独立存储，可有多个非聚簇索引。
   - 优点：灵活，可用于多个字段。
   - 缺点：查询需要回表增加开销。

#### **B-Tree vs Hash**

1. B-Tree 索引：
   - 支持范围查询（如 `<`、`>`）。
   - 适合排序和范围条件。
2. Hash 索引：
   - 查询复杂度 O(1)，但不支持排序和范围条件。
   - 适合等值查询。

------

### 总结

索引分类方式多样化，具体选择要结合业务需求。功能、数据结构和存储方式分类是最常用的角度。合理使用索引可以有效提升查询性能，同时避免索引过多导致写入开销增加。

------

## 什么是索引下推

### 回答重点

**索引下推**（Index Condition Pushdown, ICP）是 MySQL 5.6 引入的一种优化技术，用于减少回表次数，提升查询效率。

在传统的索引查询中，如果有索引覆盖了部分查询条件，查询会通过索引找到匹配的记录指针，然后回表检查剩余的条件是否满足。而索引下推技术允许 MySQL 在**存储引擎层**直接使用部分查询条件过滤数据，减少需要回表的记录数。

------

### 详细解析

#### **1. 索引下推的工作原理**

![image-20241213222557566](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213222557566.png)

- **传统索引查询（无索引下推）**：
   查询条件在 MySQL **服务器层**处理，存储引擎只通过索引查找到记录的主键值或行位置。对于每条候选记录，存储引擎都要回表读取完整记录，返回给服务器层，再由服务器层判断是否符合其他查询条件。
- **索引下推**：
   一部分查询条件（与索引相关的条件）被下推到**存储引擎层**，存储引擎可以在索引中直接过滤数据，只有满足条件的记录才会回表。

#### **2. 索引下推的适用场景**

索引下推主要在以下场景中生效：

1. 复合索引

   ：

   - 查询条件中包含多个字段，但不全是最左前缀的字段。

2. 范围查询

   ：

   - 某些条件需要回表进一步判断，例如 `LIKE` 或范围过滤。

#### **3. 示例说明**

假设有如下表和索引：

```sql
CREATE TABLE employees (
    id INT NOT NULL,
    name VARCHAR(100),
    age INT,
    department VARCHAR(50),
    PRIMARY KEY (id),
    KEY idx_name_age (name, age)
);
```

**查询：**

```sql
SELECT * FROM employees WHERE name LIKE 'A%' AND age > 30;
```

- **无索引下推**：
  1. 使用索引 `idx_name_age` 找到 `name LIKE 'A%'` 的匹配记录。
  2. 对每条匹配记录进行回表操作，读取完整记录。
  3. 回表后，再由服务器层判断 `age > 30` 是否满足。
- **索引下推**：
  1. 存储引擎先在 `idx_name_age` 中找到 `name LIKE 'A%'` 的匹配记录。
  2. 同时直接在存储引擎中判断 `age > 30`，仅保留符合条件的记录。
  3. 只对符合两个条件的记录回表读取完整数据。

------

### 知识扩展

#### **索引下推的优点**

1. 减少回表次数

   ：

   - 存储引擎过滤掉不必要的记录，降低磁盘 I/O 开销。

2. 提升查询性能

   ：

   - 减少服务器层的计算压力。

#### **索引下推的限制**

1. 条件必须与索引相关

   ：

   - 只有能通过索引访问的字段条件才可以下推。

2. 不支持非索引字段的条件

   ：

   - 例如 `WHERE name LIKE 'A%' AND department = 'HR'`，`department` 的条件不会被下推。

------

### 索引下推的执行过程示意图

```plaintext
传统方式（无索引下推）：
索引匹配 → 回表所有候选记录 → 服务器层过滤剩余条件

索引下推：
索引匹配 → 存储引擎层过滤部分条件 → 回表符合条件的记录 → 服务器层完成剩余条件过滤
```

------

### 总结

![image-20241213222635662](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213222635662.png)

## 防止索引失效

![图片.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b70720b0cb422fb2583fb80a745e99~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![image-20241213224322902](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213224322902.png)

![image-20241213224350318](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241213224350318.png)

## B树与B+树的区别

*参考视频地址*：https://www.bilibili.com/video/BV1zE421F7TA?t=151.2

![image-20250120141331829](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250120141331829.png)

# Java集合

## Java 中的 HashSet 和 HashMap 有什么区别

![image-20241127144114391](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20241127144114391.png)

在 Java 中，`HashSet` 和 `HashMap` 都是基于哈希表的集合类，但它们的用途和底层实现有所不同。以下从理论角度详细解析两者的区别，重点在底层逻辑和使用场景。

------

### **1. 核心区别总结**

1. **用途**：
   - **`HashSet`**：用于存储 **唯一元素**，保证无重复。
   - **`HashMap`**：用于存储 **键值对**（Key-Value），通过键快速查找值。
2. **底层实现**：
   - **`HashSet`**：基于 `HashMap` 实现，内部使用 `HashMap` 存储元素。
   - **`HashMap`**：基于数组 + 链表 + 红黑树实现，是更底层的实现结构。
3. **存储结构**：
   - **`HashSet`**：将元素存储为 `HashMap` 的键（`Key`），值（`Value`）为固定的常量对象（`PRESENT`）。
   - **`HashMap`**：存储键和值，每个键值对是一个 `Node<K, V>`。
4. **唯一性**：
   - **`HashSet`**：元素的唯一性通过 `hashCode` 和 `equals` 保证。
   - **`HashMap`**：键的唯一性通过 `hashCode` 和 `equals` 保证，但值可以重复。

------

### **2. 理论深度解析**

#### **2.1 为什么 HashSet 基于 HashMap 实现？**

- `HashSet` 的主要功能是存储唯一元素，而 `HashMap` 的键（`Key`）本身就是唯一的。
- 利用 `HashMap` 的键存储元素，可以复用 `HashMap` 的底层哈希表、冲突处理（链表/红黑树）、扩容机制等复杂逻辑，从而简化 `HashSet` 的实现。

#### **2.2 HashSet 的底层结构**

- `HashSet` 使用 `HashMap` 存储元素，所有存储在 `HashSet` 的元素都作为 `HashMap` 的键（`Key`），对应的值（`Value`）是一个固定的常量对象（`PRESENT`）。

- 示例（内部实现逻辑）：

  ```java
  private static final Object PRESENT = new Object();
  private transient HashMap<E, Object> map;
  
  public boolean add(E e) {
      return map.put(e, PRESENT) == null;
  }
  ```

#### **2.3 HashMap 的底层结构**

- `HashMap` 使用 **数组 + 链表 + 红黑树** 存储键值对。
  - 数组：用来快速定位存储桶（Bucket）。
  - 链表：解决哈希冲突（多个键映射到同一个桶时）。
  - 红黑树：当冲突链表长度超过阈值（默认 8）时，将链表转换为红黑树，提高查找效率。
- 关键点：
  - 键（Key）的唯一性通过 `hashCode` 和 `equals` 保证。
  - 值（Value）可以重复。

------

### **3. 使用场景分析**

#### **3.1 HashSet**

- **去重**：用于存储唯一元素，例如去除重复的集合数据。

- **快速查找**：可以高效判断集合中是否存在某个元素。

- 示例：

  ```java
  HashSet<String> set = new HashSet<>();
  set.add("A");
  set.add("B");
  set.add("A"); // 无效，HashSet 保证唯一性
  ```

#### **3.2 HashMap**

- **存储键值对**：用于快速查找值，例如实现缓存。

- **统计计数**：可以通过键值对存储统计数据，例如单词频率计数。

- 示例：

  ```java
  HashMap<String, Integer> map = new HashMap<>();
  map.put("A", 1);
  map.put("B", 2);
  map.put("A", 3); // 键 "A" 的值被更新为 3
  ```

------

### **4. 关键区别总结**

| 特性           | **HashSet**         | **HashMap**                  |
| -------------- | ------------------- | ---------------------------- |
| **用途**       | 存储唯一元素        | 存储键值对                   |
| **底层实现**   | 基于 `HashMap` 实现 | 基于数组 + 链表 + 红黑树实现 |
| **存储内容**   | 仅存储键（Key）     | 存储键（Key）和值（Value）   |
| **键的唯一性** | 元素唯一            | 键唯一，值可重复             |
| **线程安全性** | 否                  | 否                           |

------

### **5. 面试高频问题**

#### **5.1 为什么 HashSet 基于 HashMap 实现？**

- `HashSet` 只需要存储唯一元素，而 `HashMap` 的键（Key）已经是唯一的。
- 复用 `HashMap` 的哈希表结构，可以避免重新实现复杂的哈希算法和冲突处理逻辑。

#### **5.2 HashSet 和 HashMap 的性能如何？**

- 两者性能基本相同，因为 `HashSet` 内部依赖于 `HashMap`。
- 在插入、删除和查找操作中，时间复杂度通常为 **O(1)**（哈希冲突少的情况下）。

#### **5.3 HashSet 是否允许 null？HashMap 是否允许 null？**

- **HashSet**：允许存储一个 `null`。
- **HashMap**：允许一个 `null` 键和多个 `null` 值。

#### **5.4 HashSet 和 HashMap 的线程安全性如何？**

- 都是 **非线程安全** 的。
- 在多线程场景下，可以使用：
  - `HashSet`：通过 `Collections.synchronizedSet` 实现线程安全。
  - `HashMap`：推荐使用 `ConcurrentHashMap`。

------

### **6. 总结复习**

- **核心点**：
  - `HashSet` 是基于 `HashMap` 实现的，内部通过 `HashMap` 存储元素。
  - `HashMap` 是一个底层结构复杂、功能更强大的数据结构，支持键值对存储。
- **适用场景**：
  - 使用 `HashSet` 存储唯一值。
  - 使用 `HashMap` 实现键值对映射或数据统计。
- **面试关键词**：
  1. 底层结构：数组 + 链表 + 红黑树。
  2. 唯一性：通过 `hashCode` 和 `equals` 保证。
  3. 线程安全：默认非线程安全，需使用同步包装类或并发实现。



## Java 并发集合对比分析：HashMap、Hashtable 与 ConcurrentHashMap

![image-20250218105026792](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250218105026792.png)

### 🔍 1. 概述

在 Java 中，`HashMap`、`Hashtable` 和 `ConcurrentHashMap` 都是 `Map` 接口的实现，但它们在**线程安全性**、**性能**和**适用场景**上存在显著区别。

| ⚡ 特性              | 🟢 HashMap     | 🔵 Hashtable                     | 🔴 ConcurrentHashMap                     |
| ------------------- | ------------- | ------------------------------- | --------------------------------------- |
| 🔐 线程安全          | ❌ 不安全      | ✅ 安全（`synchronized` 全局锁） | ✅ 安全（CAS + `synchronized` 细粒度锁） |
| 🔄 同步机制          | 无            | `synchronized`                  | CAS + `synchronized`                    |
| ✅ 允许 `null` 键/值 | ✅ 允许 `null` | ❌ 不允许 `null`                 | ❌ 不允许 `null` 键，✅ 允许 `null` 值    |
| 🚀 性能              | 最高          | 最低                            | 高并发                                  |
| 📌 适用场景          | 单线程        | 旧代码维护                      | 高并发场景                              |

------

### 📌 2. HashMap 详解

- **🛠️ 底层数据结构**：数组 + 链表（JDK 1.8 以后，当链表长度超过 8 时转换为红黑树）
- **⚠️ 线程不安全**：多线程下 `put/get` 可能会出现数据不一致
- **✅ 适用场景**：单线程环境，例如临时数据缓存、非并发数据存储

示例代码：

```java
Map<String, Integer> map = new HashMap<>();
map.put("key", 1);
System.out.println(map.get("key"));
```

------

### 📌 3. Hashtable 详解

- **🛠️ 底层数据结构**：数组 + 链表
- **🔐 线程安全但性能低**：使用 `synchronized` 锁住全部操作，导致线程阻塞
- **✅ 适用场景**：早期 Java 代码，较少使用

示例代码：

```java
Map<String, Integer> table = new Hashtable<>();
table.put("key", 1);
System.out.println(table.get("key"));
```

------

### 📌 4. ConcurrentHashMap 详解

#### 🔄 JDK 1.7 与 JDK 1.8 实现对比

| 🏷️ 版本  | 🔍 底层结构                | 🔄 并发机制                        |
| ------- | ------------------------- | --------------------------------- |
| JDK 1.7 | `Segment[] + HashEntry[]` | **分段锁** (`ReentrantLock`)      |
| JDK 1.8 | `Node[] + 链表 + 红黑树`  | **CAS + `synchronized` + 红黑树** |

#### ⚡ JDK 1.8 关键优化点

1. **🚀 移除 `Segment`**，减少内存消耗，提高扩容效率。
2. **🔄 CAS（Compare-And-Swap）操作**，避免全局锁，提高并发能力。
3. **🔐 更精细的锁机制**，只锁定特定 `Node`，而非整个 `Map`，减少锁冲突。
4. **🌳 红黑树优化**，在链表长度超过 8 时自动转换，提高查询效率。

#### 🌳 红黑树详解

红黑树（Red-Black Tree）是一种**自平衡二叉查找树**，其特点包括：

- 🔴 **节点颜色**：每个节点要么是红色，要么是黑色。
- ⚫ **根节点必须是黑色**。
- ❌ **红色节点不能有两个连续的红色子节点**。
- 🏗️ **从根节点到叶子节点的所有路径上，黑色节点数量必须相同**。
- 🔄 **插入和删除操作后，树会进行颜色调整和旋转，以保持平衡。**

在 `ConcurrentHashMap` 中，红黑树的主要作用是**在哈希冲突较多时，提高查询效率**：

- **当链表长度超过 8**，会自动转换为红黑树，使查询复杂度由 O(n) 降低到 O(log n)。
- **如果扩容后冲突减少，红黑树可能会退化回链表**，以减少空间消耗。

示例代码：

```java
TreeMap<Integer, String> treeMap = new TreeMap<>();
treeMap.put(1, "A");
treeMap.put(2, "B");
System.out.println(treeMap.get(1));
```

------

### 📌 5. 结论

1. **✅ 单线程环境建议使用 `HashMap`**，性能最高。
2. **⚠️ `Hashtable` 已过时，建议使用 `ConcurrentHashMap` 代替。**
3. **🔄 高并发环境建议使用 `ConcurrentHashMap`**，避免全局锁，提高性能。

------

## ConcurrentHashMap在java7和java8的区别

![image-20250213160054153](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250213160054153.png)

1.7中

![image-20250213160113751](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250213160113751.png)

**1.8中**

![image-20250213160306289](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250213160306289.png)

### 扩容机制的区别



# Mybatis

## 在 MyBatis 中，#{} 和 ${} 的区别？

###   回答重点

在 MyBatis 中，`#{} 和 ${}` 的区别主要体现在以下几个方面：

1. **SQL 参数处理方式**：
   - `#{}：` 预编译方式，使用占位符 `?`，可以有效防止 SQL 注入。
   - `${}`：直接将变量的值拼接到 SQL 语句中，可能存在 SQL 注入风险。
2. **使用场景**：
   - `#{}：` 用于传递参数值（安全优先）。
   - `${}`：用于动态拼接 SQL 语句（如表名、列名等）。
3. **性能与安全**：
   - `#{}：` 由于参数绑定是在预编译时完成的，性能和安全性更高。
   - `${}`：直接拼接字符串，易被恶意注入攻击，不建议用于用户输入的值。

------

### 详细解析

#### 1. `#{} 的工作机制`

当使用 `#{} 时，MyBatis 会：

- 将 `#{}` 内的参数转换为 SQL 语句中的 `?`。
- 在执行时，通过 PreparedStatement 对参数进行绑定。

**示例**：

```xml
<select id="selectById" parameterType="int" resultType="User">
  SELECT * FROM user WHERE id = #{id}
</select>
```

生成的 SQL：

```sql
SELECT * FROM user WHERE id = ?
```

#### 2. `${}` 的工作机制

当使用 `${}` 时，MyBatis 会：

- 直接将参数值替换到 SQL 语句中。

**示例**：

```xml
<select id="selectByColumn" parameterType="map" resultType="User">
  SELECT * FROM user WHERE ${column} = #{value}
</select>
```

假如参数为 `column="username"` 和 `value="John"`，生成的 SQL：

```sql
SELECT * FROM user WHERE username = ?
```

#### 3. SQL 注入风险

由于 `${}` 会直接拼接到 SQL 中，如果参数来自用户输入而未做严格校验，可能会导致 SQL 注入攻击。例如：

```xml
<select id="deleteByCondition">
  DELETE FROM user WHERE ${condition}
</select>
```

传入 `condition="1=1; DROP TABLE user"` 时，生成的 SQL：

```sql
DELETE FROM user WHERE 1=1; DROP TABLE user
```

这是非常危险的。

#### 4. 动态 SQL 的应用场景

对于动态 SQL，例如动态拼接表名或列名，必须使用 `${}`，因为 `#{} 不支持表名或列名的动态替换。例如：

```xml
<select id="selectDynamicTable" resultType="User">
  SELECT * FROM ${tableName} WHERE id = #{id}
</select>
```

此时的mapper的写法

```java
  /**
     * 查询动态表的数据
     * @param tableName 表名
     * @param id 主键 ID
     * @return 查询结果（可以是对象，也可以是 Map，根据需要定义返回值类型）
     */
    Map<String, Object> selectDynamicTable(@Param("tableName") String tableName, @Param("id") Long id);
}
```



------

### 知识扩展

#### 1. 安全性对比

| 特性         | `#{} (安全)` | `${} (不安全)`    |
| ------------ | ------------ | ----------------- |
| 预编译       | 是           | 否                |
| SQL 注入风险 | 无           | 高                |
| 使用场景     | 传递参数值   | 动态拼接表名/列名 |

#### 2. 优化建议

1. **优先使用 `#{}`**，避免 SQL 注入风险。
2. **动态 SQL 场景校验输入**：当必须使用 `${}` 时，务必对用户输入进行严格校验，避免拼接恶意数据。
3. **使用框架提供的工具**：如 MyBatis 动态 SQL 标签 `<if>、<choose>` 等，替代直接拼接。

#### 3. 动态 SQL 标签示例

```xml
<select id="findUserByCondition" parameterType="map" resultType="User">
  SELECT * FROM user
  <where>
    <if test="name != null"> AND name = #{name}</if>
    <if test="age != null"> AND age = #{age}</if>
  </where>
</select>
```

------

### 总结

1. `#{}` 和 `${}` 区别：
   - `#{}` 安全，预编译，传递参数值。
   - `${}` 灵活，直接拼接，存在风险。
2. **建议优先使用 `#{}`，仅在必要时使用 `${}`。**

# JUC

![img](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/java-concurrent-overview-1.png)

## 什么是协程？和进程的区别？java中支持协程吗

![image-20250109140053377](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109140053377.png)

### 协程的特点

- **轻量级**：减少了线程创建和销毁的开销，避免了内核态和用户态之间切换的时间成本
- **非抢占式调度**
- **异步化编排**

![image-20250109140139540](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109140139540.png)

### 和线程的区别

![image-20250109140321588](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109140321588.png)

## java中如何创建多线程

## 进程的几种状态

**新建、就绪、运行、阻塞、终止**

![image-20250109142500914](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142500914.png)

## 线程池的七个参数

![image-20250220165746720](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250220165746720.png)

https://www.cnblogs.com/vipstone/p/15983907.html详细博客链接

## 并发三要素

- 原子性 ：**进程的切换导致了原子性的问题**
- 可见性：**CPU存在缓存导致了引出可见性的问题**
- 有序性

![image-20250109142840594](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142840594.png)

![image-20250109142915097](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142915097.png)

![image-20250109142932419](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109142932419.png)

**有序性**，jvm会优化指令的执行顺序

![image-20250109143356270](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250109143356270.png)

# 设计模式

## 什么是设计模式？

- 设计模式是一种通用的代码编程手段，合适的场景用上合适的设计模式，**可以增强代码的灵活性、可维护性、还有可扩展性**

**结构型**：解决类与类之间搭建更大的积木产生的崩塌问题

## 设计模式分为哪三类

关键词：创建、结构、行为

![image-20250114163004851](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114163004851.png)

## 什么是策略模式？

![image-20250114162446726](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114162446726.png)

策略模式（Strategy Pattern）是一种行为型设计模式，用于定义一系列算法，将它们封装起来，并使它们可以互相替换，从而使算法的变化不会影响到使用算法的客户代码。

### 回答重点

1. **核心概念**：策略模式通过将算法封装到独立的类中，使得可以在运行时动态地选择合适的算法。
2. **参与角色**：
   - **抽象策略（Strategy）**：定义算法的接口。
   - **具体策略（ConcreteStrategy）**：实现算法的不同版本。
   - **上下文（Context）**：使用策略的环境，维护对策略对象的引用，并负责与策略的交互。
3. **应用场景**：
   - 系统需要动态地在多个算法之间切换。
   - 各种算法的逻辑是独立的，并且可能经常变化。
   - 需要避免在类中使用多个条件语句来选择算法。

------

### 详细解析

**示例代码**（以折扣计算为例）：
 假设一个电商系统根据不同用户类型（普通用户、会员用户、VIP用户）提供不同的折扣策略。

```java
// 抽象策略
public interface DiscountStrategy {
    double calculateDiscount(double amount);
}

// 具体策略
public class NoDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculateDiscount(double amount) {
        return amount;
    }
}

public class MemberDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculateDiscount(double amount) {
        return amount * 0.9;
    }
}

public class VIPDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculateDiscount(double amount) {
        return amount * 0.8;
    }
}

// 上下文
public class ShoppingCart {
    private DiscountStrategy discountStrategy;

    public ShoppingCart(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    public double calculateFinalAmount(double amount) {
        return discountStrategy.calculateDiscount(amount);
    }

    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }
}

// 测试
public class StrategyPatternDemo {
    public static void main(String[] args) {
        //指定上下文
        ShoppingCart cart = new ShoppingCart(new NoDiscountStrategy());
        System.out.println("Final Amount: " + cart.calculateFinalAmount(100));
		
        //指定上下文为会员用户
        cart.setDiscountStrategy(new MemberDiscountStrategy());
        System.out.println("Final Amount: " + cart.calculateFinalAmount(100));
		
        //指定上下问使用VIP用户的策略
        cart.setDiscountStrategy(new VIPDiscountStrategy());
        System.out.println("Final Amount: " + cart.calculateFinalAmount(100));
    }
}
```

**运行结果**：

```
Final Amount: 100.0
Final Amount: 90.0
Final Amount: 80.0
```

------

### 知识扩展

1. **优点**：
   - **开闭原则**：增加新策略时无需修改上下文代码。
   - **代码清晰**：避免了冗长的条件语句。
   - **提高灵活性**：可以在运行时动态更改策略。
2. **缺点**：
   - 策略类数量可能过多，导致代码复杂度增加。
   - 客户端需要了解不同策略的行为。
3. **实际应用**：
   - 支付方式选择（支付宝、微信、银行卡等）。
   - 排序算法切换（快速排序、归并排序等）。
   - 日志策略（控制台日志、文件日志等）。

------

### 总结

![image-20250114162613592](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114162613592.png)

策略模式通过将算法或行为封装到独立的类中，提供了灵活、可扩展的解决方案，适合需要动态切换或增加算法的场景。然而，在使用策略模式时需要注意策略类的数量增长可能带来的复杂性。

------

### 相关面试题

1. **为什么策略模式比条件语句更优雅？**
2. **在策略模式中如何避免策略类过多的问题？**
3. **策略模式和工厂模式的区别和联系是什么？**
4. **在Java中，策略模式如何与Lambda表达式结合使用？**

## 什么是单例模式？

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

![image-20250114164137625](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114164137625.png)

### 单例模式的优缺点

![image-20250114164315335](https://raw.githubusercontent.com/xiechen274/ChenCsNote/images/images/image-20250114164315335.png)

### 解决多线程模式下的单例重复创建

在多线程环境下实现单例模式时，需要确保单例实例的创建过程是线程安全的。下面是一个基于 **双重检查锁定（Double-Checked Locking）** 的线程安全单例模式示例，这是常见的高效实现方式。

#### 双重检查锁定的单例模式示例

```java
public class Singleton {
    // 使用 volatile 关键字确保变量的可见性和禁止指令重排序
    private static volatile Singleton instance;

    // 私有构造函数，防止外部实例化
    private Singleton() {
        System.out.println("单例实例被创建");
    }

    // 提供全局访问点
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

    // 测试方法
    public void doSomething() {
        System.out.println("单例方法执行");
    }
}

// 测试类
public class SingletonTest {
    public static void main(String[] args) {
        // 启动多个线程同时获取单例实例
        Runnable task = () -> {
            Singleton singleton = Singleton.getInstance();
            singleton.doSomething();
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);
        Thread thread3 = new Thread(task);

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

#### 代码说明

1. **`volatile` 关键字**
    确保 `instance` 在多线程环境中可见，同时禁止指令重排序，避免初始化过程中未完成就被读取的问题。
2. **双重检查锁定**
   - 第一次检查：避免无意义的同步，提升性能。
   - 第二次检查：确保在 `synchronized` 块内也不会重复创建实例，保证线程安全。
3. **`synchronized` 块**
    只在实例未创建时进入同步块，确保性能损耗最小化。
4. **线程安全测试**
    在测试类中通过多个线程并发调用 `getInstance`，验证单例模式的线程安全性。

#### 输出示例（可能略有不同，取决于线程调度）：

```
单例实例被创建
单例方法执行
单例方法执行
单例方法执行
```

#### 优点

1. **线程安全**：使用 `synchronized` 和 `volatile` 确保线程安全。
2. **高效**：双重检查锁定避免每次获取实例时的同步操作，性能更优。
3. **懒加载**：只有在首次调用 `getInstance` 时才会创建实例，节省资源。

#### 缺点

1. 实现稍微复杂，需要理解 `volatile` 和指令重排序问题。
2. 如果系统对性能要求极高，可以考虑其他方式，如静态内部类实现单例。

#### 静态内部类实现单例的替代方式（更简单的线程安全实现）

```java
public class Singleton {
    // 静态内部类
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // 私有构造函数
    private Singleton() {
        System.out.println("单例实例被创建");
    }

    // 提供全局访问点
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

这种方式基于类加载机制，线程安全且简单，无需显式同步。